/* bump-0.1.vapi generated by valac 0.51.3, do not modify. */

namespace Bump {
	/**
	 * Priority queue for asynchronous communications
	 *
	 * This is basically just a layer on top of GeePriorityQueue to
	 * provide thread safety and blocking peek and poll methods, similar
	 * to how GAsyncQueue adds functionality to GQueue.
	 */
	[CCode (cheader_filename = "bump.h")]
	public class AsyncPriorityQueue<G> : Gee.PriorityQueue<G> {
		public AsyncPriorityQueue (owned GLib.CompareDataFunc? compare_func = null);
		public override bool @foreach (Gee.ForallFunc<G> f);
		public new bool offer (G element);
		public override G peek ();
		/**
		 * Peek on the queue, blocking until timeout or data is received
		 *
		 * @param wait the duration to wait. 0 for no waiting, -1 to wait
		 *   forever
		 * @return the data, or null if there was no data
		 */
		public G peek_timed (GLib.TimeSpan wait = -1);
		public override G poll ();
		/**
		 * Poll the queue, blocking until timeout or data is received
		 *
		 * @param wait the duration to wait. 0 for no waiting, -1 to wait
		 *   forever
		 * @return the data, or null if there was no data
		 */
		public G poll_timed (GLib.TimeSpan wait = -1);
		public int waiting_threads { get; private set; }
		/**
		 * Data was added to the queue but no consumers were waiting.
		 */
		public signal void consumer_shortage ();
	}
	/**
	 * Claim on a rivalrous resource
	 *
	 * This API allows for easy interoperability with exceptions without
	 * forcing the use of callbacks, as the lock will be released
	 * automatically when this class is destroyed.
	 *
	 * @see Semaphore.claim
	 * @see ResourcePool.claim
	 */
	[CCode (cheader_filename = "bump.h")]
	public class Claim : GLib.Object, GLib.Initable, GLib.AsyncInitable {
		public Claim ();
		public virtual bool init (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual async bool init_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Release the lock
		 */
		public virtual void release ();
		/**
		 * Whether the claim is active
		 */
		public bool active { get; }
		/**
		 * The length of time this claim has been held
		 */
		public GLib.TimeSpan duration_held { get; }
		/**
		 * The time (monotonic) at which the lock was acquired
		 */
		public int64 time_acquired { get; private set; }
		/**
		 * The time (monotonic) at which the lock was released
		 */
		public int64 time_released { get; private set; }
	}
	/**
	 * An event
	 *
	 * An event is a bit like a signal where all handlers are dispatched
	 * immediately. In other words, as soon as the event is triggered,
	 * all background tasks will be passed to the {@link pool}, all idle
	 * callback tasks will be added to the idle queue, and all blocking
	 * tasks will be woken.
	 *
	 * An interesting side-effect of this is that {@link Event.SourceFunc}
	 * callbacks can be executed after they return false, since other
	 * events may have caused the callback to be queued again. If you
	 * want to make sure that a callback is not invoked again you should
	 * use the cancellable.
	 */
	[CCode (cheader_filename = "bump.h")]
	public class Event<T> : GLib.Object {
		/**
		 * Callback for use with {@link Event.execute} and variants
		 *
		 * @param arg argument passed when triggering the event
		 * @return whatever you want
		 */
		public delegate R Callback<A,R> (A arg) throws GLib.Error;
		/**
		 * Callback for use with {@link Event.add}
		 *
		 * The callback will be dispatched for each event, until it
		 * returns false
		 *
		 * @param arg argument passed when triggering the event
		 * @return whatever you want
		 */
		public delegate bool SourceFunc<A> (A arg);
		/**
		 * Create a new Event
		 *
		 * @param auto_reset whether to automatically reset the event
		 *   after the handlers have been invoked
		 */
		public Event (bool auto_reset = true);
		/**
		 * Add a callback to be executed in the idle queue
		 *
		 * The callback will be added to the idle queue once per event
		 * until it returns false. Note that this means it is possible
		 * that the callback will be executed again after it returns
		 * false, since another event could be triggered (causing the
		 * callback to be added to the idle queue again) before the
		 * callback is actually executed.
		 *
		 * @param func the callback to add
		 * @param priority the priority of the callback
		 * @param cancellable optional cancellable for removing the callback
		 */
		public void add (owned Bump.Event.SourceFunc<T> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute the callback and wait for the result
		 *
		 * This method will block until the event is triggered, then
		 * execute the callback and return the result
		 *
		 * @param func the callback to execute once the event is triggered
		 * @param priority the priority of the callback
		 * @param cancellable optional cancellable for aborting
		 */
		public R execute<R> (Bump.Event.Callback<T,R> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute the callback asynchronously
		 *
		 * This method will wait until the event is triggered, then
		 * execute the (as an idle callback) callback and return the
		 * result.
		 *
		 * @param func the callback to execute once the event is triggered
		 * @param priority the priority of the callback
		 * @param cancellable optional cancellable for aborting
		 */
		public async R execute_async<R> (Bump.Event.Callback<T,R> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute the callback asynchronously
		 *
		 * This method will wait until the event is triggered, then
		 * execute the callback in a thread (from the {@link pool}) and
		 * return the result asynchronously.
		 *
		 * @param func the callback to execute once the event is triggered
		 * @param priority the priority of the callback
		 * @param cancellable optional cancellable for aborting
		 */
		public async R execute_background<R> (Bump.Event.Callback<T,R> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void reset ();
		/**
		 * Trigger the event
		 *
		 * @param value the value to pass to each listener
		 */
		public void trigger (T value) throws GLib.Error;
		/**
		 * Whether to automatically reset the event after dispatching the
		 * handlers
		 */
		public bool auto_reset { get; construct; }
		/**
		 * The pool used to execute background tasks
		 */
		public Bump.TaskQueue pool { get; construct; }
		/**
		 * Whether or not the event is currently triggered
		 */
		public bool triggered { get; private set; }
	}
	/**
	 * Object which creates other objects
	 *
	 * In order to acquire an instance of the type the factory creates
	 * you should use one of the acquire methods ({@link acquire},
	 * {@link acquire_async}, and {@link acquire_background}). The
	 * create methods exist to be overridden in order to properly
	 * integrate with subclasses and should not be called directly
	 * except from within acquire implementations.
	 */
	[CCode (cheader_filename = "bump.h")]
	public abstract class Factory<G> : GLib.Object {
		protected Factory ();
		/**
		 * Synchronously acquire an instance
		 *
		 * @param priority the priority with which to create the instance
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the instance
		 * @see acquire_async
		 * @see acquire_background
		 */
		public abstract unowned G acquire (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Asynchronously acquire an instance
		 *
		 * @param priority the priority with which to create the instance
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the instance
		 * @see acquire
		 * @see acquire_background
		 */
		public abstract async unowned G acquire_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Asynchronously acquire an instance in a background thread
		 *
		 * @param priority the priority with which to create the instance
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the instance
		 * @see acquire
		 * @see acquire_async
		 */
		public abstract async unowned G acquire_background (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Create an instance synchronously
		 *
		 * The default implementation will handle creation of classes
		 * derived from {@link GLib.Object} as well as initialization of
		 * {@link GLib.Initable} implementations. You can override this
		 * method in a subclass to provide a customized method for
		 * instantiating your object synchronously.
		 *
		 * @return the newly created instance
		 */
		protected virtual G create (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Create an instance asynchronously
		 *
		 * For classes which implement {@link GLib.AsyncInitable}, the
		 * default implementation will create an instance of the class
		 * using {@link GLib.Object.new} then initialize the instance
		 * using {@link GLib.AsyncInitable.init_async}. Otherwise, the
		 * default implementation will simply invoke {@link create} in an
		 * idle callback. You can override this method in a subclass to
		 * provide a customized method for instantiating your object
		 * asynchronously.
		 *
		 * @return the newly created instance
		 */
		protected virtual async G create_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Create an instance in a background thread
		 *
		 * The default implementation will call {@link create} in a
		 * background thread. You can override this method in a subclass
		 * to provide a customized method for instantiating your object in
		 * a background thread.
		 *
		 * @return the newly created instance
		 */
		protected virtual async G create_background (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Properties used for GObject construction
		 *
		 * These properties are used by the default implementations of
		 * {@link create}, {@link create_async}, and {@link create_background}.
		 */
		public GLib.Parameter[]? construct_properties { get; set; }
	}
	/**
	 * Lazy initializer
	 */
	[CCode (cheader_filename = "bump.h")]
	public class Lazy<T> : Bump.Factory<T> {
		public Lazy ();
		/**
		 * {@inheritDoc}
		 */
		public override unowned T acquire (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * {@inheritDoc}
		 */
		public override async unowned T acquire_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * {@inheritDoc}
		 */
		public override async unowned T acquire_background (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Whether or not the value has already been initialized
		 */
		public bool is_initialized { get; }
		/**
		 * Pool used to process requests
		 */
		public Bump.TaskQueue pool { get; construct; }
		/**
		 * The value
		 *
		 * This is roughly equivalent to calling {@link acquire}
		 */
		public T value { get; }
	}
	/**
	 * Claim on a resource from a {@link Bump.ResourcePool}
	 */
	[CCode (cheader_filename = "bump.h")]
	public class ResourceClaim<T> : Bump.Claim {
		public ResourceClaim (Bump.ResourcePool pool);
		public override bool init (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override async bool init_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override void release ();
		public Bump.ResourcePool<T> pool { get; construct; }
		public weak T resource { get; }
	}
	/**
	 * Pool of reusable resources
	 *
	 * This class is designed to help manage a group of reusable
	 * resources, especially those that are expensive to acquire. The
	 * pool will automatically grow, and shrink, as required.
	 */
	[CCode (cheader_filename = "bump.h")]
	public class ResourcePool<T> : Bump.Factory<T> {
		/**
		 * Delegate type for {@link ResourcePool}
		 *
		 * @param resource the resource
		 * @return value to return to the invoker
		 * @see execute
		 * @see execute_async
		 * @see execute_background
		 */
		public delegate R Callback<T,R> (T resource) throws GLib.Error;
		/**
		 * Create a resource pool
		 *
		 * @param max_resources the maximum number of resources allowed at
		 *   any given time (0 for unlimited)
		 */
		public ResourcePool (int max_resources = -1);
		/**
		 * Synchronously acquire a resource
		 *
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the resource
		 * @see acquire_async
		 * @see acquire_background
		 */
		public override unowned T acquire (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Asynchronously acquire a resource
		 *
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the resource
		 * @see acquire
		 * @see acquire_background
		 */
		public override async unowned T acquire_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Asynchronously acquire a resource in a background thread
		 *
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the resource
		 * @see acquire
		 * @see acquire_async
		 */
		public override async unowned T acquire_background (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Acquire a claim
		 *
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the newly acquired (and initialized) claim
		 * @see claim_async
		 */
		public Bump.ResourceClaim<T> claim (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Acquire a claim asynchronously
		 *
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the newly acquired (and initialized) claim
		 * @see claim
		 */
		public async Bump.ResourceClaim<T> claim_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute a callback which uses a resource
		 *
		 * @param func the callback to execute
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the return value from the callback
		 * @see execute_async
		 * @see execute_background
		 */
		public R execute<R> (Bump.ResourcePool.Callback<T,R> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Asynchronously execute a callback which uses a resource
		 *
		 * @param func the callback to execute
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the return value from the callback
		 * @see execute
		 * @see execute_background
		 */
		public async R execute_async<R> (owned Bump.ResourcePool.Callback<T,R> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute a callback in a background thread which uses a resource
		 *
		 * @param func the callback to execute
		 * @param priority the priority with which to create the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @return the return value from the callback
		 * @see execute
		 * @see execute_async
		 */
		public async R execute_background<R> (owned Bump.ResourcePool.Callback<T,R> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Release a resource into the pool
		 *
		 * @param resource the resource to release
		 */
		public virtual void release (T resource);
		/**
		 * Number of currently active resources
		 */
		public int active_resources { get; }
		/**
		 * Number of currently idle resources
		 */
		public int idle_resources { get; }
		/**
		 * Amount of time a resource should stay idle before being closed
		 *
		 * Note that this is currently only accurate to around 1 second,
		 * and then only if you're not blocking the main loop.
		 */
		public GLib.TimeSpan max_idle_time { get; set; }
		/**
		 * Maximum number of resources allowed at any given time
		 *
		 * If you do not wish to limit the size of the pool use
		 * 0. Resources will be created as needed and destroyed according
		 * to {@link max_idle_time}.
		 */
		public int max_resources { get; construct; }
		/**
		 * Number of resources which currently exist
		 */
		public int num_resources { get; private set; }
		/**
		 * Pool used to process requests
		 */
		public Bump.TaskQueue pool { get; construct; }
	}
	/**
	 * A high-level non-recursive counting semaphore
	 *
	 * This is a semaphore designed for asynchronous GObject programming. It
	 * integrates well with the main event loop and provides features
	 * such as prioritization, cancellation, and asynchronous
	 * interfaces. Requests with higher priorities will always be
	 * executed first, and requests of equal priorities will be executed
	 * in the order in which they are requested.
	 *
	 * Unfortunately, this is relatively slow compared to lower level
	 * mutex implementations such as GMutex and pthreads. If you don't
	 * require the advanced features, or if you only need short-lived
	 * locks, it would probably be much better to use GMutex.  However,
	 * if you are writing an asynchronous GObject-based application the
	 * convenience provided by these methods can go a long way towards
	 * helping you write applications don't block the main loop and,
	 * therefore, feel faster.
	 */
	[CCode (cheader_filename = "bump.h")]
	public class Semaphore : Bump.TaskQueue {
		public Semaphore (int max_claims = 1);
		public override void add (owned GLib.SourceFunc task, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Synchronously acquire a claim
		 *
		 * @param priority the priority with which to prepare the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @see claim_async
		 */
		public virtual Bump.SemaphoreClaim claim (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Asynchronously acquire a claim
		 *
		 * @param priority the priority with which to prepare the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @see claim
		 */
		public virtual async Bump.SemaphoreClaim claim_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Synchronously acquire an anonymous claim
		 *
		 * You must release the claim with {@link unlock}.
		 *
		 * @param priority the priority with which to prepare the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @see lock_async
		 */
		public void @lock (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Asynchronously acquire an anonymous claim
		 *
		 * You must release the claim with {@link unlock}.
		 *
		 * @param priority the priority with which to prepare the resource
		 * @param cancellable optional cancellable for aborting the opearation
		 * @see lock
		 */
		public async void lock_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override bool process (GLib.TimeSpan wait = 0);
		protected override int spawn (int max = -1);
		/**
		 * Release an anonymous claim
		 *
		 * @see lock
		 * @see lock_async
		 */
		public void @unlock ();
		/**
		 * The current number of claims
		 */
		public int claims { get; private set; }
		/**
		 * The maximum number of claims allowed
		 */
		public int max_claims { get; construct; }
		/**
		 * Pool used to process requests
		 */
		public Bump.TaskQueue pool { get; construct; }
	}
	/**
	 * Claim on a semaphore
	 */
	[CCode (cheader_filename = "bump.h")]
	public class SemaphoreClaim : Bump.Claim {
		public override bool init (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override async bool init_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override void release ();
		/**
		 * The {@link Bump.Semaphore} which this claim operates on
		 */
		public Bump.Semaphore semaphore { get; construct; }
	}
	/**
	 * Base class used for common task queueing behavior
	 */
	[CCode (cheader_filename = "bump.h")]
	public class TaskQueue : GLib.Object, Bump.Queue, Bump.Threading {
		public TaskQueue ();
		/**
		 * Add a task to the queue
		 *
		 * @param task the task
		 * @param priority the priority of the task
		 * @param cancellable optional cancellable for aborting the task
		 */
		public virtual void add (owned GLib.SourceFunc task, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute a callback, blocking until it is done
		 *
		 * The callback will be executed in the calling thread. Note that
		 * the calling thread will block until the callback can be
		 * processed, so if this method is called from the default thread
		 * it will block the main loop and likely lead to a deadlock. When
		 * executing a callback from the default thread you should use
		 * {@link execute_async} or {@link execute_background}.
		 *
		 * @param func the callback to execute
		 * @param priority the priority
		 * @param cancellable optional cancellable for aborting the
		 *   operation
		 */
		public virtual G execute<G> (Bump.Callback<G> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute a callback asynchronously in an idle callback
		 *
		 * The priority argument for this can be a bit misleading when
		 * mixed with {@link execute} and {@link execute_background}. When
		 * a callback is queued with this method it will be sent to the
		 * main loop in order based on priority and the time it was added,
		 * but when the callback is actually executed will then be
		 * controlled by the GLib Main Loop. It will, however, be executed
		 * in the proper order relative to any other callbacks which have
		 * already been sent to the main loop.
		 *
		 * @param func the callback to execute
		 * @param priority the priority
		 * @param cancellable optional cancellable for aborting the
		 *   operation
		 */
		public virtual async G execute_async<G> (owned Bump.Callback<G> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Execute a callback in a background thread
		 *
		 * Although the supplied callback will be executed in a background
		 * thread, the async function call will be finished in an idle
		 * callback for the thread-default main context.
		 *
		 * @param func the callback to execute
		 * @param priority the priority
		 * @param cancellable optional cancellable for aborting the
		 *   operation
		 */
		public virtual async G execute_background<G> (owned Bump.Callback<G> func, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Get the global task queue
		 *
		 * This will retrieve a global task queue, creating it if it does
		 * not exist.
		 */
		public static Bump.TaskQueue get_global ();
		public virtual bool process (GLib.TimeSpan wait = 0);
		/**
		 * Spawn new threads if appropriate
		 *
		 * @return whether or not a new thread was created
		 */
		protected virtual int spawn (int max = -1);
	}
	/**
	 * A Queue
	 */
	[CCode (cheader_filename = "bump.h")]
	public interface Queue : GLib.Object {
		/**
		 * Process a single task in the queue
		 *
		 * This is method should not usually be called by user code (which
		 * should usually be calling one of the *_execute methods
		 * instead). This method assumes that any locks have already been
		 * acquired.
		 *
		 * @param wait the maximum number of microseconds to wait for an
		 *   item to appear in the queue (0 for no waiting, < 0 to wait
		 *   indefinitely).
		 * @return true if an item was processed, false if not
		 */
		public abstract bool process (GLib.TimeSpan wait = 0);
		/**
		 * The number of items currently queued
		 *
		 * Please keep in mind that in multi-threaded code this value may
		 * have changed by the time you see it.
		 */
		public abstract int length { get; }
	}
	/**
	 * A structure which spawns threads
	 */
	[CCode (cheader_filename = "bump.h")]
	public interface Threading : GLib.Object, Bump.Queue {
		/**
		 * Number of threads currently waiting for input
		 *
		 * @return number of threads waiting for input
		 */
		public int get_idle_threads ();
		/**
		 * Get the maximum amount of time to allow a thread to remain unused
		 *
		 * For unlimited, use -1. For none, use 0.
		 *
		 * @return The maximum amount of time (in microseconds) to allow a
		 *   thread to remain unused before removing it
		 * @see set_max_idle_time
		 */
		public GLib.TimeSpan get_max_idle_time ();
		/**
		 * Get the maximum number of threads to spawn
		 *
		 * Note that this isn't necessarily the maximum number of threads
		 * which could be in use, since threads spawned prior to lowering
		 * this value will not be destroyed until the maximum idle time is
		 * exceeded.
		 *
		 * @return the maximum number of threads, or -1 for unlimited
		 * @see set_max_threads
		 * @see increase_max_threads
		 * @see get_max_idle_time
		 * @see set_max_idle_time
		 */
		public int get_max_threads ();
		/**
		 * Total number of threads currently running
		 *
		 * @return number of threads currently running
		 * @see get_idle_threads
		 */
		public int get_num_threads ();
		/**
		 * Update the max_threads property to the new value if it permits
		 * more threads than the old value.
		 *
		 * Setting the max_threads using {@link set_max_threads} can
		 * clobber the value, so you should prefer to use this method if
		 * you want to increase the number of threads.
		 *
		 * @param new_max_threads new maximum number of threads
		 * @see set_max_threads
		 * @see get_max_threads
		 */
		public void increase_max_threads (int new_max_threads);
		/**
		 * Run user-provided code
		 *
		 * Implementations should use this method to execute user provided
		 * code in a managed thread.
		 *
		 * @param func the callback to execute
		 * @return value returned by the callback
		 */
		protected bool run_task (GLib.SourceFunc func);
		/**
		 * Set the maximum amount of time to allow a thread to remain unused
		 *
		 * For unlimited, use -1. For none, use 0.
		 *
		 * Changing this value will not have any effect on an already
		 * waiting thread, though the thread will pick up the new value
		 * next time it needs to wait.
		 *
		 * @param value maximum amount of time (in microseconds) to allow
		 *   a thread to remain unused before removing it
		 * @see set_max_idle_time
		 */
		public void set_max_idle_time (GLib.TimeSpan value);
		/**
		 * Set the maximum number of threads to spawn
		 *
		 * Note that this isn't necessarily the maximum number of threads
		 * which could be in use, since threads spawned prior to lowering
		 * this value will not be destroyed until max idle time is
		 * exceeded.
		 *
		 * If you want to increase the maximum number of threads, you
		 * should use {@link increase_max_threads} instead.
		 *
		 * @param value the maximum number of threads, or -1 for unlimited
		 * @see get_max_threads
		 * @see increase_max_threads
		 */
		public void set_max_threads (int value);
		/**
		 * Possibly spawn new thread(s)
		 *
		 * This method will spawn up to max_new_threads new threads if no
		 * constraints (i.e., maximum number of threads) would be violated
		 * by doing so.
		 *
		 * @param max_new_threads the maximum number of new threads to
		 *   spawn, or -1 for unlimited
		 * @return the number of new threads spawned
		 */
		protected virtual int spawn (int max_new_threads);
	}
	/**
	 * Callback which is invoked by the {@link TaskQueue.execute} and
	 * {@link TaskQueue.execute_async} functions.
	 *
	 * This is similar to {@link GLib.ThreadFunc}, except the delegate
	 * can throw exceptions.
	 */
	[CCode (cheader_filename = "bump.h")]
	public delegate G Callback<G> () throws GLib.Error;
}
