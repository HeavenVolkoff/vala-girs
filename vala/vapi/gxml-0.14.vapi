/* gxml-0.14.vapi generated by valac 0.35.2.2-136c4-dirty, do not modify. */

[CCode (gir_namespace = "GXml", gir_version = "0.14")]
namespace GXml {
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomCustomEventInit : GXml.DomEventInit {
		public DomCustomEventInit ();
		public GLib.Value? detail { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomElementList : Gee.ArrayList<GXml.DomElement>, GXml.DomHTMLCollection {
		public DomElementList ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomErrorName : GLib.Object {
		public DomErrorName ();
		public int get_code (string error_name);
		public string get_name (int error_code);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomEventInit : GLib.Object {
		public DomEventInit ();
		public bool bubbles { get; set; }
		public bool cancelable { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomMutationObserverInit : GLib.Object {
		public DomMutationObserverInit ();
		public Gee.List<string> attribute_filter { get; set; }
		public bool attribute_old_value { get; set; }
		public bool attributes { get; set; }
		public bool character_data { get; set; }
		public bool character_data_old_value { get; set; }
		public bool child_list { get; set; }
		public bool subtree { get; set; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomNodeFilter : GLib.Object {
		public delegate int AcceptNode (GXml.Node node);
		public const int FILTER_ACCEPT;
		public const int FILTER_REJECT;
		public const int FILTER_SKIP;
		public const int SHOW_ALL;
		public const int SHOW_ATTRIBUTE;
		public const int SHOW_CDATA_SECTION;
		public const int SHOW_COMMENT;
		public const int SHOW_DOCUMENT;
		public const int SHOW_DOCUMENT_FRAGMENT;
		public const int SHOW_DOCUMENT_TYPE;
		public const int SHOW_ELEMENT;
		public const int SHOW_ENTITY;
		public const int SHOW_ENTITY_REFERENCE;
		public const int SHOW_NOTATION;
		public const int SHOW_PROCESSING_INSTRUCTION;
		public const int SHOW_TEXT;
		public DomNodeFilter ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomTimeStamp : GLib.Object {
		public DomTimeStamp ();
		public string to_string ();
		public GLib.DateTime time { get; set; }
	}
	/**
	 * Convenient class for a list of {@link GXml.Element} objects based on
	 * {@link Gee.ListArray}, with good support for bindings.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class ElementList : Gee.ArrayList<GXml.Element>, GXml.DomHTMLCollection {
		public ElementList ();
	}
	/**
	 * Convenient static methods for enumeration serialization to string.
	 * 
	 * Enumerations have a set of utility methods to better represent on
	 * serialisation/deserialization.
	 * 
	 * Enumerations could be converted to string using its definition on {@link GLib.EnumClass},
	 * by taking its nick name directly or converting to its camel case representation.
	 * 
	 * Any enumeration value type in a <code>GLib.Object</code>'s property could be
	 * deserialized from its definition given on {@link GLib.EnumClass} (name and
	 * nick) or from its camel case representation.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Enumeration {
		public Enumeration ();
		/**
		 * Introspect an enumeration to get value's nick name.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @enumeration.
		 */
		public static string get_nick (GLib.Type enumeration, int val) throws GLib.Error;
		/**
		 * Introspect an enumeration to get value's nick name and transform
		 * to camel case representation.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @param enumeration.
		 */
		public static string get_nick_camelcase (GLib.Type enumeration, int val) throws GLib.Error;
		/**
		 * Transform enumeration's value to its string representation.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @enumeration.
		 * @param use_nick makes to returns value's nick name in {@link GLib.EnumClass}
		 * @param camelcase makes to returns value's nick name in {@link GLib.EnumClass}
		 * as camel case representation. If @use_nick is set this take no effect.
		 */
		public static string get_string (GLib.Type enumeration, int val, bool use_nick = false, bool camelcase = false) throws GLib.Error;
		/**
		 * Parse @val to an enumeration's value.
		 * 
		 * Returns: an {@link GLib.EnumValue} representing an enumeration's value.
		 * 
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val a string to parse an enum value of type @param enumeration.
		 * as camel case representation. If @use_nick is set this take no effect.
		 */
		public static GLib.EnumValue? parse (GLib.Type enumeration, string val) throws GLib.Error;
		/**
		 * From a integer valuer calculates a valid {@link GLib.EnumValue} for a
		 * {@link GLib.Type}. 
		 *
		 * Returns: a {@link GLib.EnumValue} or null if fails.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer in a valid range in the enumeration.
		 */
		public static GLib.EnumValue? parse_integer (GLib.Type enumeration, int val);
		/**
		 * Transform an enumeration in an array of {@link GLib.EnumValue}.
		 * 
		 * Returns: an array of {@link GLib.EnumValue} representing an enumeration.
		 * 
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 */
		public static unowned GLib.EnumValue[] to_array (GLib.Type enumeration);
		/**
		 * Transform an enumeration in an array of strings representing enumeration values.
		 *
		 * Returns: an array of strings representing an enumeration.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 */
		public static string[] to_string_array (GLib.Type enumeration) throws GLib.Error;
	}
	/**
	 * Class implemeting {@link GXml.Attribute} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GAttribute : GXml.GNode, GXml.Attribute, GXml.DomAttr {
		public GAttribute (GXml.GDocument doc, Xml.Attr* node);
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
		public override GXml.Node parent { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.CDATA} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GCDATA : GXml.GNode, GXml.CDATA {
		public GCDATA (GXml.GDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	/**
	 * Base class for character data
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GCharacterData : GXml.GNonDocumentChildNode, GXml.Character, GXml.DomCharacterData {
		public GCharacterData ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GChildNode : GXml.GNode, GXml.DomChildNode {
		public GChildNode ();
	}
	/**
	 * Class implemeting {@link GXml.Comment} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GComment : GXml.GCharacterData, GXml.Comment, GXml.DomComment {
		public GComment (GXml.GDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.Document} interface, not tied to libxml-2.0 library.
	 *
	 * This class use {@link Xml.TextWriter} to write down XML documents using
	 * its contained {@link GXml.Node} children or other XML structures.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDocument : GXml.GNode, GXml.Document, GXml.DomParentNode, GXml.DomNonElementParentNode, GXml.DomDocument, GXml.DomXMLDocument, GXml.XPathContext {
		protected Xml.Buffer _buffer;
		protected string _character_set;
		protected string _compat_mode;
		protected GXml.DomEvent _constructor;
		protected string _content_type;
		protected GXml.GImplementation _implementation;
		protected string _origin;
		protected string _url;
		protected Xml.Doc* doc;
		public GDocument ();
		public GDocument.from_doc (Xml.Doc doc);
		public GDocument.from_file (GLib.File file, int options = 0, GLib.Cancellable? cancel = null) throws GLib.Error;
		public GDocument.from_path (string path, int options = 0) throws GLib.Error;
		public GDocument.from_stream (GLib.InputStream istream) throws GLib.Error;
		public GDocument.from_string (string str, int options = 0) throws GLib.Error;
		public GDocument.from_uri (string uri, int options = 0) throws GLib.Error;
		/**
		 * Uses libxml2 internal dump to memory function over owned 
		 */
		public string libxml_to_string ();
		public virtual bool save (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual bool save_as (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override bool set_namespace (string uri, string? prefix);
		public override string to_string ();
		public override Gee.Map<string,GXml.Node> attrs { owned get; }
		public override Gee.BidirList<GXml.Node> children_nodes { owned get; }
		public override GXml.Document document { get; }
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDocumentFragment : GXml.GDocument, GXml.DomDocumentFragment {
		public GDocumentFragment (GXml.GDocument d);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDocumentType : GXml.GChildNode, GXml.DomNode, GXml.DomChildNode, GXml.DomDocumentType {
		protected string _name;
		protected string _public_id;
		protected string _system_id;
		public GDocumentType ();
		public GDocumentType.with_ids (string name, string public_id, string system_id);
		public GDocumentType.with_name (string name);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomCustomEvent : GXml.GDomEvent {
		protected GLib.Value? _detail;
		public GDomCustomEvent ();
		public void init_custom_event (string type, bool bubbles, bool cancelable, GLib.Value? detail);
		public GLib.Value? detail { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomEvent : GLib.Object, GXml.DomEvent {
		protected bool _bubbles;
		protected bool _cancelable;
		protected GXml.DomEventTarget _current_target;
		protected bool _default_prevented;
		protected string _etype;
		protected GXml.DomEvent.Phase _event_phase;
		protected GXml.DomEventTarget _event_target;
		protected GXml.DomEvent.Flags _flags;
		protected bool _is_trusted;
		protected GXml.DomTimeStamp _time_stamp;
		public GDomEvent ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomHTMLCollection : Gee.ArrayList<GXml.DomElement>, GXml.DomHTMLCollection {
		public GDomHTMLCollection ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomNodeIterator : GLib.Object, GXml.DomNodeIterator {
		protected GXml.DomNodeFilter _filter;
		protected bool _pointer_before_reference_node;
		protected GXml.DomNode _reference_node;
		protected GXml.DomNode _root;
		protected int _what_to_show;
		public GDomNodeIterator (GXml.DomNode n, int what_to_show, GXml.DomNodeFilter filter);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomRange : GLib.Object, GXml.DomRange {
		protected bool _collapse;
		protected GXml.DomNode _common_ancestor_container;
		protected GXml.DomDocument _document;
		protected GXml.DomNode _end_container;
		protected int _end_offset;
		protected GXml.DomNode _start_container;
		protected int _start_offset;
		public GDomRange (GXml.DomDocument doc);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomSettableTokenList : GXml.GDomTokenList, GXml.DomSettableTokenList {
		public GDomSettableTokenList (GXml.DomElement e, string? attr);
	}
	/**
	 * List of string tokens.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomTokenList : Gee.ArrayList<string>, GXml.DomTokenList {
		protected string _attr;
		protected GXml.DomElement _element;
		public GDomTokenList (GXml.DomElement e, string? attr);
		public void update ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDomTreeWalker : GLib.Object, GXml.DomTreeWalker {
		protected GXml.DomNode _current_node;
		protected GXml.DomNodeFilter? _filter;
		protected GXml.DomNode _root;
		protected int _what_to_show;
		public GDomTreeWalker (GXml.DomNode r, int w, GXml.DomNodeFilter f);
	}
	/**
	 * Class implemeting {@link GXml.Element} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GElement : GXml.GNonDocumentChildNode, GXml.DomParentNode, GXml.DomElement, GXml.Element, GXml.XPathContext {
		public GElement (GXml.GDocument doc, Xml.Node* node);
		public override string to_string ();
		public override string value { owned get; set; }
	}
	/**
	 * Implementation of {@link Gee.AbstractMap} to handle {@link Xml.Node} attributes
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GHashMapAttr : Gee.AbstractMap<string,GXml.Node>, GXml.DomNamedNodeMap {
		public class Entry : Gee.Map.Entry<string,GXml.Node> {
			public Entry (GXml.GDocument doc, Xml.Attr* attr);
			public override string key { get; }
			public override bool read_only { get; }
			public override GXml.Node value { get; set; }
		}
		public class Iterator : GLib.Object, Gee.MapIterator<string,GXml.Node> {
			public Iterator (GXml.GDocument doc, Xml.Node* node);
		}
		public GHashMapAttr (GXml.GDocument doc, Xml.Node* node);
		public override void clear ();
		public override GXml.Node @get (string key);
		public override bool has (string key, GXml.Node value);
		public override bool has_key (string key);
		public override Gee.MapIterator<string,GXml.Node> map_iterator ();
		public override void @set (string key, GXml.Node value);
		public override bool unset (string key, out GXml.Node value = null);
		public override Gee.Set<Gee.Map.Entry<string,GXml.Node>> entries { owned get; }
		public override Gee.Set<string> keys { owned get; }
		public override bool read_only { get; }
		public override int size { get; }
		public override Gee.Collection<GXml.Node> values { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GImplementation : GLib.Object, GXml.DomImplementation {
		public GImplementation ();
	}
	/**
	 * A {@link Gee.AbstractBidirList} implementation to access {@link Xml.Node} collection
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GListChildren : Gee.AbstractBidirList<GXml.Node>, GXml.DomNodeList, GXml.DomHTMLCollection {
		public class Iterator : GLib.Object, Gee.Traversable<GXml.Node>, Gee.Iterator<GXml.Node>, Gee.BidirIterator<GXml.Node>, Gee.ListIterator<GXml.Node>, Gee.BidirListIterator<GXml.Node> {
			public Iterator (GXml.GDocument doc, Xml.Node* node);
		}
		public GListChildren (GXml.GDocument doc, Xml.Node* node);
		public override bool add (GXml.Node item);
		public override new Gee.BidirListIterator<GXml.Node> bidir_list_iterator ();
		public override void clear ();
		public override bool contains (GXml.Node item);
		public override GXml.Node @get (int index);
		public override int index_of (GXml.Node item);
		/**
		 * Insert @item before @index
		 */
		public override void insert (int index, GXml.Node item);
		public override Gee.Iterator<GXml.Node> iterator ();
		public override Gee.ListIterator<GXml.Node> list_iterator ();
		public override bool remove (GXml.Node item);
		/**
		 * Removes a node at @index. This method never returns a valid pointer.
		 */
		public override GXml.Node remove_at (int index);
		/**
		 * This method is ignored by default.
		 */
		public override void @set (int index, GXml.Node item);
		public override Gee.List<GXml.Node>? slice (int start, int stop);
		public override bool read_only { get; }
		public override int size { get; }
	}
	/**
	 * A {@link Gee.AbstractList} implementation to access {@link Xml.Ns} namespaces collection
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GListNamespaces : Gee.AbstractList<GXml.Namespace> {
		public class Iterator : GLib.Object, Gee.Traversable<GXml.Namespace>, Gee.Iterator<GXml.Namespace>, Gee.ListIterator<GXml.Namespace> {
			public Iterator (Xml.Node* node);
		}
		public GListNamespaces (GXml.GDocument doc, Xml.Node* node);
		public override bool add (GXml.Namespace item);
		public override void clear ();
		public override bool contains (GXml.Namespace item);
		public override new GXml.Namespace @get (int index);
		public override int index_of (GXml.Namespace item);
		public override void insert (int index, GXml.Namespace item);
		public override Gee.Iterator<GXml.Namespace> iterator ();
		public override Gee.ListIterator<GXml.Namespace> list_iterator ();
		public override bool remove (GXml.Namespace item);
		public override GXml.Namespace remove_at (int index);
		public override new void @set (int index, GXml.Namespace item);
		public override Gee.List<GXml.Namespace>? slice (int start, int stop);
		public override bool read_only { get; }
		public override int size { get; }
	}
	/**
	 * Class implemeting {@link GXml.Namespace}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GNamespace : GLib.Object, GXml.Namespace {
		public GNamespace (Xml.Ns* ns);
		public Xml.Ns* get_internal_ns ();
	}
	/**
	 * Base interface providing basic functionalities to all GXml interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class GNode : GLib.Object, GXml.DomEventTarget, GXml.DomNode, GXml.Node {
		protected string _base_uri;
		protected GXml.GDocument _doc;
		protected Xml.Node* _node;
		public GNode ();
		public Xml.Node* get_internal_node ();
		public virtual bool set_namespace (string uri, string? prefix);
		public static GXml.Node to_gnode (GXml.GDocument doc, Xml.Node* node);
		public virtual string to_string ();
		public virtual Gee.Map<string,GXml.Node> attrs { owned get; }
		public virtual Gee.BidirList<GXml.Node> children_nodes { owned get; }
		public virtual GXml.Document document { get; }
		public virtual string name { owned get; }
		public virtual Gee.List<GXml.Namespace> namespaces { owned get; }
		public virtual GXml.Node parent { owned get; }
		public virtual GXml.NodeType type_node { get; }
		public virtual string value { owned get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GNonDocumentChildNode : GXml.GChildNode, GXml.DomNonDocumentTypeChildNode {
		public GNonDocumentChildNode ();
	}
	/**
	 * Class implemeting {@link GXml.ProcessingInstruction} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GProcessingInstruction : GXml.GCharacterData, GXml.ProcessingInstruction, GXml.DomProcessingInstruction {
		public GProcessingInstruction (GXml.GDocument doc, Xml.Node* node);
	}
	/**
	 * Class implemeting {@link GXml.Text} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GText : GXml.GCharacterData, GXml.Text, GXml.DomText {
		public GText (GXml.GDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GXPathObject : GLib.Object, GXml.XPathObject {
		public GXPathObject (GXml.GDocument document, Xml.XPath.Object* pointer);
	}
	/**
	 * A class impementing {@link GomCollection} to store references to
	 * child {@link DomElement} of {@link element}, using an index.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomArrayList : GLib.Object, GXml.GomCollection {
		/**
		 * Element used to refer of containier element. You should define it at construction time
		 * our set it as a construction property.
		 */
		protected GXml.GomElement _element;
		/**
		 * Local name of {@link DomElement} objects of {@link element}, which could be
		 * contained in this collection.
		 *
		 * Used when reading to add elements to collection. You can set it at construction time,
		 * by, for example, instantaiting a object of the type {@link GomCollection.items_type}
		 * then use {@link GomElement.local_name}'s value.
		 */
		protected string _items_name;
		/**
		 * Objects' type to be referenced by this collection and to deserialize objects.
		 * Derived classes, can initilize this value at constructor or as construct property.
		 *
		 * Used when reading and at initialization time, to know {@link GomElement.local_name}
		 * at runtime.
		 */
		protected GLib.Type _items_type;
		/**
		 * A collection of node's index refered. Don't modify it manually.
		 */
		protected GLib.Queue<int> _nodes_index;
		public GomArrayList ();
		/**
		 * Initialize an {@link GomArrayList} to use an element as child parent
		 * and items of given type. Derived classes are encourage to provide its
		 * own definition, chaining up, to correctly initialize a collection.
		 */
		public GomArrayList.initialize (GXml.GomElement element, GLib.Type items_type);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomAttr : GXml.GomNode, GXml.DomAttr {
		protected string _namespace_uri;
		protected string _prefix;
		public GomAttr (GXml.DomElement element, string name, string value);
		public GomAttr.@namespace (GXml.DomElement element, string namespace_uri, string? prefix, string name, string value);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomBoolean : GLib.Object, GXml.GomProperty {
		protected string _attribute_name;
		protected bool _value;
		public GomBoolean ();
		public bool get_boolean ();
		public void set_boolean (bool value);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomCharacterData : GXml.GomNode, GXml.DomNonDocumentTypeChildNode, GXml.DomChildNode, GXml.DomCharacterData {
		public GomCharacterData ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomComment : GXml.GomCharacterData, GXml.DomComment {
		public GomComment (GXml.DomDocument doc, string data);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomDocument : GXml.GomNode, GXml.DomParentNode, GXml.DomNonElementParentNode, GXml.DomDocument, GXml.DomXMLDocument {
		protected string _character_set;
		protected string _compat_mode;
		protected GXml.DomEvent _constructor;
		protected string _content_type;
		protected GXml.DomImplementation _implementation;
		protected string _origin;
		protected string _url;
		public GomDocument ();
		/**
		 * Creates a document parsing a file.
		 */
		public GomDocument.from_file (GLib.File file) throws GLib.Error;
		public GomDocument.from_path (string path) throws GLib.Error;
		/**
		 * Creates a document parsing a stream.
		 */
		public GomDocument.from_stream (GLib.InputStream stream) throws GLib.Error;
		/**
		 * Creates a document parsing a string.
		 */
		public GomDocument.from_string (string str) throws GLib.Error;
		/**
		 * Creates a document parsing a URI file.
		 */
		public GomDocument.from_uri (string uri) throws GLib.Error;
		/**
		 * Reads a file contents and parse it to document.
		 */
		public void read_from_file (GLib.File file) throws GLib.Error;
		/**
		 * Reads a string and parse it to document.
		 */
		public void read_from_string (string str) throws GLib.Error;
		/**
		 * Writes a dump XML representation of document to a file.
		 */
		public void write_file (GLib.File file) throws GLib.Error;
		/**
		 * Writes a dump XML representation of document to a stream.
		 */
		public void write_stream (GLib.OutputStream stream) throws GLib.Error;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomDocumentFragment : GXml.GomNode, GXml.DomParentNode, GXml.DomNonElementParentNode, GXml.DomDocumentFragment {
		public GomDocumentFragment (GXml.DomDocument doc);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomDocumentType : GXml.GomNode, GXml.DomNode, GXml.DomChildNode, GXml.DomDocumentType {
		protected string _name;
		protected string _public_id;
		protected string _system_id;
		public GomDocumentType ();
		public GomDocumentType.with_ids (GXml.DomDocument doc, string name, string public_id, string system_id);
		public GomDocumentType.with_name (GXml.DomDocument doc, string name);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomDouble : GLib.Object, GXml.GomProperty {
		protected string _attribute_name;
		protected double _value;
		public GomDouble ();
		public double get_double ();
		public void set_double (double value);
		public uint decimals { get; set; }
	}
	/**
	 * A GXml Object Model (GOM) implementation of {@link GomElement}.It can be used
	 * transparently as {@link DomElement} in a XML tree.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomElement : GXml.GomNode, GXml.DomChildNode, GXml.DomNonDocumentTypeChildNode, GXml.DomParentNode, GXml.DomElement, GXml.GomObject {
		/**
		 * Holds attributes in current node, using attribute's name as key
		 * and it's value as value. Appends namespace prefix to attribute's name as
		 * key if a namespaced attribute.
		 */
		public class Attributes : Gee.HashMap<string,string>, GXml.DomNamedNodeMap {
			/**
			 * Holds {@link GomElement} refrence to attributes' parent element.
			 * Derived classes should not modify, but set at construction time.
			 */
			protected GXml.GomElement _element;
			public Attributes (GXml.GomElement element);
		}
		/**
		 * Reference to {@link Attributes} for element's attributes.
		 * Derived classes should avoid to modify it.
		 */
		protected GXml.GomElement.Attributes _attributes;
		/**
		 * Use this field to set node's namespace URI. Can used to set it at construction time.
		 */
		protected string _namespace_uri;
		public GomElement ();
		public GomElement.initialize (GXml.DomDocument doc, string local_name);
		public new string? lookup_namespace_uri (string? prefix);
		public new string? lookup_prefix (string? nspace);
		public GomElement.@namespace (GXml.DomDocument doc, string? namespace_uri, string? prefix, string local_name);
		/**
		 * Uses element's {@link GomDocument} to parse an XML file, deserializing it.
		 */
		public void read_from_file (GLib.File f) throws GLib.Error;
		/**
		 * Uses element's {@link GomDocument} to parse an XML string, deserializing it.
		 */
		public void read_from_string (string str) throws GLib.Error;
		/**
		 * Uses element's {@link GomDocument} to write an XML to a file, serializing it.
		 */
		public void write_file (GLib.File f) throws GLib.Error;
		/**
		 * Uses element's {@link GomDocument} to write an XML to a stream, serializing it.
		 */
		public void write_stream (GLib.OutputStream stream) throws GLib.Error;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomEnum : GLib.Object, GXml.GomProperty {
		protected string _attribute_name;
		protected GLib.Type _enum_type;
		protected int _value;
		public GomEnum ();
		public int get_enum ();
		public void set_enum (int value);
		public GLib.Type enum_type { get; set construct; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomFloat : GXml.GomDouble {
		public GomFloat ();
		public float get_float ();
		public void set_float (float value);
	}
	/**
	 * A class impementing {@link GomCollection} to store references to
	 * child {@link DomElement} of {@link element}, using an attribute in
	 * items as key.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomHashMap : GLib.Object, GXml.GomCollection {
		protected string _attribute_key;
		/**
		 * Element used to refer of containier element. You should define it at construction time
		 * our set it as a construction property.
		 */
		protected GXml.GomElement _element;
		/**
		 * A hashtable with all keys as string to node's index refered. Don't modify it manually.
		 */
		protected GLib.HashTable<string,int> _hashtable;
		/**
		 * {@link DomElement.local_name} used to identify nodes at runtime on readding
		 * XML documents. You can set it at construction time see {@link GomCollection.items_name}
		 */
		protected string _items_name;
		/**
		 * Objects' type to be referenced by this collection and to deserialize objects.
		 * Derived classes, can initilize this value at constructor or as construct property.
		 *
		 * Used when reading and at initialization time, to know {@link GomElement.local_name}
		 * at runtime.
		 */
		protected GLib.Type _items_type;
		/**
		 * A collection of node's index refered. Don't modify it manually.
		 */
		protected GLib.Queue<int> _nodes_index;
		public GomHashMap ();
		/**
		 * Returns an {@link DomElement} in the collection using a string key.
		 */
		public new GXml.DomElement? @get (string key);
		public GomHashMap.initialize (GXml.GomElement element, GLib.Type items_type, string attribute_key);
		/**
		 * An attribute's name in items to be added and used to retrieve a key to
		 * used in collection.
		 */
		public string attribute_key { get; set construct; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomImplementation : GLib.Object, GXml.DomImplementation {
		public GomImplementation ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomInt : GLib.Object, GXml.GomProperty {
		protected string _attribute_name;
		protected int _value;
		public GomInt ();
		public int get_integer ();
		public void set_integer (int value);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomNode : GLib.Object, GXml.DomEventTarget, GXml.DomNode {
		/**
		 * Use this field to set node's base URI. Can be set at construction time.
		 *
		 * See [[https://www.w3.org/TR/dom/#concept-node-base-url]]
		 */
		protected string _base_uri;
		/**
		 * Use this field to set node's child nodes. Derived classes should avoid to modify it.
		 */
		protected GXml.GomNodeList _child_nodes;
		protected GXml.DomDocument _document;
		/**
		 * Use this field to set node's local name. Can be set at construction time.
		 */
		protected string _local_name;
		/**
		 * Use this field to set node's Type. Derived classes should avoid to modify it.
		 */
		protected GXml.DomNode.NodeType _node_type;
		/**
		 * Use this field to hold node's value. Can be set at construction time.
		 */
		protected string _node_value;
		/**
		 * Use this field to holding node's parent node. Derived classes should avoid to modify it.
		 */
		protected GXml.DomNode _parent;
		/**
		 * Use this field to set node's prefix. Can be set at construction time.
		 */
		protected string _prefix;
		public GomNode ();
	}
	/**
	 * List of {@link DomNode} implementing {@link DomNodeList}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomNodeList : Gee.ArrayList<GXml.DomNode>, GXml.DomNodeList {
		public GomNodeList ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomProcessingInstruction : GXml.GomCharacterData, GXml.DomProcessingInstruction {
		public GomProcessingInstruction (GXml.DomDocument doc, string target, string data);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GomText : GXml.GomCharacterData, GXml.DomText {
		public GomText (GXml.DomDocument doc, string data);
	}
	/**
	 * HML parsing suport. Document handling
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HtmlDocument : GXml.GDocument {
		public HtmlDocument ();
		public HtmlDocument.from_file (GLib.File file, int options = 0, GLib.Cancellable? cancel = null) throws GLib.Error;
		public HtmlDocument.from_path (string path, int options = 0) throws GLib.Error;
		public HtmlDocument.from_string (string html, int options = 0);
		public HtmlDocument.from_uri (string uri, int options = 0) throws GLib.Error;
		public static int default_options { get; }
	}
	/**
	 * Convenient class for a list of {@link GXml.Node} objects based on
	 * {@link Gee.ListArray}, with good support for bindings.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NodeList : Gee.ArrayList<GXml.Node> {
		public NodeList ();
		public new GXml.Node @get (int index);
		public new GXml.Node[] to_array ();
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on {@link Gee.ArrayList}.
	 * 
	 * It is derived  It implements {@link Serializable} and {@link SerializableCollection}
	 * interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableArrayList<G> : Gee.ArrayList<G>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		public SerializableArrayList ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Represent any boolean property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableBool : GLib.Object, GXml.SerializableProperty {
		public SerializableBool ();
		/**
		 * Parse the stored value, from the XML property, to a {@link int}. This parsing
		 * may is different from the actual stored string. If can't be parsed to a valid
		 * boolean, this method will always return false.
		 */
		public bool get_value ();
		/**
		 * Given boolean value is parsed to string and then stored.
		 */
		public void set_value (bool val);
		/**
		 * Parse actual stored string to a boolean and returns the result. See {@link get_value}
		 */
		public string to_string ();
	}
	/**
	 * Any {@link GXml.Serializable} class having a collection managed list of
	 * {@link GXml.Node} must implement this abstract class.
	 * 
	 * Gee Serializable clases requires to be initialized with required typed objects to contain 
	 * its collections and Serializable interface don't know required type. Then you must use this
	 * function to initialize any Serializable collection objects in order to serialize/deserialize
	 * all {@link GXml.Node} to given clases.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class SerializableContainer : GXml.SerializableObjectModel {
		public SerializableContainer ();
		/**
		 * Implementors must implement this function and initialize any Serializable container.
		 */
		public abstract void init_containers ();
	}
	/**
	 * Represent any real double value property to be added as a
	 * {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 * This object can be used when the property could be removed from
	 * serialization, specially if missing on XML have some
	 * missing and avoidable.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableDouble : GLib.Object, GXml.SerializableProperty {
		protected int _fraction;
		protected string _val;
		public SerializableDouble ();
		public string format (string f);
		public int get_fraction ();
		public double get_value ();
		public void set_fraction (int fraction);
		public void set_value (double val);
		public string to_string ();
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on Gee interfaces with dual key.
	 * 
	 * It implements {@link Serializable} and {@link SerializableCollection} interfaces, it is iterable as
	 * other Gee collections.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableDualKeyMap<P,S,V> : GLib.Object, Gee.Traversable<V>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		protected Gee.HashMultiMap<P,Gee.HashMap<S,V>> storage;
		public SerializableDualKeyMap ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public new V @get (P primary_key, S secondary_key);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public Gee.Collection<S> secondary_keys (P key);
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public new void @set (P primary_key, S secundary_key, V val);
		public virtual bool set_default_namespace (GXml.Node node);
		public Gee.Collection<V> values ();
		public Gee.Collection<V> values_for_key (P primary_key);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		public GLib.Type primary_key_type { get; }
		public Gee.Collection<P> primary_keys { owned get; }
		protected GLib.ParamSpec[] properties { get; set; }
		public GLib.Type secondary_key_type { get; }
		public int size { get; }
		public GLib.Type value_type { get; }
	}
	/**
	 * Represent any value as string but a list of enum values by default to select from.
	 * property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}.
	 *
	 * This class makes easy to create enumerations with its representation to string,
	 * but limited to the actual values of the enumeration, making it flexible for
	 * values not supported now but possible because some extensions. Can be added
	 * an extension element in the enumeration and return it when the supported values
	 * are not met with the string representation in the property.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableEnum : GLib.Object, GXml.SerializableProperty {
		protected GLib.Type _enumtype;
		protected string _val;
		public SerializableEnum ();
		public GLib.Type get_enum_type ();
		public void parse (string str) throws GLib.Error;
		public void parse_integer (int v) throws GLib.Error;
		public void set_enum_type (GLib.Type type);
		public int to_integer () throws GLib.Error;
		public string to_string ();
		public SerializableEnum.with_enum (GLib.Type type);
	}
	/**
	 * Represent any float property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 * This object can be used when the property could be removed from serialization, specially if missing
	 * on XML have some missing and avoidable.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableFloat : GXml.SerializableDouble {
		public SerializableFloat ();
		/**
		 * Parse the stored value, from the XML property, to a {@link int}. This parsing
		 * may is different from the actual stored string.
		 *
		 * The stored value, is parsed using to double value and then
		 * casted to an float before return, this make flexible on stored values
		 * in XML and parsed without errors, but they could defere from the value
		 * returned by this method.
		 */
		public new float get_value ();
		/**
		 * Given float number is parsed to string and then stored.
		 */
		public new void set_value (float val);
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on {@link Gee.HashMap}.
	 * 
	 * It uses a key and value store implementing {@link Gee.HashMap} interface.
	 * It implements {@link Serializable} and {@link SerializableCollection} interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableHashMap<K,V> : Gee.HashMap<K,V>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		public SerializableHashMap ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Represent any boolean property to be added as a {@link GXml.Attribute} to a {@link GXml.Element} 
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableInt : GXml.SerializableDouble {
		public SerializableInt ();
		/**
		 * Parse the stored value, from the XML property, to a {@link int}. This parsing
		 * may is different from the actual stored string.
		 *
		 * The stored value, is parsed as double value and then
		 * casted to an integer before return, this make flexible on stored values
		 * in XML and parsed without errors, but they could defere from the value
		 * returned by this method.
		 */
		public new int get_value ();
		/**
		 * Given integer is parsed to string and then stored.
		 */
		public new void set_value (int val);
	}
	/**
	 * Object Model is an {@link Serializable} implementation using {@link Element}
	 * to represent {@link GLib.Object} class objects.
	 * 
	 * This implementation consider each object as a XML node, represented in GXml 
	 * as a {@link GXml.Element} and its properties is represented by {@link GXml.Attribute}.
	 * Each property, if it is a {@link Serializable} object, is represented as child
	 * {@link Element}.
	 * 
	 * If a object's value property must be represented as a XML node content, 
	 * then it requires to override {@link Serializable.serialize_use_xml_node_value}
	 * and set value at {@link Serializable.serialized_xml_node_value}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class SerializableObjectModel : GLib.Object, GXml.Serializable {
		protected GXml.Node _node;
		public SerializableObjectModel ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public string default_node_name ();
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public abstract string to_string ();
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on {@link Gee.TreeMap}.
	 * 
	 * It uses a key and value store implementing {@link Gee.TreeMap} interface.
	 * It implements {@link Serializable} and {@link SerializableCollection} interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableTreeMap<K,V> : Gee.TreeMap<K,V>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		public SerializableTreeMap ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Represent any value as string but a list of options by default to select from.
	 * property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}.
	 *
	 * All values are stored in an array to get access to it by its position using
	 * {@link SerializableValueList.get_value_at}.
	 *
	 * Is recommended to initilize your list from a fixed array to avoid to have a list
	 * for each object in memory, do it by initialize the internal variable
	 * {@link GXml.SerializableValueList._vals}, at construct {} clause to point a fixed
	 * array of strings.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableValueList : GLib.Object, GXml.SerializableProperty {
		protected string[] _vals;
		protected Gee.ArrayList<string> extra;
		public SerializableValueList ();
		/**
		 * Add a list of string values to select from.
		 * 
		 * This values are added to the ones already defined at construct time.s
		 */
		public virtual void add_values (string[] vals);
		/**
		 * Get the string value at a given index. This operation does not change
		 * the actual value.
		 */
		public virtual string? get_value_at (int index);
		/**
		 * Return a {@link Gee.List} with all possible selection strings.
		 *
		 * If no values where defined at construction time and no values
		 * have been added, then this will return an empty list.
		 */
		public virtual Gee.List<string> get_values ();
		/**
		 * Get an array of string values in list.
		 *
		 * If no values were defined at construction time and
		 * no values were added this return null
		 */
		public virtual string[] get_values_array ();
		/**
		 * Checks if the actual value is in the values list.
		 */
		public virtual bool is_value ();
		/**
		 * Sets actual value to the one at a given position.
		 */
		public virtual void select_value_at (int index);
		public string to_string ();
	}
	/**
	 * Class implemeting {@link GXml.Attribute} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TAttribute : GXml.TNode, GXml.Attribute {
		protected Gee.ArrayList<GXml.Node> _namespaces;
		public TAttribute (GXml.Document d, string name, string value);
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.CDATA} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TCDATA : GXml.TNode, GXml.CDATA {
		public TCDATA (GXml.Document d, string text);
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Comment} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TComment : GXml.TNode, GXml.Comment {
		public TComment (GXml.Document doc, string text);
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Document} interface, not tied to libxml-2.0 library.
	 *
	 * This class use {@link Xml.TextWriter} to write down XML documents using
	 * its contained {@link GXml.Node} children or other XML structures.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TDocument : GXml.TNode, GXml.Document {
		/**
		 * Enum for {@link Xml.TextReader} flag on parsing.
		 */
		public enum ReadType {
			NEXT,
			CONTINUE,
			STOP
		}
		/**
		 * Delegate function to control parsing of XML documents. Return {@link ReadType.NEXT}
		 * to skip all children nodes of current {@link GXml.Node}; {@link ReadType.CONTINUE}
		 * continue parsing nodes or {@link ReadType.STOP} to stop reading.
		 *
		 * While you get the current {@link Xml.TextReader} used in parsing, you can control
		 * next action to take depending on current node.
		 */
		public delegate GXml.TDocument.ReadType ReadTypeFunc (GXml.Node node, Xml.TextReader tr);
		protected Gee.ArrayList<GXml.Node> _children;
		protected Gee.ArrayList<GXml.Node> _namespaces;
		public TDocument ();
		public TDocument.from_file (GLib.File file);
		public TDocument.from_file_with_readtype_func (GLib.File file, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_path (string path);
		public TDocument.from_path_with_readtype_func (string path, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_stream (GLib.InputStream stream);
		public TDocument.from_stream_with_readtype_func (GLib.InputStream stream, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_string (string str);
		public TDocument.from_string_with_readtype_func (string str, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_uri (string uri);
		public TDocument.from_uri_with_readtype_func (string uri, GXml.TDocument.ReadTypeFunc func);
		/**
		 * Read a {@link GXml.Document} from a {@link GLib.File}, parsing is controller
		 * using {@link ReadTypeFunc}, if null it parse all nodes.
		 */
		public static void read_doc (GXml.Document doc, GLib.File file, GXml.TDocument.ReadTypeFunc? rtfunc = null) throws GLib.Error;
		/**
		 * Reads document from {@link GLib.InputStream} objects.
		 */
		public static void read_doc_stream (GXml.Document doc, GLib.InputStream istream, GXml.TDocument.ReadTypeFunc? rtfunc = null) throws GLib.Error;
		/**
		 * Parse current node in {@link Xml.TextReader}.
		 *
		 * Returns: a {@link GXml.Node} respresenting current parsed one.
		 */
		public static GXml.TDocument.ReadType read_node (GXml.Node node, Xml.TextReader tr, GXml.TDocument.ReadTypeFunc? rntfunc = null) throws GLib.Error;
		[Version (deprecated = true, deprecated_since = "0.8.1", replacement = "save_as")]
		public bool save_to (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * {@inheritDoc}
		 *
		 * All namespaces are stored at {@link GXml.Node.namespaces} owned by
		 * this {@link GXml.TDocument}.
		 *
		 * First namespace at list, is considered default one for the document. If
		 * you haven't declared a namespace for this document or for its root element,
		 * and you define one for a child node, this one is added for the first time
		 * to document's namespaces, then this becomes the default namespace. To avoid
		 * this, you should set a namespace for documento or its root, then children.
		 *
		 * Default {@link GXml.Namespace} for a document is the first
		 */
		public override bool set_namespace (string uri, string? prefix);
		public static void start_node (GXml.Document doc, Xml.TextWriter tw, GXml.Node node, bool root, ref Gee.ArrayList<string> declared_ns) throws GLib.Error;
		public override string to_string ();
		public static bool tw_save_as (GXml.Document doc, GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public static void write_document (GXml.Document doc, Xml.TextWriter tw) throws GLib.Error;
		public override Gee.BidirList<GXml.Node> children_nodes { owned get; }
		public override GXml.Document document { get; }
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.Element} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TElement : GXml.TNode, GXml.Element {
		protected Gee.HashMap<string,GXml.Node> _attrs;
		protected GXml.TNode.TChildrenList _children;
		protected Gee.ArrayList<GXml.Node> _namespaces;
		public TElement (GXml.Document d, string name);
		public override Gee.Map<string,GXml.Node> attrs { owned get; }
		public override Gee.BidirList<GXml.Node> children_nodes { owned get; }
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Namespace}, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TNamespace : GXml.TNode, GXml.Namespace {
		public TNamespace (GXml.Document d, string uri, string? prefix);
	}
	/**
	 * Base node abstract class implemeting {@link GXml.Node} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class TNode : GLib.Object, GXml.Node {
		protected class TChildrenList : Gee.AbstractBidirList<GXml.Node> {
			public TChildrenList (GXml.Node e);
			public override bool add (GXml.Node item);
			public override Gee.BidirListIterator<GXml.Node> bidir_list_iterator ();
			public override void clear ();
			public override bool contains (GXml.Node item);
			public override new GXml.Node @get (int index);
			public override int index_of (GXml.Node item);
			public override void insert (int index, GXml.Node item);
			public override Gee.Iterator<GXml.Node> iterator ();
			public override Gee.ListIterator<GXml.Node> list_iterator ();
			public override bool remove (GXml.Node item);
			public override GXml.Node remove_at (int index);
			public override new void @set (int index, GXml.Node item);
			public override Gee.List<GXml.Node>? slice (int start, int stop);
			public override bool read_only { get; }
			public override int size { get; }
		}
		protected GXml.Document _doc;
		protected string _name;
		protected GXml.NodeType _node_type;
		protected GXml.Node _parent;
		protected string _value;
		public TNode ();
		public virtual bool set_namespace (string uri, string? prefix);
		public virtual void set_parent (GXml.Node node);
		public virtual string to_string ();
		public virtual Gee.Map<string,GXml.Node> attrs { owned get; }
		public virtual Gee.BidirList<GXml.Node> children_nodes { owned get; }
		public virtual GXml.Document document { get; }
		public virtual string name { owned get; }
		public virtual Gee.List<GXml.Namespace> namespaces { owned get; }
		public virtual GXml.Node parent { owned get; }
		public virtual GXml.NodeType type_node { get; }
		public virtual string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.ProcessingInstruction} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TProcessingInstruction : GXml.TNode, GXml.ProcessingInstruction {
		public TProcessingInstruction (GXml.Document doc, string target, string data);
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Text} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TText : GXml.TNode, GXml.Text {
		public TText (GXml.Document d, string text);
		public override string value { owned get; set; }
	}
	/**
	 * {@link Parser} implementation using libxml2 engine
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XParser : GLib.Object, GXml.Parser {
		public XParser (GXml.DomNode node);
		/**
		 * Read current node from a TextReader
		 */
		public bool read_current_node (GXml.DomNode node, bool read_current = false, bool read_property = false) throws GLib.Error;
	}
	/**
	 * Interface to handle XML tags properties.
	 *
	 * Its features relays on {@link GXml.Node} interface inplementation to access
	 * {@link GXml.Element} properties.
	 *
	 * Attribute's name could be get from {@link GXml.Node.name} property. Its value
	 * should be get from {@link GXml.Node.value} property.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Attribute : GLib.Object, GXml.Node {
		public abstract GXml.Namespace? @namespace { owned get; set; }
		public abstract string? prefix { owned get; }
	}
	/**
	 * CDATA sections in XML documents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface CDATA : GLib.Object, GXml.Node {
		/**
		 * This should be implemented by returning {@link GXml.Node.value}
		 */
		public abstract string str { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Character : GLib.Object, GXml.Node {
		public abstract string str { owned get; set; }
	}
	/**
	 * Representation of comments nodes in any {@link GXml.Node}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Comment : GLib.Object, GXml.Node {
		/**
		 * This should be implemented by returning {@link GXml.Node.value}
		 */
		public abstract string str { owned get; set; }
	}
	/**
	 * Interface to handle XML documents.
	 *
	 * Provides basic interfaces to read and create XML documents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Document : GLib.Object, GXml.Node {
		/**
		 * Creates a new {@link GXml.CDATA}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_cdata (string text);
		/**
		 * Creates a new {@link GXml.Comment}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_comment (string text);
		/**
		 * This method should create a new {@link GXml.Element}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}.
		 */
		public abstract GXml.Node create_element (string name) throws GLib.Error;
		/**
		 * Creates a new {@link GXml.ProcessingInstruction}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_pi (string target, string data);
		/**
		 * Creates a new {@link GXml.Text}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_text (string text);
		/**
		 * Creates a new {@link GXml.Document} using default implementation class.
		 *
		 * As an interface you can create your own implementation of it, but if 
		 * default one is required use this.
		 */
		public static GXml.Document new_default ();
		/**
		 * Creates a new {@link GXml.Document} from a {@link GLib.File} using default implementation class.
		 *
		 * As an interface you can create your own implementation of it, but if 
		 * default one is required use this.
		 */
		public static GXml.Document new_default_for_file (GLib.File f) throws GLib.Error;
		/**
		 * Creates a new {@link GXml.Document} from a file path using default implementation class.
		 *
		 * As an interface you can create your own implementation of it, but if 
		 * default one is required use this.
		 */
		public static GXml.Document new_default_for_path (string path) throws GLib.Error;
		/**
		 * Save this {@link GXml.Document} to {@link GXml.Document.file}
		 *
		 * If {@link GXml.Document.file} doesn't exists, it creates a new file to save to.
		 */
		public abstract bool save (GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Save this {@link GXml.Document} to given {@link GLib.File}
		 */
		public abstract bool save_as (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Controls if writting to a {@link GLib.File} creates a backup, by default
		 * is true;
		 */
		public abstract bool backup { get; set; }
		/**
		 * Stores a {@link GLib.File} to save/read XML documents to/from.
		 */
		public abstract GLib.File file { get; set; }
		/**
		 * Controls if writting this documents should use indent.
		 */
		public abstract bool indent { get; set; }
		/**
		 * Controls if writting this documentsshould use namespaces
		 * declaration at root {@link GXml.Element}.
		 *
		 * This removes full declaration at childs nodes, because they
		 * are just prefixed if a prefix was defined for namespace apply.
		 */
		public abstract bool ns_top { get; set; }
		/**
		 * Controls if writting this document should use default namespace's prefix
		 * to prefix root's childs {@link GXml.Element}.
		 *
		 * This removes prefix on childs using default namespace. Default namespace
		 * is the first one found in {@link GXml.Node.namespaces} for this document.
		 */
		public abstract bool prefix_default_ns { get; set; }
		/**
		 * XML document root node as a {@link GXml.Element}.
		 */
		public abstract GXml.Node root { owned get; }
	}
	/**
	 * Interface to represent Document type definitions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DocumentType : GLib.Object, GXml.Node {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomAttr : GLib.Object {
		public abstract string local_name { owned get; }
		public abstract string name { owned get; }
		public abstract string? namespace_uri { owned get; }
		public abstract string? prefix { owned get; }
		public virtual bool specified { get; }
		public abstract string value { owned get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomCharacterData : GLib.Object, GXml.DomNode, GXml.DomNonDocumentTypeChildNode, GXml.DomChildNode {
		public virtual void append_data (string data);
		public virtual void delete_data (int offset, int count) throws GLib.Error;
		public virtual void insert_data (int offset, string data) throws GLib.Error;
		public virtual new void replace_data (int offset, int count, string data) throws GLib.Error;
		public virtual string substring_data (int offset, int count) throws GLib.Error;
		/**
		 * Null is an empty string.
		 */
		public abstract string data { owned get; set; }
		public virtual int length { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomChildNode : GLib.Object {
		public abstract void remove ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomComment : GXml.DomCharacterData {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomCustomEvent : GLib.Object, GXml.DomEvent {
		public abstract void init_custom_event (string type, bool bubbles, bool cancelable, GLib.Value? detail);
		public abstract GLib.Value? detail { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomDocument : GLib.Object, GXml.DomNode, GXml.DomParentNode, GXml.DomNonElementParentNode {
		public abstract GXml.DomNode adopt_node (GXml.DomNode node) throws GLib.Error;
		public abstract GXml.DomComment create_comment (string data) throws GLib.Error;
		public abstract GXml.DomDocumentFragment create_document_fragment ();
		public abstract GXml.DomElement create_element (string local_name) throws GLib.Error;
		public abstract GXml.DomElement create_element_ns (string? @namespace, string qualified_name) throws GLib.Error;
		/**
		 * No implemented jet. This can lead to API changes in future versions.
		 */
		public abstract GXml.DomEvent create_event (string @interface) throws GLib.Error;
		/**
		 * No implemented jet. This can lead to API changes in future versions.
		 */
		public abstract GXml.DomNodeIterator create_node_iterator (GXml.DomNode root, int whatToShow = (int) 0xFFFFFFFF, GXml.DomNodeFilter? filter = null);
		public abstract GXml.DomProcessingInstruction create_processing_instruction (string target, string data) throws GLib.Error;
		/**
		 * No implemented jet. This can lead to API changes in future versions.
		 */
		public abstract GXml.DomRange create_range ();
		public abstract GXml.DomText create_text_node (string data) throws GLib.Error;
		/**
		 * No implemented jet. This can lead to API changes in future versions.
		 */
		public abstract GXml.DomTreeWalker create_tree_walker (GXml.DomNode root, int what_to_show = (int) 0xFFFFFFFF, GXml.DomNodeFilter? filter = null);
		public abstract GXml.DomHTMLCollection get_elements_by_class_name (string classNames);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name (string local_name);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name_ns (string? @namespace, string local_name);
		public abstract GXml.DomNode import_node (GXml.DomNode node, bool deep = false) throws GLib.Error;
		public abstract string character_set { get; }
		public abstract string compat_mode { get; }
		public abstract string content_type { get; }
		public abstract GXml.DomDocumentType? doctype { owned get; }
		public abstract GXml.DomElement? document_element { owned get; }
		public abstract string document_uri { get; }
		public abstract GXml.DomImplementation implementation { get; }
		public abstract string origin { get; }
		public abstract string url { get; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomDocumentFragment : GLib.Object, GXml.DomNode, GXml.DomParentNode, GXml.DomNonElementParentNode {
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomDocumentType : GLib.Object, GXml.DomNode, GXml.DomChildNode {
		public abstract string name { get; }
		public abstract string public_id { get; }
		public abstract string system_id { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomElement : GLib.Object, GXml.DomNode, GXml.DomChildNode, GXml.DomNonDocumentTypeChildNode, GXml.DomParentNode {
		public abstract string? get_attribute (string name);
		public abstract string? get_attribute_ns (string? @namespace, string local_name);
		public abstract GXml.DomHTMLCollection get_elements_by_class_name (string class_names);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name (string local_name);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name_ns (string? @namespace, string local_name);
		public abstract bool has_attribute (string name);
		public abstract bool has_attribute_ns (string? @namespace, string local_name);
		public abstract void remove_attribute (string name);
		public abstract void remove_attribute_ns (string? @namespace, string local_name);
		public abstract void set_attribute (string name, string value) throws GLib.Error;
		public abstract void set_attribute_ns (string? @namespace, string name, string value) throws GLib.Error;
		public abstract GXml.DomNamedNodeMap attributes { owned get; }
		public abstract GXml.DomTokenList class_list { owned get; }
		public abstract string? class_name { owned get; set; }
		public abstract string? id { owned get; set; }
		public abstract string local_name { owned get; }
		/**
		 * Returns default namespace's uri defined in node or first found.
		 */
		public abstract string? namespace_uri { owned get; }
		/**
		 * Returns default namespace's prefix defined in node or first found.
		 */
		public abstract string? prefix { owned get; }
		public abstract string tag_name { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomEvent : GLib.Object {
		[Flags]
		public enum Flags {
			STOP_PROPAGATION_FLAG,
			STOP_IMMEDIATE_PROPAGATION_FLAG,
			CANCELED_FLAG,
			INITIALIZED_FLAG,
			DISPATCH_FLAG
		}
		public enum Phase {
			NONE,
			CAPTURING_PHASE,
			AT_TARGET,
			BUBBLING_PHASE
		}
		public abstract void init_event (string type, bool bubbles, bool cancelable);
		public abstract void prevent_default ();
		public abstract void stop_immediate_propagation ();
		public abstract void stop_propagation ();
		public abstract bool bubbles { get; }
		public abstract bool cancelable { get; }
		public abstract GXml.DomEventTarget? current_target { get; }
		public abstract bool default_prevented { get; }
		public abstract string etype { get; }
		public abstract GXml.DomEvent.Phase event_phase { get; }
		public abstract GXml.DomEventTarget? event_target { get; }
		public abstract bool is_trusted { get; }
		public abstract GXml.DomTimeStamp time_stamp { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomEventListener : GLib.Object {
		public abstract void handle_event (GXml.DomEvent event);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomEventTarget : GLib.Object {
		public abstract void add_event_listener (string type, GXml.DomEventListener? callback, bool capture = false);
		public abstract bool dispatch_event (GXml.DomEvent event) throws GLib.Error;
		public abstract void remove_event_listener (string type, GXml.DomEventListener? callback, bool capture = false);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomHTMLCollection : GLib.Object, Gee.BidirList<GXml.DomElement> {
		public abstract new GXml.DomElement? get_element (int index);
		public virtual GXml.DomElement? item (int index);
		public virtual GXml.DomElement? named_item (string name);
		public virtual new GXml.DomElement[] to_array ();
		public virtual int length { get; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomImplementation : GLib.Object {
		public abstract GXml.DomXMLDocument create_document (string? nspace, string? qualified_name, GXml.DomDocumentType? doctype = null) throws GLib.Error;
		public abstract GXml.DomDocumentType create_document_type (string qualified_name, string public_id, string system_id) throws GLib.Error;
		public abstract GXml.Document create_html_document (string title);
		public virtual bool has_feature ();
	}
	/**
	 * Implementators should use constructor with one argument {@link GXml.DomMutationCallback}
	 * to use internally.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomMutationObserver : GLib.Object {
		public abstract void disconnect ();
		public abstract void observe (GXml.Node target, GXml.DomMutationObserverInit options);
		public abstract Gee.List<GXml.DomMutationRecord> take_records ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomMutationRecord : GLib.Object {
		public abstract GXml.DomNodeList added_nodes { get; set; }
		public abstract string? attribute_name { get; }
		public abstract string? attribute_namespace { get; }
		public abstract string mtype { get; }
		public abstract GXml.DomNode? next_sibling { get; }
		public abstract string? old_value { get; }
		public abstract GXml.DomNode? previous_sibling { get; }
		public abstract GXml.DomNodeList removed_nodes { get; set; }
		public abstract GXml.DomNode target { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNamedNodeMap : GLib.Object, Gee.Map<string,GXml.DomNode> {
		public abstract GXml.DomNode? get_named_item (string name);
		public abstract GXml.DomNode? get_named_item_ns (string namespace_uri, string local_name) throws GLib.Error;
		public abstract GXml.DomNode? item (int index);
		public abstract GXml.DomNode? remove_named_item (string name) throws GLib.Error;
		public abstract GXml.DomNode? remove_named_item_ns (string namespace_uri, string localName) throws GLib.Error;
		public abstract GXml.DomNode? set_named_item (GXml.DomNode node) throws GLib.Error;
		public abstract GXml.DomNode? set_named_item_ns (GXml.DomNode node) throws GLib.Error;
		public abstract int length { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNode : GLib.Object, GXml.DomEventTarget {
		[Flags]
		public enum DocumentPosition {
			NONE,
			DISCONNECTED,
			PRECEDING,
			FOLLOWING,
			CONTAINS,
			CONTAINED_BY,
			IMPLEMENTATION_SPECIFIC
		}
		public enum NodeType {
			INVALID,
			ELEMENT_NODE,
			ATTRIBUTE_NODE,
			TEXT_NODE,
			CDATA_SECTION_NODE,
			ENTITY_REFERENCE_NODE,
			ENTITY_NODE,
			PROCESSING_INSTRUCTION_NODE,
			COMMENT_NODE,
			DOCUMENT_NODE,
			DOCUMENT_TYPE_NODE,
			DOCUMENT_FRAGMENT_NODE,
			NOTATION_NODE
		}
		public abstract GXml.DomNode append_child (GXml.DomNode node) throws GLib.Error;
		public virtual GXml.DomNode clone_node (bool deep = false);
		public abstract GXml.DomNode.DocumentPosition compare_document_position (GXml.DomNode other);
		public abstract bool contains (GXml.DomNode? other);
		/**
		 * Copy a {@link GXml.DomNode} relaying on {@link GXml.DomDocument} to other {@link GXml.DomNode}.
		 *
		 * {@link node} could belongs from different {@link GXml.DomDocument}, while source is a node
		 * belonging to given document.
		 *
		 * Only {@link GXml.DomElement} objects are supported. For attributes, use
		 * {@link GXml.DomElement.set_attr} method, passing source's name and value as arguments.
		 *
		 * @param doc a {@link GXml.DomDocument} owning destiny node
		 * @param node a {@link GXml.DomElement} to copy nodes to
		 * @param source a {@link GXml.DomElement} to copy nodes from, it could be holded by different {@link GXml.DomDocument}
		 */
		public static bool copy (GXml.DomDocument doc, GXml.DomNode node, GXml.DomNode source, bool deep);
		public abstract bool has_child_nodes ();
		public abstract GXml.DomNode insert_before (GXml.DomNode node, GXml.DomNode? child) throws GLib.Error;
		public abstract bool is_default_namespace (string? nspace);
		public abstract bool is_equal_node (GXml.DomNode? node);
		public abstract string? lookup_namespace_uri (string? prefix);
		public abstract string? lookup_prefix (string? nspace);
		public abstract void normalize ();
		public abstract GXml.DomNode remove_child (GXml.DomNode child) throws GLib.Error;
		public abstract GXml.DomNode replace_child (GXml.DomNode node, GXml.DomNode child) throws GLib.Error;
		public abstract string? base_uri { get; }
		public abstract GXml.DomNodeList child_nodes { owned get; }
		public abstract GXml.DomNode? first_child { owned get; }
		public abstract GXml.DomNode? last_child { owned get; }
		public abstract GXml.DomNode? next_sibling { owned get; }
		public abstract string node_name { owned get; }
		public abstract GXml.DomNode.NodeType node_type { get; }
		public abstract string? node_value { owned get; set; }
		public abstract GXml.DomDocument? owner_document { get; set construct; }
		public abstract GXml.DomElement? parent_element { owned get; }
		public abstract GXml.DomNode? parent_node { owned get; }
		public abstract GXml.DomNode? previous_sibling { owned get; }
		public abstract string? text_content { owned get; set; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNodeIterator {
		public abstract void detach ();
		public abstract GXml.DomNode? next_node ();
		public abstract GXml.DomNode? previous_node ();
		public abstract GXml.DomNodeFilter? filter { get; }
		public abstract bool pointer_before_reference_node { get; }
		public abstract GXml.DomNode reference_node { get; }
		public abstract GXml.DomNode root { get; }
		public abstract int what_to_show { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNodeList : GLib.Object, Gee.BidirList<GXml.DomNode> {
		public abstract GXml.DomNode? item (int index);
		public abstract int length { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNonDocumentTypeChildNode : GLib.Object {
		public abstract GXml.DomElement? next_element_sibling { get; }
		public abstract GXml.DomElement? previous_element_sibling { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNonElementParentNode : GLib.Object {
		public abstract GXml.DomElement? get_element_by_id (string element_id) throws GLib.Error;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomParentNode : GLib.Object {
		/**
		 * Search all child {@link GXml.Element} with a given property's name and with
		 * value contained in text.
		 */
		public virtual GXml.DomElementList get_elements_by_property_value (string property, string value);
		public abstract GXml.DomElement? query_selector (string selectors) throws GLib.Error;
		public abstract GXml.DomNodeList query_selector_all (string selectors) throws GLib.Error;
		public abstract int child_element_count { get; }
		public abstract GXml.DomHTMLCollection children { owned get; }
		public abstract GXml.DomElement? first_element_child { owned get; }
		public abstract GXml.DomElement? last_element_child { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomProcessingInstruction : GXml.DomCharacterData {
		public abstract string target { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomRange : GLib.Object {
		public enum BoundaryPoints {
			START_TO_START,
			START_TO_END,
			END_TO_END,
			END_TO_START
		}
		public abstract GXml.DomDocumentFragment? clone_contents () throws GLib.Error;
		public abstract GXml.DomRange clone_range ();
		public abstract void collapse (bool to_start = false) throws GLib.Error;
		public abstract int compare_boundary_points (GXml.DomRange.BoundaryPoints how, GXml.DomRange sourceRange) throws GLib.Error;
		public abstract short compare_point (GXml.DomNode node, int offset);
		public abstract void delete_contents () throws GLib.Error;
		public abstract void detach ();
		public abstract GXml.DomDocumentFragment? extract_contents () throws GLib.Error;
		public abstract void insert_node (GXml.DomNode node);
		public abstract bool intersects_node (GXml.DomNode node);
		public abstract bool is_point_in_range (GXml.DomNode node, int offset);
		public abstract void select_node (GXml.DomNode node) throws GLib.Error;
		public abstract void select_node_contents (GXml.DomNode node) throws GLib.Error;
		public abstract void set_end (GXml.DomNode node, int offset) throws GLib.Error;
		public abstract void set_end_after (GXml.DomNode node) throws GLib.Error;
		public abstract void set_end_before (GXml.DomNode node) throws GLib.Error;
		public abstract void set_start (GXml.DomNode node, int offset) throws GLib.Error;
		public abstract void set_start_after (GXml.DomNode node) throws GLib.Error;
		public abstract void set_start_before (GXml.DomNode node) throws GLib.Error;
		public abstract void surround_contents (GXml.DomNode newParent);
		public abstract string to_string ();
		public abstract bool collapsed { get; }
		public abstract GXml.DomNode common_ancestor_container { get; }
		public abstract GXml.DomNode end_container { get; }
		public abstract int end_offset { get; }
		public abstract GXml.DomNode start_container { get; }
		public abstract int start_offset { get; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomSettableTokenList : GXml.DomTokenList {
		public abstract string value { owned get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomText : GXml.DomCharacterData {
		public virtual GXml.DomText split_text (int offset) throws GLib.Error;
		public virtual string whole_text { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomTokenList : GLib.Object, Gee.BidirList<string> {
		public abstract void add (string[] tokens) throws GLib.Error;
		public abstract bool contains (string token) throws GLib.Error;
		public abstract string? item (int index);
		public abstract void remove (string[] tokens);
		public abstract string to_string ();
		/**
		 * If @auto is true, adds @param token if not present and removing if it is, @force value
		 * is taken in account. If @param auto is false, then @force is considered; if true adds
		 * @param token, if false removes it.
		 */
		public abstract bool toggle (string token, bool force = false, bool auto = true) throws GLib.Error;
		public abstract int length { get; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomTreeWalker : GLib.Object {
		public abstract GXml.DomNode? firstChild ();
		public abstract GXml.DomNode? lastChild ();
		public abstract GXml.DomNode? nextNode ();
		public abstract GXml.DomNode? nextSibling ();
		public abstract GXml.DomNode? parentNode ();
		public abstract GXml.DomNode? previousNode ();
		public abstract GXml.DomNode? previousSibling ();
		public abstract GXml.DomNode current_node { get; }
		public abstract GXml.DomNodeFilter? filter { get; }
		public abstract GXml.DomNode root { get; }
		public abstract int what_to_show { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomXMLDocument : GLib.Object, GXml.DomDocument {
	}
	/**
	 * Interface to access XML document's tags, properties and content.
	 *
	 * Provides methods to create new XML tags properties and its values, and 
	 * access to tag's contents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Element : GLib.Object, GXml.Node {
		/**
		 * Search for a {@link GXml.Attribute} with given name.
		 *
		 * All attributes could be get using {@link GXml.Node.attrs} property.
		 */
		public abstract GXml.Node? get_attr (string name);
		/**
		 * Search for a {@link GXml.Attribute} with a given name and namespace uri.
		 *
		 * To get a attibute from {@link GXml.Node.attrs} with a given namespace
		 * prefix, use "prefix:name".
		 */
		public abstract GXml.Node? get_ns_attr (string name, string uri);
		/**
		 * This merges all adjacent {@link GXml.Text} nodes that are
		 * descendants of this {@link GXml.Element}.
		 */
		public abstract void normalize ();
		/**
		 * Search for a {@link GXml.Attribute} with given name and removes it.
		 */
		public abstract void remove_attr (string name);
		/**
		 * Search for a {@link GXml.Attribute} with given name and namespace and removes it.
		 */
		public abstract void remove_ns_attr (string name, string uri);
		/**
		 * Add a new {@link GXml.Attribute} to this {@link GXml.Element}.
		 *
		 * You should provide a name and a value.
		 */
		public abstract void set_attr (string name, string value);
		/**
		 * Set an {@link GXml.Attribute} with a given name, value and namespace.
		 */
		public abstract void set_ns_attr (string ns, string name, string value);
		/**
		 * This should be just a different name for {@link GXml.Node.value}.
		 */
		public abstract string content { owned get; set; }
		/**
		 * This should be just a different name for {@link GXml.Node.name}.
		 */
		public abstract string tag_name { owned get; }
	}
	/**
	 * An interface to keep references to {@link DomElement} in a {@link element}
	 * child nodes. Only {@link GomObject} are supported. It can be filled out
	 * using {@link update}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface GomCollection : GLib.Object {
		/**
		 * Adds a {@link DomElement} node to this collection. Depending on type of
		 * collection, this method will take information from node to initialize
		 * how to find it.
		 */
		public abstract void append (GXml.DomElement node) throws GLib.Error;
		/**
		 * Gets a child {@link DomElement} of {@link element} referenced in
		 * {@link nodes_index}.
		 */
		public virtual GXml.DomElement? get_item (int index) throws GLib.Error;
		/**
		 * Search and add references to all {@link GomObject} nodes as child of
		 * {@link element} with same, case insensitive, name of {@link element_name}
		 */
		public abstract void search () throws GLib.Error;
		/**
		 * A {@link DomElement} with all child elements in collection. Only
		 * {@link GomElement} objects are supported.
		 */
		public abstract GXml.DomElement element { get; set construct; }
		/**
		 * Local name of {@link DomElement} objects of {@link element}, which could be
		 * contained in this collection.
		 *
		 * Used when reading to add elements to collection.
		 */
		public abstract string items_name { get; }
		/**
		 * A {@link Type} of {@link DomElement} child objects of {@link element},
		 * which could be contained in this collection.
		 *
		 * Type should be an {@link GomObject}.
		 */
		public abstract GLib.Type items_type { get; set construct; }
		/**
		 * Number of items referenced in {@link nodes_index}
		 */
		public virtual int length { get; }
		/**
		 * A list of child {@link DomElement} objects of {@link element}
		 */
		public abstract GLib.Queue<int> nodes_index { get; }
	}
	/**
	 * A GXml Object Model (GOM) represents a {@link DomElement}. It has attributes
	 * and children. All object's properties are handled as attributes if they are
	 * basic types like integers, strings, enums and others; {@link SerializableProperty}
	 * objects are handled as attributes too. If object's attribute is a {@link GLib.Object}
	 * it is handled as node's child, but only if it is a {@link GomElement} object,
	 * other wise it is ignored when this object is used as {@link DomNode} in XML
	 * documents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface GomObject : GLib.Object, GXml.DomNode, GXml.DomElement {
		/**
		 * Returns property's name based on given nick. This function is
		 * case insensitive.
		 */
		public virtual string? find_property_name (string nick);
		/**
		 * Search for properties in objects, it should be
		 * an {@link GLib.Object}'s property. If found a
		 * property with given name its value is returned
		 * as string representation.
		 *
		 * If property is a {@link SerializableProperty}
		 * returned value is a string representation according
		 * with object implementation.
		 *
		 * If given property name is not found, then {@link DomElement.get_attribute}
		 * is called.
		 *
		 * By default all {@link GLib.Object} are children of
		 * this object, see {@link get_child}
		 */
		public virtual string? get_attribute (string name);
		/**
		 * Search a {@link GLib.Object} property with given name
		 * and returns it, if it is a {@link DomElement}. If not found,
		 * {@link DomNode.get_elements_by_tag_name} is called, returning
		 * first node found. Tag name to use, is the given name parameter.
		 *
		 * @param name a name of this object's property of type {@link DomElement} or
		 * first {@link DomNode} with that name in child nodes.
		 *
		 */
		public virtual GXml.DomElement? get_child (string name);
		/**
		 * Returns a list with all object's {@link GomProperty} property names.
		 */
		public virtual GLib.List<GLib.ParamSpec> get_object_properties_list ();
		/**
		 * Returns a list with all properties nick with "::" prefix. Nick name,
		 * without "::" will be used on serialization to an attribute's name.
		 */
		public virtual GLib.List<string> get_properties_list ();
		/**
		 * Returns a list of names for all {@link DomElement}
		 * present as object's properties.
		 */
		public virtual GLib.List<GLib.ParamSpec> get_property_element_list ();
		/**
		 * Search for a property and set it to null if possible, if value can't
		 * be removed, returns without change.
		 */
		public virtual bool remove_attribute (string name);
		/**
		 * Search for a {@link GLib.Object} property with
		 * given name, if found, given string representation
		 * is used as value to property, using any required
		 * transformation from string.
		 *
		 * By default all {@link GLib.Object} are children of
		 * this object, see {@link set_child}
		 */
		public virtual bool set_attribute (string name, string val);
		/**
		 * Controls if property name to be used when serialize to XML node
		 * attribute use property's nick name as declared in {@link GLib.ParamSpec}
		 */
		public virtual bool use_nick_name ();
	}
	/**
	 * An interface for {@link GomObject}'s properties translated to
	 * {@link DomElement} attributes.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface GomProperty : GLib.Object {
		/**
		 * Attribute's name in the parent {@link DomElement}.
		 */
		public abstract string attribute_name { get; set construct; }
		/**
		 * Attribute's value in the parent {@link DomElement}.
		 */
		public abstract string value { owned get; set; }
	}
	/**
	 * Interface to handle XML Namespaces.
	 *
	 * Basic information for a XML document's namespaces and applied to a given
	 * {@link GXml.Node}.
	 *
	 * Namespace management is a matter of this or other libraries, implementing
	 * this interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Namespace : GLib.Object {
		/**
		 * Read-only property to get namespace's prefix.
		 *
		 * Prefix should be added to {@link GXml.Element} or {@link GXml.Attribute}
		 * name in order to apply a given namespace, unless it is the default.
		 */
		public abstract string prefix { owned get; }
		/**
		 * Read-only property to get namespace's URI.
		 */
		public abstract string uri { owned get; }
	}
	/**
	 * Base interface providing basic functionalities to all GXml interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Node : GLib.Object {
		/**
		 * Copy a {@link GXml.Node} relaying on {@link GXml.Document} to other {@link GXml.Node}.
		 *
		 * {@link node} could belongs from different {@link GXml.Document}, while source is a node
		 * belonging to given document.
		 *
		 * Only {@link GXml.Element} objects are supported. For attributes, use
		 * {@link GXml.Element.set_attr} method, passing source's name and value as arguments.
		 *
		 * @param doc a {@link GXml.Document} owning destiny node
		 * @param node a {@link GXml.Element} to copy nodes to
		 * @param source a {@link GXml.Element} to copy nodes from, it could be holded by different {@link GXml.Document}
		 */
		public static bool copy (GXml.Document doc, GXml.Node node, GXml.Node source, bool deep);
		/**
		 * Get first child with given name, or null. 
		 */
		public virtual new GXml.Node? @get (string key);
		/**
		 * Search all child {@link GXml.Element} with a given name.
		 */
		public virtual GXml.ElementList get_elements_by_name (string name);
		/**
		 * Search all child {@link GXml.Element} with a given name and namespace URI.
		 */
		public virtual GXml.ElementList get_elements_by_name_ns (string name, string? ns);
		/**
		 * Search all child {@link GXml.Element} with a given property's name and with
		 * value contained in text.
		 */
		public virtual GXml.ElementList get_elements_by_property_value (string property, string value);
		/**
		 * Node's defaults namespace's prefix.
		 *
		 * This allways returns first {@link GXml.Namespace}'s prefix in {@link GXml.Node}'s
		 * namespaces collection.
		 */
		public virtual string ns_prefix ();
		/**
		 * Node's defaults namespace's URI.
		 *
		 * This allways returns first {@link GXml.Namespace}'s URI in {@link GXml.Node}'s
		 * namespaces collection.
		 */
		public virtual string ns_uri ();
		/**
		 * Set a namespace to this node.
		 *
		 * Search for existing document's namespaces and applies it if found or creates
		 * a new one, appending to document's namespaces collection.
		 */
		public abstract bool set_namespace (string uri, string? prefix);
		/**
		 * Node's string representation.
		 */
		public abstract string to_string ();
		/**
		 * Attributes in this {@link GXml.Node}.
		 */
		public abstract Gee.Map<string,GXml.Node> attrs { owned get; }
		/**
		 * Collection of {@link GXml.Node} as children.
		 *
		 * Depends on {@link GXml.Node} type, this children could be different, like,
		 * elements, element's contents or properties.
		 */
		public abstract Gee.BidirList<GXml.Node> children_nodes { owned get; }
		/**
		 * Node's XML document holding this node.
		 */
		public abstract GXml.Document document { get; }
		/**
		 * Node's name. The meaning differs, depending on node's type.
		 */
		public abstract string name { owned get; }
		/**
		 * Collection of Namespaces applied to this {@link GXml.Node}.
		 */
		public abstract Gee.List<GXml.Namespace> namespaces { owned get; }
		/**
		 * Node's XML document holding this node.
		 */
		public abstract GXml.Node parent { owned get; }
		/**
		 * Node's type as a enumeration.
		 */
		public abstract GXml.NodeType type_node { get; }
		/**
		 * Node's value. The meaning differs, depending on node's type.
		 */
		public abstract string value { owned get; set; }
	}
	/**
	 * Interface to handle notation elements
	 *
	 * Used in defining {@link GXml.DocumentType}s to declare the format of
	 * {@link GXml.Entity} and {@link GXml.ProcessingInstruction}s.
	 *
	 * Used collectively in defining DocumentTypes. A Notation can
	 * declare the format of unparsed entities or
	 * ProcessingInstruction targets.
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-5431D1B9]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Notation : GLib.Object, GXml.Node {
		public abstract string? external_id { get; }
		public abstract string? public_id { get; }
	}
	/**
	 * XML parser engine for {@link DomDocument} implementations.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Parser : GLib.Object {
		/**
		 * Writes a {@link GXml.DomDocument} to a {@link GLib.OutputStream}
		 */
		public virtual void read_file (GLib.File file, GLib.Cancellable? cancellable) throws GLib.Error;
		/**
		 * Read a {@link GXml.DomDocument} from a {@link GLib.InputStream}
		 */
		public abstract void read_stream (GLib.InputStream stream, GLib.Cancellable? cancellable) throws GLib.Error;
		/**
		 * Read a {@link GXml.DomDocument} from a {@link GLib.File}
		 */
		public abstract void read_string (string str, GLib.Cancellable? cancellable) throws GLib.Error;
		/**
		 * Writes a {@link GXml.DomDocument} to a {@link GLib.File}
		 */
		public virtual void write_file (GLib.File file, GLib.Cancellable? cancellable) throws GLib.Error;
		/**
		 * Writes a {@link GXml.DomDocument} to a {@link GLib.OutputStream}
		 */
		public abstract void write_stream (GLib.OutputStream stream, GLib.Cancellable? cancellable) throws GLib.Error;
		/**
		 * Writes a {@link GXml.DomDocument} to a string
		 */
		public abstract string write_string () throws GLib.Error;
		/**
		 * Controls if, when writing to a file, a backup should
		 * be created.
		 */
		public abstract bool backup { get; set; }
		/**
		 * Controls if, when writing, identation should be used.
		 */
		public abstract bool indent { get; set; }
		/**
		 * A {@link GXml.DomDocument} to read to or write from
		 */
		public abstract GXml.DomNode node { get; }
	}
	/**
	 * Interface for XML Processing Instruction sections.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface ProcessingInstruction : GLib.Object, GXml.Node {
		/**
		 * The data used by the target, like {{{href="style.xsl" type="text/xml"}}}
		 */
		public abstract string data { owned get; set; }
		/**
		 * The target for the processing instruction, like "xml-stylesheet".
		 */
		public abstract string target { owned get; }
	}
	/**
	 * Serialization framework. Base interface.
	 *
	 * Implementors of this interface, could define or override the way you want to 
	 * represent your class in a XML file.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Serializable : GLib.Object {
		/**
		 * Default implementation for {@link Serializable.find_property_spec}
		 *
		 */
		public virtual GLib.ParamSpec? default_find_property_spec (string property_name);
		/**
		 * Default implementation for {@link Serializable.list_serializable_properties}
		 *
		 */
		public virtual GLib.ParamSpec[] default_list_serializable_properties ();
		/**
		 * Deserialize this object.
		 *
		 * @param node {@link GXml.Node} used to deserialize from.
		 */
		public abstract bool deserialize (GXml.Node node) throws GLib.Error;
		/**
		 * Handles deserializing individual properties.
		 *
		 * Interface method to handle deserialization of an
		 * individual property.  The implementing class
		 * receives a description of the property and the
		 * {@link GXml.Node} that contains the content.  The
		 * implementing {@link GXml.Serializable} object can extract
		 * the data from the {@link GXml.Node} and store it in its
		 * property itself. Note that the {@link GXml.Node} may be
		 * as simple as a {@link GXml.Text} that stores the data as a
		 * string.
		 *
		 * Implementors:
		 * Use Serializable.get_property_value in order to allow derived classes to
		 * override the properties to serialize.
		 *
		 * @param property_node the {@link GXml.Node} encapsulating data to deserialize
		 * @return `true` if the property was handled, `false` if {@link GXml.Serialization} should handle it.
		 */
		public abstract bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		/**
		 * Handles finding the {@link GLib.ParamSpec} for a given property.
		 *
		 * {@link GXml.Serialization} uses {@link GLib.ObjectClass.find_property}
		 * (as well as {@link GLib.ObjectClass.list_properties},
		 * {@link GLib.Object.get_property}, and
		 * {@link GLib.Object.set_property}) to manage serialization
		 * of properties.  {@link GXml.Serializable} gives the
		 * implementing class an opportunity to override
		 * {@link GLib.ObjectClass.find_property} to control
		 * what properties exist for {@link GXml.Serialization}'s
		 * purposes.
		 *
		 * For instance, if an object has private data fields
		 * that are not installed public properties, but that
		 * should be serialized, {@link GLib.ObjectClass.find_property} can be defined
		 * to return a {@link GLib.ParamSpec} for non-installed
		 * properties.  Other {@link GXml.Serializable} functions
		 * should be consistent with it.
		 *
		 * An implementing class might wish to maintain such
		 * {@link GLib.ParamSpec} s separately, rather than creating new
		 * ones for each call.
		 *
		 * @param property_name the name of a property to obtain a {@link GLib.ParamSpec} for
		 * @return a {@link GLib.ParamSpec} describing the named property
		 */
		public abstract GLib.ParamSpec? find_property_spec (string property_name);
		/**
		 * Return false if you want to ignore unknown properties and {@link GXml.Node}'s
		 * not in your class definition.
		 *
		 * Take care, disabling this feature you can lost data on serialization, because any unknown
		 * property or element will be discarted.
		 */
		public abstract bool get_enable_unknown_serializable_property ();
		/**
		 * Transforms a {@link GLib.Value} to its string representation.
		 *
		 * By default use {@link GLib.Value} standard transformations.
		 *
		 */
		public static string gvalue_to_string (GLib.Value val) throws GXml.SerializableError;
		/**
		 * List the known properties for an object's class
		 *
		 * Class {@link GXml.Serialization} uses
		 * {@link GLib.ObjectClass.list_properties} (as well as
		 * {@link GLib.ObjectClass.find_property},
		 * {@link GLib.Object.get_property}, and {@link GLib.Object.set_property})
		 * to manage serialization of an object's properties.
		 * {@link GXml.Serializable} gives an implementing class an
		 * opportunity to override
		 * {@link GLib.ObjectClass.list_properties} to control which
		 * properties exist for {@link GXml.Serialization}'s purposes.
		 *
		 * For instance, if an object has private data fields
		 * that are not installed public properties, but that
		 * should be serialized, list_properties can be
		 * defined to return a list of {@link GLib.ParamSpec} s covering
		 * all the "properties" to serialize.  Other
		 * {@link GXml.Serializable} functions should be consistent
		 * with it.
		 *
		 * An implementing class might wish to maintain such
		 * {@link GLib.ParamSpec} s separately, rather than creating new
		 * ones for each call.
		 *
		 * @return an array of {@link GLib.ParamSpec} of "properties" for the object.
		 */
		public abstract GLib.ParamSpec[] list_serializable_properties ();
		/**
		 * Defines the way to set Node name.
		 */
		public abstract string node_name ();
		/**
		 * Defines the way to set Node's property name, by using
		 * it's nick instead of default name.
		 *
		 * When serialize a class property, by default it uses its name given  on class
		 * declaration, but is less common to see XML node properties with names like
		 * "your_property", but more common is to use "YourProperty". In order
		 * to use this kind of names, your implementation should use properties' nick
		 * name and override {@link property_use_nick} method to return true. This should
		 * instruct your code to use this method to use property's nick name. This is
		 * the default in GXml default implementations.
		 */
		public abstract bool property_use_nick ();
		/**
		 * Serialize this object.
		 *
		 * This method must call serialize_property() recursivally on all properties
		 * to serialize.
		 *
		 * @param node an {@link GXml.Node} object to serialize to.
		 */
		public abstract GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		/**
		 * Serialize a property @prop on a {@link GXml.Element}.
		 *
		 * This method is called recursivally by {@link serialize} method over all properties
		 * to be serialized.
		 */
		public abstract GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		/**
		 * Used to check {@link GXml.Element}'s contents must be deseralized.
		 *
		 * By default GXml's implementations doesn't deseriaze/serialize XML node contents.
		 * In order to enable it, you must override {@link serialize_use_xml_node_value}
		 * method to return true and store XML node's content to {@link serialized_xml_node_value}
		 * property.
		 *
		 * Implementors could set up methods to provide a clean easy to use API to set
		 * nodes contents. In most cases, users would like to set a value through a getter
		 * or setter or through a property in the class. If you use a property, you should
		 * add it to {@link ignored_serializable_properties} in order to see its value
		 * in a XML node property.
		 *
		 */
		public abstract bool serialize_use_xml_node_value ();
		/**
		 * Used to set specific namespace for an {@link GXml.Element}.
		 *
		 * By default no namspace prefix is added to {@link GXml.Element} on serialized. Implementors
		 * must consider override this methodk if this node should have a namespace.
		 */
		public abstract bool set_default_namespace (GXml.Node node);
		/**
		 * Transforms a string into another type hosted by {@link GLib.Value}.
		 *
		 * A utility function that handles converting a string
		 * representation of a value into the type specified by the
		 * supplied #GValue dest.  A #GXmlSerializableError will be
		 * set if the string cannot be parsed into the desired type.
		 * 
		 * {@link Serializable} interface support a number of data types to convert
		 * from its string representation. These are supported types:
		 * 
		 * a. integers: int8, int64, uint, long, ulong, char, uchar
		 * a. boolean
		 * a. floats: float, double
		 * a. enumerations
		 *
		 * @param str the string to transform into the given #GValue object
		 * @param dest the #GValue out parameter that will contain the parsed value from the string
		 * @return `true` if parsing succeeded, otherwise `false`
		 */
		public static bool string_to_gvalue (string str, ref GLib.Value dest) throws GXml.SerializableError;
		/**
		 * Used to add content in an {@link GXml.Element}.
		 *
		 * By default no contents is serialized/deseralized. Implementors must implement
		 * {@link Serializable.serialize_use_xml_node_value} function returning
		 * true in order to use this property.
		 *
		 * This property is ignored by default. Implementors must implement
		 * {@link serialize_use_xml_node_value} to return true and add a
		 * set and get function to get/set this value, in order to use your own API.
		 *
		 * This property is ignored on serialisation.
		 */
		public abstract string? serialized_xml_node_value { owned get; protected set; }
		/**
		 * On deserialization stores any {@link GXml.Node} not used on this
		 * object, but exists in current XML file.
		 *
		 * XML allows great flexibility, providing different ways to represent the same
		 * information. This is a problem when you try to deserialize them.
		 *
		 * In order to deserialize correctly, you must create your XML, both by
		 * serializing a {@link Serializable} object or by hand writing. By using the
		 * former, you can add extra information, like nodes or contents in known nodes,
		 * but most of them could be ignored or lost on deserialization/serialization process.
		 * To avoid data lost, you can override {@link get_enable_unknown_serializable_property}
		 * method in order to return true, your implementation or the ones in GXml, will
		 * store all unknown properties and nodes on deserialization and must serialize
		 * again back to the XML file. Even you are allowed to get this unknown objects
		 * by iterating on {@link Serializable.unknown_serializable_nodes} hash table.
		 *
		 * This property is ignored on serialisation.
		 */
		public abstract Gee.Collection<GXml.Node> unknown_serializable_nodes { owned get; }
		/**
		 * On deserialization stores any {@link GXml.Attribute} not used on this
		 * object, but exists in current XML file.
		 *
		 * Node's name is used as key to find stored {@link GXml.Attribute}, key is
		 * case sensitive.
		 *
		 * XML allows great flexibility, providing different ways to represent the same
		 * information. This is a problem when you try to deserialize them.
		 *
		 * In order to deserialize correctly, you must create your XML, both by
		 * serializing a {@link Serializable} object or by hand writing. By using the
		 * former, you can add extra information, like attributes, but most of
		 * them could be ignored or lost on deserialization/serialization process. To
		 * avoid data lost, you can override {@link get_enable_unknown_serializable_property}
		 * method in order to return true, your implementation or the ones in GXml, will
		 * store all unknown attributes on deserialization and must serialize
		 * again back to the XML file. Even you are allowed to get this unknown objects
		 * by iterating on {@link unknown_serializable_properties} collection, if you know
		 * attribute's name, use it to retrieve it.
		 *
		 * This property is ignored on serialisation.
		 */
		public abstract Gee.Map<string,GXml.Attribute> unknown_serializable_properties { owned get; }
		/**
		 * Signal to deserialize unknown properties.
		 *
		 * @param node a {@link GXml.Node} to get attribute from
		 * @param prop a {@link GLib.ParamSpec} describing attribute to deserialize
		 */
		public signal void deserialize_unknown_property (GXml.Node node, GLib.ParamSpec prop);
		/**
		 * Signal to deserialize unknown properties' type.
		 *
		 * @param node a {@link GXml.Node} to get attribute from
		 * @param prop a {@link GLib.ParamSpec} describing attribute to deserialize
		 */
		public signal void deserialize_unknown_property_type (GXml.Node node, GLib.ParamSpec prop);
		/**
		 * Signal to serialize unknown properties. Any new node must be added to
		 * @param element before return the new @param node added.
		 *
		 * @param element a {@link GXml.Node} to add attribute or child nodes to
		 * @param prop a {@link GLib.ParamSpec} describing attribute to serialize
		 * @param node set to the {@link GXml.Node} representing this attribute
		 */
		public signal void serialize_unknown_property (GXml.Node element, GLib.ParamSpec prop, out GXml.Node node);
		/**
		 * Signal to serialize unknown properties. Any new node must be added to
		 * @param element before return the new @node added.
		 * 
		 * @param element a {@link GXml.Node} to add attribute or child nodes to
		 * @param prop a {@link GLib.ParamSpec} describing attribute to serialize
		 * @param node set to the {@link GXml.Node} representing this attribute
		 */
		public signal void serialize_unknown_property_type (GXml.Node element, GLib.ParamSpec prop, out GXml.Node node);
	}
	/**
	 * Serializable Framework. interface to be implemented by any collection of {@link Serializable} objects.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableCollection : GLib.Object, Gee.Traversable<GXml.Serializable>, GXml.Serializable {
		/**
		 * Executes a deserialization from all children nodes in a {@link GXml.Node}. After this operation
		 * {@link GXml.SerializableCollection.deserialized} should return true. This
		 * operation should not be executed if {@link GXml.SerializableCollection.is_prepared}
		 * return false;
		 *
		 * This could override existing objects in collection.
		 */
		public abstract bool deserialize_children () throws GLib.Error;
		/**
		 * Executes a deserialization from a {@link GXml.Node}. After this operation
		 * {@link GXml.SerializableCollection.deserialized} should return true. This
		 * operation should not be executed if {@link GXml.SerializableCollection.is_prepared}
		 * return false;
		 *
		 * This could override existing objects in collection.
		 */
		public abstract bool deserialize_node (GXml.Node node) throws GLib.Error;
		/**
		 * Returns true if the collection should be deserialized from a {@link GXml.Node}'s children
		 * when {@link GXml.Serializable.deserialize} is called. For large collection of nodes
		 * this could impact in performance; return false and use {@link GXml.SerializableCollection.deserialize_children}
		 * when you need to deserialize all nodes to access them.
		 */
		public abstract bool deserialize_proceed ();
		/**
		 * Returns true if the collection was deserialized from a {@link GXml.Node}'s children.
		 */
		public abstract bool deserialized ();
		/**
		 * Convenient function to detect Serializable Collections.
		 */
		public virtual bool is_collection ();
	}
	/**
	 * Serializable Framework. Interface to get two keys to be used to store {@link Serializable} objects.
	 * 
	 * This interface must be implemented by classes derived from {@link GXml.SerializableDualKeyMap}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableMapDualKey<P,S> : GLib.Object {
		/**
		 * Implement this function to return the value to be used as primary key on
		 * {@link SerializableDualKeyMap} containers.
		 */
		public abstract P get_map_primary_key ();
		/**
		 * Implement this function to return the value to be used as secondary key on
		 * {@link SerializableDualKeyMap} containers.
		 */
		public abstract S get_map_secondary_key ();
	}
	/**
	 * Serializable Framework. Interface to get one key to be used to store {@link Serializable} objects.
	 * 
	 * This interface must be implemented by classes derived from {@link SerializableTreeMap}
	 * and {@link SerializableHashMap}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableMapKey<K> : GLib.Object {
		/**
		 * Implement this function to return the value to be used as key on {@link SerializableTreeMap}
		 * and {@link SerializableHashMap} containers.
		 */
		public abstract K get_map_key ();
	}
	/**
	 * Represent any property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 * The actual value stored and returned by {@link GXml.SerializableProperty.get_serializable_property_value}
	 * is the actual string in the XML property, this means may the value could differ from the spected value
	 * on some implementations like {@link GXml.SerializableInt}. Take a look in each implementations about
	 * retured values.
	 *
	 * Implementations of {@link GXml.SerializableProperty}, could be used to provide more flexibility
	 * when parsing {@link GXml.Attribute} properties values and to exclude to be serialized if they have not
	 * been created in the holding objects.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableProperty : GLib.Object {
		/**
		 * Tryies to deserialize from a {@link GXml.Node} searching a {@link GXml.Attribute}
		 * with the name in @param prop or from its nick if @nick is true.
		 */
		public bool default_serializable_property_deserialize_property (GXml.Node property_node, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Default serialization method to add a {@link GXml.Attribute} to a {@link GXml.Element}
		 *
		 * If {@link GXml.SerializableProperty.get_serializable_property_value} returns null
		 * given {@link GXml.Node} is not modified.
		 */
		public GXml.Node? default_serializable_property_serialize_property (GXml.Node element, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Tryies to deserialize from a {@link GXml.Node} searching a {@link GXml.Attribute}
		 * with the name provided in @param prop or its nick if @nick is true,
		 * if not set, then {@link GLib.ParamSpec} name should used. If @param nick is set to true,
		 * then {@link GLib.ParamSpec} nick is used as name.
		 */
		public virtual bool deserialize_property (GXml.Node property_node, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Value to be set to a {@link GXml.Attribute}, to be added to a {@link GXml.Element}
		 */
		public abstract string get_serializable_property_value ();
		/**
		 * Serialization method to add a {@link GXml.Attribute} to a {@link GXml.Element}, using {@link GLib.ParamSpec}
		 * name or nick, if @param nick is set to true, as the attribute's name.
		 *
		 * If {@link GXml.SerializableProperty.get_serializable_property_value} returns null
		 * given {@link GXml.Node} should not be modified.
		 */
		public virtual GXml.Node? serialize_property (GXml.Node property_node, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Set value to be set to a {@link GXml.Attribute}, to be added to a {@link GXml.Element}
		 *
		 * If value is set to @null then the property will be ignored by default and no
		 * property will be set to given {@link GXml.Element}.
		 *
		 * Some implementations stores the value without any convertion at all; then if the value,
		 * from XML property, makes no sense for the property type, you should take care
		 * to use the provided API from them to convert it.
		 */
		public abstract void set_serializable_property_value (string? val);
	}
	/**
	 * Representation of text nodes in any {@link GXml.Node}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Text : GLib.Object, GXml.Node {
		/**
		 * This should be implemented by returning {@link GXml.Node.value}
		 */
		public abstract string str { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface XPathContext : GLib.Object {
		/**
		 * Evaluate XPath expression.
		 *
		 * This method evaluates provided expression, registers provided namespaces in resolver and returns an {@link GXml.XPath.Object}.
		 *
		 * Throw {@link GXml.XPath.Error} if one of provided namespaces is invalid.
		 */
		public abstract GXml.XPathObject evaluate (string expression, Gee.List<GXml.Namespace>? resolver = null) throws GXml.XPathError;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface XPathObject : GLib.Object {
		/**
		 *
		 */
		public abstract bool boolean_value { get; }
		/**
		 *
		 */
		public abstract GXml.DomHTMLCollection nodeset { get; }
		/**
		 *
		 */
		public abstract double number_value { get; }
		/**
		 *
		 */
		public abstract GXml.XPathObjectType object_type { get; }
		/**
		 *
		 */
		public abstract string string_value { get; }
	}
	/**
	 * Enumerates possible NodeTypes.
	 *
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-1950641247]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum NodeType {
		INVALID,
		ELEMENT,
		ATTRIBUTE,
		TEXT,
		CDATA_SECTION,
		ENTITY_REFERENCE,
		ENTITY,
		PROCESSING_INSTRUCTION,
		COMMENT,
		DOCUMENT,
		DOCUMENT_TYPE,
		DOCUMENT_FRAGMENT,
		NOTATION
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum XPathObjectType {
		UNDEFINED,
		NODESET,
		BOOLEAN,
		NUMBER,
		STRING,
		POINT,
		RANGE,
		LOCATIONSET,
		USERS,
		XSLT_TREE
	}
	/**
	 * Errors for documents handling reading/writing
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain DocumentError {
		INVALID_DOCUMENT_ERROR,
		INVALID_FILE
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain DomError {
		INDEX_SIZE_ERROR,
		DOMSTRING_SIZE_ERROR,
		HIERARCHY_REQUEST_ERROR,
		WRONG_DOCUMENT_ERROR,
		INVALID_CHARACTER_ERROR,
		NO_DATA_ALLOWED_ERROR,
		NO_MODIFICATION_ALLOWED_ERROR,
		NOT_FOUND_ERROR,
		NOT_SUPPORTED_ERROR,
		INUSE_ATTRIBUTE_ERROR,
		INVALID_STATE_ERROR,
		SYNTAX_ERROR,
		INVALID_MODIFICATION_ERROR,
		NAMESPACE_ERROR,
		INVALID_ACCESS_ERROR,
		VALIDATION_ERROR,
		TYPE_MISMATCH_ERROR,
		SECURITY_ERROR,
		NETWORK_ERROR,
		ABORT_ERROR,
		URL_MISMATCH_ERROR,
		QUOTA_EXCEEDED_ERROR,
		TIME_OUT_ERROR,
		INVALID_NODE_TYPE_ERROR,
		DATA_CLONE_ERROR
	}
	/**
	 * Errors when de/serializing enumerations.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain EnumerationError {
		/**
		 * Given value is invalid in enumeration, when transform to string.
		 */
		INVALID_VALUE,
		/**
		 * Given text to transform to an enumeration's value.
		 */
		INVALID_TEXT
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain Error {
		NOT_SUPPORTED,
		PARSER,
		WRITER
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain ParserError {
		INVALID_DATA_ERROR,
		INVALID_FILE_ERROR,
		INVALID_STREAM_ERROR
	}
	/**
	 * Errors when de/serializing enumerations as a set of string when using {@link GXml.SerializableEnum}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain SerializableEnumError {
		INVALID_VALUE_ERROR,
		PARSE_ERROR
	}
	/**
	 * Errors from {@link Serializable}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain SerializableError {
		/**
		 * An object with a known {@link GLib.Type} that we do not support was encountered.
		 */
		UNSUPPORTED_TYPE_ERROR,
		STR_TO_VALUE_ERROR
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain XPathError {
		EXPRESSION_OK,
		NUMBER_ERROR,
		UNFINISHED_LITERAL_ERROR,
		START_LITERAL_ERROR,
		VARIABLE_REF_ERROR,
		UNDEF_VARIABLE_ERROR,
		INVALID_PREDICATE_ERROR,
		EXPR_ERROR,
		UNCLOSED_ERROR,
		UNKNOWN_FUNC_ERROR,
		INVALID_OPERAND,
		INVALID_TYPE,
		INVALID_ARITY,
		INVALID_CTXT_SIZE,
		INVALID_CTXT_POSITION,
		MEMORY_ERROR,
		XPTR_SYNTAX_ERROR,
		XPTR_RESOURCE_ERROR,
		XPTR_SUB_RESOURCE_ERROR,
		UNDEF_PREFIX_ERROR,
		ENCODING_ERROR,
		INVALID_CHAR_ERROR,
		INVALID_CTXT
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public delegate void DomMutationCallback (Gee.List<GXml.DomMutationRecord> mutations, GXml.DomMutationObserver observer);
}
