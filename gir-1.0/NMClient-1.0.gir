<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="DBusGLib" version="1.0"/>
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <include name="NetworkManager" version="1.0"/>
  <package name="libnm-glib"/>
  <package name="libnm-glib-vpn"/>
  <namespace name="NMClient"
             version="1.0"
             shared-library="libnm-glib.so.4,libnm-util.so.2"
             c:identifier-prefixes="NM"
             c:symbol-prefixes="nm">
    <constant name="ACCESS_POINT_BSSID"
              value="bssid"
              c:type="NM_ACCESS_POINT_BSSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_FLAGS"
              value="flags"
              c:type="NM_ACCESS_POINT_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_FREQUENCY"
              value="frequency"
              c:type="NM_ACCESS_POINT_FREQUENCY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_HW_ADDRESS"
              value="hw-address"
              c:type="NM_ACCESS_POINT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_MAX_BITRATE"
              value="max-bitrate"
              c:type="NM_ACCESS_POINT_MAX_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_MODE"
              value="mode"
              c:type="NM_ACCESS_POINT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_RSN_FLAGS"
              value="rsn-flags"
              c:type="NM_ACCESS_POINT_RSN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_SSID"
              value="ssid"
              c:type="NM_ACCESS_POINT_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_STRENGTH"
              value="strength"
              c:type="NM_ACCESS_POINT_STRENGTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCESS_POINT_WPA_FLAGS"
              value="wpa-flags"
              c:type="NM_ACCESS_POINT_WPA_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_CONNECTION"
              value="connection"
              c:type="NM_ACTIVE_CONNECTION_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEFAULT"
              value="default"
              c:type="NM_ACTIVE_CONNECTION_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEFAULT6"
              value="default6"
              c:type="NM_ACTIVE_CONNECTION_DEFAULT6">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_DEVICES"
              value="devices"
              c:type="NM_ACTIVE_CONNECTION_DEVICES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_MASTER"
              value="master"
              c:type="NM_ACTIVE_CONNECTION_MASTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_SPECIFIC_OBJECT"
              value="specific-object"
              c:type="NM_ACTIVE_CONNECTION_SPECIFIC_OBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_STATE"
              value="state"
              c:type="NM_ACTIVE_CONNECTION_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACTIVE_CONNECTION_UUID"
              value="uuid"
              c:type="NM_ACTIVE_CONNECTION_UUID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="AccessPoint"
           c:symbol-prefix="access_point"
           c:type="NMAccessPoint"
           parent="Object"
           glib:type-name="NMAccessPoint"
           glib:get-type="nm_access_point_get_type"
           glib:type-struct="AccessPointClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_access_point_new">
        <doc xml:whitespace="preserve">Creates a new #NMAccessPoint.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new access point</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBusobject path of the access point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="connection_valid"
              c:identifier="nm_access_point_connection_valid">
        <doc xml:whitespace="preserve">Validates a given connection against a given WiFi access point to ensure that
the connection may be activated with that AP.  The connection must match the
@ap's SSID, (if given) BSSID, and other attributes like security settings,
channel, band, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection may be activated with this WiFi AP, %FALSE if it cannot be.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMAccessPoint to validate @connection against</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMConnection to validate against @ap</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_access_point_filter_connections">
        <doc xml:whitespace="preserve">Filters a given list of connections for a given #NMAccessPoint object and
return connections which may be activated with the access point.  Any
returned connections will match the @ap's SSID and (if given) BSSID and
other attributes like security settings, channel, etc.

To obtain the list of connections that are compatible with this access point,
use nm_remote_settings_list_connections() and then filter the returned list
for a given #NMDevice using nm_device_filter_connections() and finally
filter that list with this function.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a list of #NMConnection objects that could be activated with the given @ap. The elements of the list are owned by their creator and should not be freed by the caller, but the returned list itself is owned by the caller and should be freed with g_slist_free() when it is no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="NetworkManager.Connection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMAccessPoint to filter connections for</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:whitespace="preserve">a list of #NMConnection objects to filter</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="NetworkManager.Connection"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_bssid" c:identifier="nm_access_point_get_bssid">
        <doc xml:whitespace="preserve">Gets the Basic Service Set ID (BSSID) of the WiFi access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the BSSID of the access point. This is an internal string and must not be modified or freed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="nm_access_point_get_flags">
        <doc xml:whitespace="preserve">Gets the flags of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the flags</doc>
          <type name="NetworkManager.80211ApFlags" c:type="NM80211ApFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frequency"
              c:identifier="nm_access_point_get_frequency">
        <doc xml:whitespace="preserve">Gets the frequency of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the frequency</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_access_point_get_hw_address"
              deprecated="Use nm_access_point_get_bssid() instead."
              deprecated-version="0.9">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address of the access point. This is the internal string used by the access point and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_bitrate"
              c:identifier="nm_access_point_get_max_bitrate">
        <doc xml:whitespace="preserve">Gets the maximum bit rate of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the maximum bit rate</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_access_point_get_mode">
        <doc xml:whitespace="preserve">Gets the mode of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the mode</doc>
          <type name="NetworkManager.80211Mode" c:type="NM80211Mode"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rsn_flags"
              c:identifier="nm_access_point_get_rsn_flags">
        <doc xml:whitespace="preserve">Gets the RSN (Robust Secure Network, ie WPA version 2) flags of the access
point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the RSN flags</doc>
          <type name="NetworkManager.80211ApSecurityFlags"
                c:type="NM80211ApSecurityFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_access_point_get_ssid">
        <doc xml:whitespace="preserve">Gets the SSID of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GByteArray containing the SSID. This is the internal copy used by the access point, and must not be modified.</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_strength" c:identifier="nm_access_point_get_strength">
        <doc xml:whitespace="preserve">Gets the current signal strength of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal strength</doc>
          <type name="guint8" c:type="guint8"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wpa_flags"
              c:identifier="nm_access_point_get_wpa_flags">
        <doc xml:whitespace="preserve">Gets the WPA (version 1) flags of the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the WPA flags</doc>
          <type name="NetworkManager.80211ApSecurityFlags"
                c:type="NM80211ApSecurityFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMAccessPoint</doc>
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bssid" transfer-ownership="none">
        <doc xml:whitespace="preserve">The BSSID of the access point.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="flags" transfer-ownership="none">
        <doc xml:whitespace="preserve">The flags of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="frequency" transfer-ownership="none">
        <doc xml:whitespace="preserve">The frequency of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware address of the access point.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="max-bitrate" transfer-ownership="none">
        <doc xml:whitespace="preserve">The maximum bit rate of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mode" transfer-ownership="none">
        <doc xml:whitespace="preserve">The mode of the access point; either "infrastructure" (a central
coordinator of the wireless network allowing clients to connect) or
"ad-hoc" (a network with no central controller).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="rsn-flags" transfer-ownership="none">
        <doc xml:whitespace="preserve">The RSN flags of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="ssid" transfer-ownership="none">
        <doc xml:whitespace="preserve">The SSID of the access point.</doc>
        <type name="Ssid"/>
      </property>
      <property name="strength" transfer-ownership="none">
        <doc xml:whitespace="preserve">The current signal strength of the access point.</doc>
        <type name="guint8" c:type="guint8"/>
      </property>
      <property name="wpa-flags" transfer-ownership="none">
        <doc xml:whitespace="preserve">The WPA flags of the access point.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="AccessPointClass"
            c:type="NMAccessPointClass"
            glib:is-gtype-struct-for="AccessPoint">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="ActiveConnection"
           c:symbol-prefix="active_connection"
           c:type="NMActiveConnection"
           parent="Object"
           glib:type-name="NMActiveConnection"
           glib:get-type="nm_active_connection_get_type"
           glib:type-struct="ActiveConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_active_connection_new">
        <doc xml:whitespace="preserve">Creates a new #NMActiveConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new active connection</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_connection"
              c:identifier="nm_active_connection_get_connection">
        <doc xml:whitespace="preserve">Gets the #NMConnection&lt;!-- --&gt;'s DBus object path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of the #NMConnection inside of #NMActiveConnection. This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default"
              c:identifier="nm_active_connection_get_default">
        <doc xml:whitespace="preserve">Whether the active connection is the default IPv4 one (that is, is used for
the default IPv4 route and DNS information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the active connection is the default IPv4 connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_default6"
              c:identifier="nm_active_connection_get_default6">
        <doc xml:whitespace="preserve">Whether the active connection is the default IPv6 one (that is, is used for
the default IPv6 route and DNS information).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the active connection is the default IPv6 connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_devices"
              c:identifier="nm_active_connection_get_devices">
        <doc xml:whitespace="preserve">Gets the #NMDevice&lt;!-- --&gt;s used for the active connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GPtrArray containing #NMDevice&lt;!-- --&gt;s. This is the internal copy used by the connection, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_master" c:identifier="nm_active_connection_get_master">
        <doc xml:whitespace="preserve">Gets the path to the master #NMDevice of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the path of the master #NMDevice of the #NMActiveConnection. This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specific_object"
              c:identifier="nm_active_connection_get_specific_object">
        <doc xml:whitespace="preserve">Gets the "specific object" used at the activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the specific object's DBus path. This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_active_connection_get_state">
        <doc xml:whitespace="preserve">Gets the active connection's state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the state</doc>
          <type name="NetworkManager.ActiveConnectionState"
                c:type="NMActiveConnectionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="nm_active_connection_get_uuid">
        <doc xml:whitespace="preserve">Gets the #NMConnection&lt;!-- --&gt;'s UUID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the UUID of the #NMConnection that backs the #NMActiveConnection. This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMActiveConnection</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="connection" transfer-ownership="none">
        <doc xml:whitespace="preserve">The connection's path of the active connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="default" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the active connection is the default IPv4 one.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="default6" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the active connection is the default IPv6 one.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="devices" transfer-ownership="none">
        <type name="ObjectArray"/>
      </property>
      <property name="master" transfer-ownership="none">
        <doc xml:whitespace="preserve">The path of the master device if one exists.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="specific-object" transfer-ownership="none">
        <doc xml:whitespace="preserve">The specific object's path of the active connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:whitespace="preserve">The state of the active connection.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="uuid" transfer-ownership="none">
        <doc xml:whitespace="preserve">The active connection's UUID</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="ActiveConnectionClass"
            c:type="NMActiveConnectionClass"
            glib:is-gtype-struct-for="ActiveConnection">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="CLIENT_ACTIVE_CONNECTIONS"
              value="active-connections"
              c:type="NM_CLIENT_ACTIVE_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_MANAGER_RUNNING"
              value="manager-running"
              c:type="NM_CLIENT_MANAGER_RUNNING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_NETWORKING_ENABLED"
              value="networking-enabled"
              c:type="NM_CLIENT_NETWORKING_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_STATE" value="state" c:type="NM_CLIENT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_VERSION" value="version" c:type="NM_CLIENT_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIMAX_ENABLED"
              value="wimax-enabled"
              c:type="NM_CLIENT_WIMAX_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIMAX_HARDWARE_ENABLED"
              value="wimax-hardware-enabled"
              c:type="NM_CLIENT_WIMAX_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIRELESS_ENABLED"
              value="wireless-enabled"
              c:type="NM_CLIENT_WIRELESS_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WIRELESS_HARDWARE_ENABLED"
              value="wireless-hardware-enabled"
              c:type="NM_CLIENT_WIRELESS_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WWAN_ENABLED"
              value="wwan-enabled"
              c:type="NM_CLIENT_WWAN_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_WWAN_HARDWARE_ENABLED"
              value="wwan-hardware-enabled"
              c:type="NM_CLIENT_WWAN_HARDWARE_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Client"
           c:symbol-prefix="client"
           c:type="NMClient"
           parent="Object"
           glib:type-name="NMClient"
           glib:get-type="nm_client_get_type"
           glib:type-struct="ClientClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_client_new">
        <doc xml:whitespace="preserve">Creates a new #NMClient.

Note that this will do blocking D-Bus calls to initialize the
client. You can use nm_client_new_async() if you want to avoid
that.

NOTE: #NMClient provides information about devices and a mechanism to
control them.  To access and modify network configuration data, use the
#NMRemoteSettings object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #NMClient</doc>
          <type name="Client" c:type="NMClient*"/>
        </return-value>
      </constructor>
      <constructor name="new_finish"
                   c:identifier="nm_client_new_finish"
                   throws="1">
        <doc xml:whitespace="preserve">Gets the result of an nm_client_new_async() call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #NMClient, or %NULL on error</doc>
          <type name="Client" c:type="NMClient*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async" c:identifier="nm_client_new_async">
        <doc xml:whitespace="preserve">Creates a new #NMClient and begins asynchronously initializing it.
@callback will be called when it is done; use
nm_client_new_finish() to get the result.

NOTE: #NMClient provides information about devices and a mechanism to
control them.  To access and modify network configuration data, use the
#NMRemoteSettings object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">callback to call when the client is created</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="device_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="device_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="permission_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="permission" transfer-ownership="none">
            <type name="ClientPermission" c:type="NMClientPermission"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="ClientPermissionResult"
                  c:type="NMClientPermissionResult"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="activate_connection"
              c:identifier="nm_client_activate_connection">
        <doc xml:whitespace="preserve">Starts a connection to a particular network using the configuration settings
from @connection and the network device @device.  Certain connection types
also take a "specific object" which is the object path of a connection-
specific object, like an #NMAccessPoint for WiFi connections, or an
#NMWimaxNsp for WiMAX connections, to which you wish to connect.  If the
specific object is not given, NetworkManager can, in some cases, automatically
determine which network to connect to given the settings in @connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="device" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
          <parameter name="specific_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the object path of a connection-type-specific object this activation should use. This parameter is currently ignored for wired and mobile broadband connections, and the value of NULL should be used (ie, no specific object).  For WiFi or WiMAX connections, pass the object path of a #NMAccessPoint or #NMWimaxNsp owned by @device, which you can get using nm_object_get_path(), and which will be used to complete the details of the newly added connection.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">the function to call when the call is done</doc>
            <type name="ClientActivateFn" c:type="NMClientActivateFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_and_activate_connection"
              c:identifier="nm_client_add_and_activate_connection">
        <doc xml:whitespace="preserve">Adds a new connection using the given details (if any) as a template,
automatically filling in missing settings with the capabilities of the
given device and specific object.  The new connection is then activated.
Cannot be used for VPN connections at this time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="partial" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an #NMConnection to add; the connection may be partially filled (or even NULL) and will be completed by NetworkManager using the given @device and @specific_object before being added</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </parameter>
          <parameter name="specific_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the object path of a connection-type-specific object this activation should use. This parameter is currently ignored for wired and mobile broadband connections, and the value of NULL should be used (ie, no specific object).  For WiFi or WiMAX connections, pass the object path of a #NMAccessPoint or #NMWimaxNsp owned by @device, which you can get using nm_object_get_path(), and which will be used to complete the details of the newly added connection.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">the function to call when the call is done</doc>
            <type name="ClientAddActivateFn" c:type="NMClientAddActivateFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="deactivate_connection"
              c:identifier="nm_client_deactivate_connection">
        <doc xml:whitespace="preserve">Deactivates an active #NMActiveConnection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMActiveConnection to deactivate</doc>
            <type name="ActiveConnection" c:type="NMActiveConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_active_connections"
              c:identifier="nm_client_get_active_connections">
        <doc xml:whitespace="preserve">Gets the active connections.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray containing all the active #NMActiveConnection&lt;!-- --&gt;s. The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="ActiveConnection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_by_iface"
              c:identifier="nm_client_get_device_by_iface">
        <doc xml:whitespace="preserve">Gets a #NMDevice from a #NMClient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMDevice for the given @iface or %NULL if none is found.</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the interface name to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_device_by_path"
              c:identifier="nm_client_get_device_by_path">
        <doc xml:whitespace="preserve">Gets a #NMDevice from a #NMClient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMDevice for the given @object_path or %NULL if none is found.</doc>
          <type name="Device" c:type="NMDevice*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path to search for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_devices" c:identifier="nm_client_get_devices">
        <doc xml:whitespace="preserve">Gets all the known network devices.  Use nm_device_get_type() or the
NM_IS_DEVICE_XXXX() functions to determine what kind of device member of the
returned array is, and then you may use device-specific methods such as
nm_device_ethernet_get_hw_address().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray containing all the #NMDevice&lt;!-- --&gt;s.  The returned array is owned by the #NMClient object and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_logging"
              c:identifier="nm_client_get_logging"
              throws="1">
        <doc xml:whitespace="preserve">Gets NetworkManager current logging level and domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">return location for logging level string</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="domains" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">return location for log domains string. The string is a list of domains separated by ","</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_manager_running"
              c:identifier="nm_client_get_manager_running">
        <doc xml:whitespace="preserve">Determines whether the daemon is running.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the daemon is running</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permission_result"
              c:identifier="nm_client_get_permission_result">
        <doc xml:whitespace="preserve">Requests the result of a specific permission, which indicates whether the
client can or cannot perform the action the permission represents</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the permission's result, one of #NMClientPermissionResult</doc>
          <type name="ClientPermissionResult"
                c:type="NMClientPermissionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="permission" transfer-ownership="none">
            <doc xml:whitespace="preserve">the permission for which to return the result, one of #NMClientPermission</doc>
            <type name="ClientPermission" c:type="NMClientPermission"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_client_get_state">
        <doc xml:whitespace="preserve">Gets the current daemon state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current %NMState</doc>
          <type name="NetworkManager.State" c:type="NMState"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_version" c:identifier="nm_client_get_version">
        <doc xml:whitespace="preserve">Gets NetworkManager version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">string with the version</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="networking_get_enabled"
              c:identifier="nm_client_networking_get_enabled">
        <doc xml:whitespace="preserve">Whether networking is enabled or disabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if networking is enabled, %FALSE if networking is disabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="networking_set_enabled"
              c:identifier="nm_client_networking_set_enabled">
        <doc xml:whitespace="preserve">Enables or disables networking.  When networking is disabled, all controlled
interfaces are disconnected and deactivated.  When networking is enabled,
all controlled interfaces are available for activation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to set networking enabled, %FALSE to set networking disabled</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_logging"
              c:identifier="nm_client_set_logging"
              throws="1">
        <doc xml:whitespace="preserve">Sets NetworkManager logging level and/or domains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">logging level to set (%NULL or an empty string for no change)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="domains" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">logging domains to set. The string should be a list of log domains separated by ",". (%NULL or an empty string for no change)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sleep" c:identifier="nm_client_sleep">
        <doc xml:whitespace="preserve">Deprecated; use nm_client_networking_set_enabled() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="sleep_" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to put the daemon to sleep</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wimax_get_enabled"
              c:identifier="nm_client_wimax_get_enabled">
        <doc xml:whitespace="preserve">Determines whether WiMAX is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if WiMAX is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wimax_hardware_get_enabled"
              c:identifier="nm_client_wimax_hardware_get_enabled">
        <doc xml:whitespace="preserve">Determines whether the WiMAX hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the WiMAX hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wimax_set_enabled"
              c:identifier="nm_client_wimax_set_enabled">
        <doc xml:whitespace="preserve">Enables or disables WiMAX devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to enable WiMAX</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wireless_get_enabled"
              c:identifier="nm_client_wireless_get_enabled">
        <doc xml:whitespace="preserve">Determines whether the wireless is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if wireless is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wireless_hardware_get_enabled"
              c:identifier="nm_client_wireless_hardware_get_enabled">
        <doc xml:whitespace="preserve">Determines whether the wireless hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the wireless hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wireless_set_enabled"
              c:identifier="nm_client_wireless_set_enabled">
        <doc xml:whitespace="preserve">Enables or disables wireless devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to enable wireless</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wwan_get_enabled"
              c:identifier="nm_client_wwan_get_enabled">
        <doc xml:whitespace="preserve">Determines whether WWAN is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if WWAN is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wwan_hardware_get_enabled"
              c:identifier="nm_client_wwan_hardware_get_enabled">
        <doc xml:whitespace="preserve">Determines whether the WWAN hardware is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the WWAN hardware is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wwan_set_enabled"
              c:identifier="nm_client_wwan_set_enabled">
        <doc xml:whitespace="preserve">Enables or disables WWAN devices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMClient</doc>
            <type name="Client" c:type="NMClient*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to enable WWAN</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="active-connections" transfer-ownership="none">
        <type name="ObjectArray"/>
      </property>
      <property name="manager-running" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="networking-enabled"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:whitespace="preserve">The current daemon state.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="version" transfer-ownership="none">
        <doc xml:whitespace="preserve">The NetworkManager version.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wimax-enabled" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wimax-hardware-enabled" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wireless-enabled" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wireless-hardware-enabled" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wwan-enabled" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="wwan-hardware-enabled" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
      <glib:signal name="device-added" when="first">
        <doc xml:whitespace="preserve">Notifies that a #NMDevice is added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="device-removed" when="first">
        <doc xml:whitespace="preserve">Notifies that a #NMDevice is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">the removed device</doc>
            <type name="Device"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="permission-changed" when="first">
        <doc xml:whitespace="preserve">Notifies that a permission has changed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="permission" transfer-ownership="none">
            <doc xml:whitespace="preserve">a permission from #NMClientPermission</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the permission's result, one of #NMClientPermissionResult</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="ClientActivateFn" c:type="NMClientActivateFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <type name="Client" c:type="NMClient*"/>
        </parameter>
        <parameter name="active_connection" transfer-ownership="none">
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ClientAddActivateFn" c:type="NMClientAddActivateFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <type name="Client" c:type="NMClient*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </parameter>
        <parameter name="new_connection_path" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClientClass"
            c:type="NMClientClass"
            glib:is-gtype-struct-for="Client">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="device_added">
        <callback name="device_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="device_removed">
        <callback name="device_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="permission_changed">
        <callback name="permission_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="client" transfer-ownership="none">
              <type name="Client" c:type="NMClient*"/>
            </parameter>
            <parameter name="permission" transfer-ownership="none">
              <type name="ClientPermission" c:type="NMClientPermission"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="ClientPermissionResult"
                    c:type="NMClientPermissionResult"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ClientPermission"
                 glib:type-name="NMClientPermission"
                 glib:get-type="nm_client_permission_get_type"
                 c:type="NMClientPermission">
      <doc xml:whitespace="preserve">#NMClientPermission values indicate various permissions that NetworkManager
clients can obtain to perform certain tasks on behalf of the current user.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_CLIENT_PERMISSION_NONE"
              glib:nick="none">
        <doc xml:whitespace="preserve">unknown or no permission</doc>
      </member>
      <member name="enable_disable_network"
              value="1"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK"
              glib:nick="enable-disable-network">
        <doc xml:whitespace="preserve">controls whether networking can be globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wifi"
              value="2"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI"
              glib:nick="enable-disable-wifi">
        <doc xml:whitespace="preserve">controls whether WiFi can be globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wwan"
              value="3"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN"
              glib:nick="enable-disable-wwan">
        <doc xml:whitespace="preserve">controls whether WWAN (3G) can be globally enabled or disabled</doc>
      </member>
      <member name="enable_disable_wimax"
              value="4"
              c:identifier="NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX"
              glib:nick="enable-disable-wimax">
        <doc xml:whitespace="preserve">controls whether WiMAX can be globally enabled or disabled</doc>
      </member>
      <member name="sleep_wake"
              value="5"
              c:identifier="NM_CLIENT_PERMISSION_SLEEP_WAKE"
              glib:nick="sleep-wake">
        <doc xml:whitespace="preserve">controls whether the client can ask NetworkManager to sleep and wake</doc>
      </member>
      <member name="network_control"
              value="6"
              c:identifier="NM_CLIENT_PERMISSION_NETWORK_CONTROL"
              glib:nick="network-control">
        <doc xml:whitespace="preserve">controls whether networking connections can be started, stopped, and changed</doc>
      </member>
      <member name="wifi_share_protected"
              value="7"
              c:identifier="NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED"
              glib:nick="wifi-share-protected">
        <doc xml:whitespace="preserve">controls whether a password protected WiFi hotspot can be created</doc>
      </member>
      <member name="wifi_share_open"
              value="8"
              c:identifier="NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN"
              glib:nick="wifi-share-open">
        <doc xml:whitespace="preserve">controls whether an open WiFi hotspot can be created</doc>
      </member>
      <member name="settings_modify_system"
              value="9"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM"
              glib:nick="settings-modify-system">
        <doc xml:whitespace="preserve">controls whether connections that are available to all users can be modified</doc>
      </member>
      <member name="settings_modify_own"
              value="10"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN"
              glib:nick="settings-modify-own">
        <doc xml:whitespace="preserve">controls whether connections owned by the current user can be modified</doc>
      </member>
      <member name="settings_modify_hostname"
              value="11"
              c:identifier="NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME"
              glib:nick="settings-modify-hostname">
        <doc xml:whitespace="preserve">controls whether the persistent hostname can be changed</doc>
      </member>
      <member name="last"
              value="11"
              c:identifier="NM_CLIENT_PERMISSION_LAST"
              glib:nick="last">
        <doc xml:whitespace="preserve">a reserved boundary value</doc>
      </member>
    </enumeration>
    <enumeration name="ClientPermissionResult"
                 glib:type-name="NMClientPermissionResult"
                 glib:get-type="nm_client_permission_result_get_type"
                 c:type="NMClientPermissionResult">
      <doc xml:whitespace="preserve">#NMClientPermissionResult values indicate what authorizations and permissions
the user requires to obtain a given #NMClientPermission</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:whitespace="preserve">unknown or no authorization</doc>
      </member>
      <member name="yes"
              value="1"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_YES"
              glib:nick="yes">
        <doc xml:whitespace="preserve">the permission is available</doc>
      </member>
      <member name="auth"
              value="2"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_AUTH"
              glib:nick="auth">
        <doc xml:whitespace="preserve">authorization is necessary before the permission is available</doc>
      </member>
      <member name="no"
              value="3"
              c:identifier="NM_CLIENT_PERMISSION_RESULT_NO"
              glib:nick="no">
        <doc xml:whitespace="preserve">permission to perform the operation is denied by system policy</doc>
      </member>
    </enumeration>
    <constant name="DEVICE_ACTIVE_CONNECTION"
              value="active-connection"
              c:type="NM_DEVICE_ACTIVE_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ADSL_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_ADSL_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_AUTOCONNECT"
              value="autoconnect"
              c:type="NM_DEVICE_AUTOCONNECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_AVAILABLE_CONNECTIONS"
              value="available-connections"
              c:type="NM_DEVICE_AVAILABLE_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_BOND_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BOND_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BOND_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_BOND_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_BRIDGE_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BRIDGE_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BRIDGE_SLAVES"
              value="slaves"
              c:type="NM_DEVICE_BRIDGE_SLAVES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_CAPABILITIES"
              value="bt-capabilities"
              c:type="NM_DEVICE_BT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_BT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_BT_NAME" value="name" c:type="NM_DEVICE_BT_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_CAPABILITIES"
              value="capabilities"
              c:type="NM_DEVICE_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DEVICE_TYPE"
              value="device-type"
              c:type="NM_DEVICE_DEVICE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DHCP4_CONFIG"
              value="dhcp4-config"
              c:type="NM_DEVICE_DHCP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DHCP6_CONFIG"
              value="dhcp6-config"
              c:type="NM_DEVICE_DHCP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DRIVER" value="driver" c:type="NM_DEVICE_DRIVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_DRIVER_VERSION"
              value="driver-version"
              c:type="NM_DEVICE_DRIVER_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_ETHERNET_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_ETHERNET_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_PERMANENT_HW_ADDRESS"
              value="perm-hw-address"
              c:type="NM_DEVICE_ETHERNET_PERMANENT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_ETHERNET_SPEED"
              value="speed"
              c:type="NM_DEVICE_ETHERNET_SPEED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_FIRMWARE_MISSING"
              value="firmware-missing"
              c:type="NM_DEVICE_FIRMWARE_MISSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_FIRMWARE_VERSION"
              value="firmware-version"
              c:type="NM_DEVICE_FIRMWARE_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INFINIBAND_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_INFINIBAND_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INFINIBAND_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_INFINIBAND_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_INTERFACE"
              value="interface"
              c:type="NM_DEVICE_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP4_CONFIG"
              value="ip4-config"
              c:type="NM_DEVICE_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP6_CONFIG"
              value="ip6-config"
              c:type="NM_DEVICE_IP6_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_IP_INTERFACE"
              value="ip-interface"
              c:type="NM_DEVICE_IP_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MANAGED" value="managed" c:type="NM_DEVICE_MANAGED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MODEM_CURRENT_CAPABILITIES"
              value="current-capabilities"
              c:type="NM_DEVICE_MODEM_CURRENT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_MODEM_MODEM_CAPABILITIES"
              value="modem-capabilities"
              c:type="NM_DEVICE_MODEM_MODEM_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_ACTIVE_CHANNEL"
              value="active-channel"
              c:type="NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_COMPANION"
              value="companion"
              c:type="NM_DEVICE_OLPC_MESH_COMPANION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_OLPC_MESH_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_OLPC_MESH_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_PRODUCT" value="product" c:type="NM_DEVICE_PRODUCT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_STATE" value="state" c:type="NM_DEVICE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_STATE_REASON"
              value="state-reason"
              c:type="NM_DEVICE_STATE_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_UDI" value="udi" c:type="NM_DEVICE_UDI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VENDOR" value="vendor" c:type="NM_DEVICE_VENDOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_CARRIER"
              value="carrier"
              c:type="NM_DEVICE_VLAN_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_VLAN_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_VLAN_VLAN_ID"
              value="vlan-id"
              c:type="NM_DEVICE_VLAN_VLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_ACTIVE_ACCESS_POINT"
              value="active-access-point"
              c:type="NM_DEVICE_WIFI_ACTIVE_ACCESS_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_BITRATE"
              value="bitrate"
              c:type="NM_DEVICE_WIFI_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_CAPABILITIES"
              value="wireless-capabilities"
              c:type="NM_DEVICE_WIFI_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_WIFI_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_MODE"
              value="mode"
              c:type="NM_DEVICE_WIFI_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIFI_PERMANENT_HW_ADDRESS"
              value="perm-hw-address"
              c:type="NM_DEVICE_WIFI_PERMANENT_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_ACTIVE_NSP"
              value="active-nsp"
              c:type="NM_DEVICE_WIMAX_ACTIVE_NSP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_BSID"
              value="bsid"
              c:type="NM_DEVICE_WIMAX_BSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_CENTER_FREQUENCY"
              value="center-frequency"
              c:type="NM_DEVICE_WIMAX_CENTER_FREQUENCY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_CINR"
              value="cinr"
              c:type="NM_DEVICE_WIMAX_CINR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_HW_ADDRESS"
              value="hw-address"
              c:type="NM_DEVICE_WIMAX_HW_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_RSSI"
              value="rssi"
              c:type="NM_DEVICE_WIMAX_RSSI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEVICE_WIMAX_TX_POWER"
              value="tx-power"
              c:type="NM_DEVICE_WIMAX_TX_POWER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="DHCP4Config"
           c:symbol-prefix="dhcp4_config"
           c:type="NMDHCP4Config"
           parent="Object"
           glib:type-name="NMDHCP4Config"
           glib:get-type="nm_dhcp4_config_get_type"
           glib:type-struct="DHCP4ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_dhcp4_config_new">
        <doc xml:whitespace="preserve">Creates a new #NMDHCP4Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_one_option"
              c:identifier="nm_dhcp4_config_get_one_option">
        <doc xml:whitespace="preserve">Gets one option by option name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the configuration option's value. This is the internal string used by the configuration, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDHCP4Config</doc>
            <type name="DHCP4Config" c:type="NMDHCP4Config*"/>
          </instance-parameter>
          <parameter name="option" transfer-ownership="none">
            <doc xml:whitespace="preserve">the option to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_options" c:identifier="nm_dhcp4_config_get_options">
        <doc xml:whitespace="preserve">Gets all the options contained in the configuration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GHashTable containing strings for keys and values. This is the internal copy used by the configuration, and must not be modified.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDHCP4Config</doc>
            <type name="DHCP4Config" c:type="NMDHCP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="options" introspectable="0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GHashTable containing options of the configuration.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="DHCP4ConfigClass"
            c:type="NMDHCP4ConfigClass"
            glib:is-gtype-struct-for="DHCP4Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="DHCP4_CONFIG_OPTIONS"
              value="options"
              c:type="NM_DHCP4_CONFIG_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="DHCP6Config"
           c:symbol-prefix="dhcp6_config"
           c:type="NMDHCP6Config"
           parent="Object"
           glib:type-name="NMDHCP6Config"
           glib:get-type="nm_dhcp6_config_get_type"
           glib:type-struct="DHCP6ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_dhcp6_config_new">
        <doc xml:whitespace="preserve">Creates a new #NMDHCP6Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_one_option"
              c:identifier="nm_dhcp6_config_get_one_option">
        <doc xml:whitespace="preserve">Gets one option by option name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the configuration option's value. This is the internal string used by the configuration, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDHCP6Config</doc>
            <type name="DHCP6Config" c:type="NMDHCP6Config*"/>
          </instance-parameter>
          <parameter name="option" transfer-ownership="none">
            <doc xml:whitespace="preserve">the option to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_options" c:identifier="nm_dhcp6_config_get_options">
        <doc xml:whitespace="preserve">Gets all the options contained in the configuration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GHashTable containing strings for keys and values. This is the internal copy used by the configuration, and must not be modified.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDHCP6Config</doc>
            <type name="DHCP6Config" c:type="NMDHCP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="options" introspectable="0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GHashTable containing options of the configuration.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="DHCP6ConfigClass"
            c:type="NMDHCP6ConfigClass"
            glib:is-gtype-struct-for="DHCP6Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="DHCP6_CONFIG_OPTIONS"
              value="options"
              c:type="NM_DHCP6_CONFIG_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Device"
           c:symbol-prefix="device"
           c:type="NMDevice"
           parent="Object"
           glib:type-name="NMDevice"
           glib:get-type="nm_device_get_type"
           glib:type-struct="DeviceClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_new">
        <doc xml:whitespace="preserve">Creates a new #NMDevice.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="connection_compatible"
                      invoker="connection_compatible"
                      throws="1">
        <doc xml:whitespace="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a WiFi device that supports only WEP encryption, the connection
will only be valid if it is a WiFi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.

This function does the same as nm_device_connection_valid(), i.e. checking
compatibility of the given device and connection. But, in addition, it sets
GError when FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection may be activated with this device, %FALSE if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMConnection to validate against @device</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="new_state" transfer-ownership="none">
            <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
          </parameter>
          <parameter name="old_state" transfer-ownership="none">
            <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="NetworkManager.DeviceStateReason"
                  c:type="NMDeviceStateReason"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="connection_compatible"
              c:identifier="nm_device_connection_compatible"
              throws="1">
        <doc xml:whitespace="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a WiFi device that supports only WEP encryption, the connection
will only be valid if it is a WiFi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.

This function does the same as nm_device_connection_valid(), i.e. checking
compatibility of the given device and connection. But, in addition, it sets
GError when FALSE is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection may be activated with this device, %FALSE if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMConnection to validate against @device</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connection_valid"
              c:identifier="nm_device_connection_valid">
        <doc xml:whitespace="preserve">Validates a given connection for a given #NMDevice object and returns
whether the connection may be activated with the device. For example if
@device is a WiFi device that supports only WEP encryption, the connection
will only be valid if it is a WiFi connection which describes a WEP or open
network, and will not be valid if it describes a WPA network, or if it is
an Ethernet, Bluetooth, WWAN, etc connection that is incompatible with the
device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection may be activated with this device, %FALSE if is incompatible with the device's capabilities and characteristics.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMDevice to validate @connection against</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMConnection to validate against @device</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="nm_device_disconnect">
        <doc xml:whitespace="preserve">Disconnects the device if currently connected, and prevents the device from
automatically connecting to networks until the next manual network connection
request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">callback to be called when disconnect operation completes</doc>
            <type name="DeviceDeactivateFn" c:type="NMDeviceDeactivateFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_device_filter_connections">
        <doc xml:whitespace="preserve">Filters a given list of connections for a given #NMDevice object and return
connections which may be activated with the device. For example if @device
is a WiFi device that supports only WEP encryption, the returned list will
contain any WiFi connections in @connections that allow connection to
unencrypted or WEP-enabled SSIDs.  The returned list will not contain
Ethernet, Bluetooth, WiFi WPA connections, or any other connection that is
incompatible with the device. To get the full list of connections see
nm_remote_settings_list_connections().</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a list of #NMConnection objects that could be activated with the given @device. The elements of the list are owned by their creator and should not be freed by the caller, but the returned list itself is owned by the caller and should be freed with g_slist_free() when it is no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="NetworkManager.Connection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMDevice to filter connections for</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:whitespace="preserve">a list of #NMConnection objects to filter</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="NetworkManager.Connection"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_active_connection"
              c:identifier="nm_device_get_active_connection">
        <doc xml:whitespace="preserve">Gets the #NMActiveConnection object which owns this device during activation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMActiveConnection or %NULL if the device is not part of an active connection</doc>
          <type name="ActiveConnection" c:type="NMActiveConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_autoconnect" c:identifier="nm_device_get_autoconnect">
        <doc xml:whitespace="preserve">Whether the #NMDevice can be autoconnected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device is allowed to be autoconnected</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_available_connections"
              c:identifier="nm_device_get_available_connections">
        <doc xml:whitespace="preserve">Gets the #NMRemoteConnections currently known to the daemon that could
be activated on @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GPtrArray containing #NMRemoteConnections. This is the internal copy used by the connection, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="RemoteConnection"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="nm_device_get_capabilities">
        <doc xml:whitespace="preserve">Gets the device' capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the capabilities</doc>
          <type name="NetworkManager.DeviceCapabilities"
                c:type="NMDeviceCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_device_type" c:identifier="nm_device_get_device_type">
        <doc xml:whitespace="preserve">Returns the numeric type of the #NMDevice, ie ethernet, wifi, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the device type</doc>
          <type name="NetworkManager.DeviceType" c:type="NMDeviceType"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp4_config"
              c:identifier="nm_device_get_dhcp4_config">
        <doc xml:whitespace="preserve">Gets the current #NMDHCP4Config associated with the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMDHCP4Config or %NULL if the device is not activated or not using DHCP.</doc>
          <type name="DHCP4Config" c:type="NMDHCP4Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp6_config"
              c:identifier="nm_device_get_dhcp6_config">
        <doc xml:whitespace="preserve">Gets the current #NMDHCP6Config associated with the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMDHCP6Config or %NULL if the device is not activated or not using DHCP.</doc>
          <type name="DHCP6Config" c:type="NMDHCP6Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_driver" c:identifier="nm_device_get_driver">
        <doc xml:whitespace="preserve">Gets the driver of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the driver of the device. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_driver_version"
              c:identifier="nm_device_get_driver_version">
        <doc xml:whitespace="preserve">Gets the driver version of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the version of the device driver. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_firmware_missing"
              c:identifier="nm_device_get_firmware_missing">
        <doc xml:whitespace="preserve">Indicates that firmware required for the device's operation is likely
to be missing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if firmware required for the device's operation is likely to be missing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_firmware_version"
              c:identifier="nm_device_get_firmware_version">
        <doc xml:whitespace="preserve">Gets the firmware version of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the firmware version of the device. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_iface" c:identifier="nm_device_get_iface">
        <doc xml:whitespace="preserve">Gets the interface name of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface of the device. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip4_config" c:identifier="nm_device_get_ip4_config">
        <doc xml:whitespace="preserve">Gets the current #NMIP4Config associated with the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMIP4Config or %NULL if the device is not activated.</doc>
          <type name="IP4Config" c:type="NMIP4Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip6_config" c:identifier="nm_device_get_ip6_config">
        <doc xml:whitespace="preserve">Gets the current #NMIP6Config associated with the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #NMIP6Config or %NULL if the device is not activated.</doc>
          <type name="IP6Config" c:type="NMIP6Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip_iface" c:identifier="nm_device_get_ip_iface">
        <doc xml:whitespace="preserve">Gets the IP interface name of the #NMDevice over which IP traffic flows
when the device is in the ACTIVATED state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the IP traffic interface of the device. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_managed" c:identifier="nm_device_get_managed">
        <doc xml:whitespace="preserve">Whether the #NMDevice is managed by NetworkManager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device is managed by NetworkManager</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_product" c:identifier="nm_device_get_product">
        <doc xml:whitespace="preserve">Gets the product string of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the product name of the device. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="nm_device_get_state">
        <doc xml:whitespace="preserve">Gets the current #NMDevice state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current device state</doc>
          <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state_reason"
              c:identifier="nm_device_get_state_reason">
        <doc xml:whitespace="preserve">Gets the current #NMDevice state (return value) and the reason for entering
the state (@reason argument).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current device state</doc>
          <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location to store reason (#NMDeviceStateReason), or NULL</doc>
            <type name="NetworkManager.DeviceStateReason"
                  c:type="NMDeviceStateReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_udi" c:identifier="nm_device_get_udi">
        <doc xml:whitespace="preserve">Gets the Unique Device Identifier of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the Unique Device Identifier of the device.  This identifier may be used to gather more information about the device from various operating system services like udev or sysfs.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vendor" c:identifier="nm_device_get_vendor">
        <doc xml:whitespace="preserve">Gets the vendor string of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the vendor name of the device. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_autoconnect" c:identifier="nm_device_set_autoconnect">
        <doc xml:whitespace="preserve">Enables or disables automatic activation of the #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDevice</doc>
            <type name="Device" c:type="NMDevice*"/>
          </instance-parameter>
          <parameter name="autoconnect" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to enable autoconnecting</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="active-connection" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #NMActiveConnection object that "owns" this device during activation.</doc>
        <type name="ActiveConnection"/>
      </property>
      <property name="autoconnect" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device can auto-activate a connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="available-connections" transfer-ownership="none">
        <doc xml:whitespace="preserve">The available connections (#NMRemoteConnection) of the device</doc>
        <type name="ObjectArray"/>
      </property>
      <property name="capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The capabilities of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="device-type" transfer-ownership="none">
        <doc xml:whitespace="preserve">The numeric type of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="dhcp4-config" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #NMDHCP4Config of the device.</doc>
        <type name="DHCP4Config"/>
      </property>
      <property name="dhcp6-config" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #NMDHCP6Config of the device.</doc>
        <type name="DHCP6Config"/>
      </property>
      <property name="driver" transfer-ownership="none">
        <doc xml:whitespace="preserve">The driver of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="driver-version" transfer-ownership="none">
        <doc xml:whitespace="preserve">The version of the device driver.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="firmware-missing" transfer-ownership="none">
        <doc xml:whitespace="preserve">When %TRUE indicates the device is likely missing firmware required
for its operation.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="firmware-version" transfer-ownership="none">
        <doc xml:whitespace="preserve">The firmware version of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="interface" transfer-ownership="none">
        <doc xml:whitespace="preserve">The interface of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip-interface" transfer-ownership="none">
        <doc xml:whitespace="preserve">The IP interface of the device which should be used for all IP-related
operations like addressing and routing.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ip4-config" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #NMIP4Config of the device.</doc>
        <type name="IP4Config"/>
      </property>
      <property name="ip6-config" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #NMIP6Config of the device.</doc>
        <type name="IP6Config"/>
      </property>
      <property name="managed" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device is managed by NetworkManager.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="product" transfer-ownership="none">
        <doc xml:whitespace="preserve">The product string of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:whitespace="preserve">The state of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="state-reason"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The state and reason of the device.</doc>
        <type/>
      </property>
      <property name="udi" transfer-ownership="none">
        <doc xml:whitespace="preserve">An operating-system specific device hardware identifier; this is not
unique to a specific hardware device across reboots or hotplugs.  It
is an opaque string which for some device types (Bluetooth, Modem)
contains an identifier provided by the underlying hardware service daemon
such as Bluez or ModemManager, and clients can use this property to
request more information about the device from those services.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vendor" transfer-ownership="none">
        <doc xml:whitespace="preserve">The vendor string of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
      <glib:signal name="state-changed" when="first">
        <doc xml:whitespace="preserve">Notifies the state change of a #NMDevice.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="new_state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new state of the device</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="old_state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the previous state of the device</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the reason describing the state change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="DeviceAdsl"
           c:symbol-prefix="device_adsl"
           c:type="NMDeviceAdsl"
           parent="Device"
           glib:type-name="NMDeviceAdsl"
           glib:get-type="nm_device_adsl_get_type"
           glib:type-struct="DeviceAdslClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_adsl_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceAdsl.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_adsl_get_carrier">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceAdsl</doc>
            <type name="DeviceAdsl" c:type="NMDeviceAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceAdslClass"
            c:type="NMDeviceAdslClass"
            glib:is-gtype-struct-for="DeviceAdsl">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceAdslError"
                 glib:type-name="NMDeviceAdslError"
                 glib:get-type="nm_device_adsl_error_get_type"
                 c:type="NMDeviceAdslError"
                 glib:error-domain="nm-device-adsl-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_ADSL_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotAdslConnection"
              value="1"
              c:identifier="NM_DEVICE_ADSL_ERROR_NOT_ADSL_CONNECTION"
              glib:nick="NotAdslConnection">
        <doc xml:whitespace="preserve">the connection was not of ADSL type</doc>
      </member>
      <member name="InvalidAdslConnection"
              value="2"
              c:identifier="NM_DEVICE_ADSL_ERROR_INVALID_ADSL_CONNECTION"
              glib:nick="InvalidAdslConnection">
        <doc xml:whitespace="preserve">the ADSL connection was invalid</doc>
      </member>
      <function name="quark" c:identifier="nm_device_adsl_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceAdsl if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceAdsl errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceBond"
           c:symbol-prefix="device_bond"
           c:type="NMDeviceBond"
           parent="Device"
           glib:type-name="NMDeviceBond"
           glib:get-type="nm_device_bond_get_type"
           glib:type-struct="DeviceBondClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_bond_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceBond.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_bond_get_carrier">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_bond_get_hw_address">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the #NMDeviceBond</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves"
              c:identifier="nm_device_bond_get_slaves"
              version="0.9.6.4">
        <doc xml:whitespace="preserve">Gets the devices currently slaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GPtrArray containing #NMDevice&lt;!-- --&gt;s that are slaves of @device. This is the internal copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBond</doc>
            <type name="DeviceBond" c:type="NMDeviceBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" transfer-ownership="none">
        <doc xml:whitespace="preserve">The devices (#NMDevice) slaved to the bond device.</doc>
        <type name="ObjectArray"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBondClass"
            c:type="NMDeviceBondClass"
            glib:is-gtype-struct-for="DeviceBond">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceBondError"
                 glib:type-name="NMDeviceBondError"
                 glib:get-type="nm_device_bond_error_get_type"
                 c:type="NMDeviceBondError"
                 glib:error-domain="nm-device-bond-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_BOND_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotBondConnection"
              value="1"
              c:identifier="NM_DEVICE_BOND_ERROR_NOT_BOND_CONNECTION"
              glib:nick="NotBondConnection">
        <doc xml:whitespace="preserve">the connection was not of bond type</doc>
      </member>
      <member name="InvalidBondConnection"
              value="2"
              c:identifier="NM_DEVICE_BOND_ERROR_INVALID_BOND_CONNECTION"
              glib:nick="InvalidBondConnection">
        <doc xml:whitespace="preserve">the bond connection was invalid</doc>
      </member>
      <member name="InterfaceMismatch"
              value="3"
              c:identifier="NM_DEVICE_BOND_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:whitespace="preserve">the interfaces of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_bond_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceBond if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceBond errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceBridge"
           c:symbol-prefix="device_bridge"
           c:type="NMDeviceBridge"
           parent="Device"
           glib:type-name="NMDeviceBridge"
           glib:get-type="nm_device_bridge_get_type"
           glib:type-struct="DeviceBridgeClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_bridge_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceBridge.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_bridge_get_carrier">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_bridge_get_hw_address">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the #NMDeviceBridge</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slaves" c:identifier="nm_device_bridge_get_slaves">
        <doc xml:whitespace="preserve">Gets the devices currently slaved to @device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GPtrArray containing #NMDevice&lt;!-- --&gt;s that are slaves of @device. This is the internal copy used by the device, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="Device"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBridge</doc>
            <type name="DeviceBridge" c:type="NMDeviceBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="slaves" transfer-ownership="none">
        <doc xml:whitespace="preserve">The devices (#NMDevice) slaved to the bridge device.</doc>
        <type name="ObjectArray"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBridgeClass"
            c:type="NMDeviceBridgeClass"
            glib:is-gtype-struct-for="DeviceBridge">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceBridgeError"
                 glib:type-name="NMDeviceBridgeError"
                 glib:get-type="nm_device_bridge_error_get_type"
                 c:type="NMDeviceBridgeError"
                 glib:error-domain="nm-device-bridge-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotBridgeConnection"
              value="1"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_NOT_BRIDGE_CONNECTION"
              glib:nick="NotBridgeConnection">
        <doc xml:whitespace="preserve">the connection was not of bridge type</doc>
      </member>
      <member name="InvalidBridgeConnection"
              value="2"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_INVALID_BRIDGE_CONNECTION"
              glib:nick="InvalidBridgeConnection">
        <doc xml:whitespace="preserve">the bridge connection was invalid</doc>
      </member>
      <member name="InterfaceMismatch"
              value="3"
              c:identifier="NM_DEVICE_BRIDGE_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:whitespace="preserve">the interfaces of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_bridge_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceBridge if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceBridge errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceBt"
           c:symbol-prefix="device_bt"
           c:type="NMDeviceBt"
           parent="Device"
           glib:type-name="NMDeviceBt"
           glib:get-type="nm_device_bt_get_type"
           glib:type-struct="DeviceBtClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_bt_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceBt.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_capabilities"
              c:identifier="nm_device_bt_get_capabilities">
        <doc xml:whitespace="preserve">Returns the Bluetooth device's usable capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a combination of #NMBluetoothCapabilities</doc>
          <type name="NetworkManager.BluetoothCapabilities"
                c:type="NMBluetoothCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address" c:identifier="nm_device_bt_get_hw_address">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the #NMDeviceBt</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_device_bt_get_name">
        <doc xml:whitespace="preserve">Gets the name of the #NMDeviceBt.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the device</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceBt</doc>
            <type name="DeviceBt" c:type="NMDeviceBt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bt-capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The device's bluetooth capabilities, a combination of #NMBluetoothCapabilities.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="name" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the bluetooth device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceBtClass"
            c:type="NMDeviceBtClass"
            glib:is-gtype-struct-for="DeviceBt">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceBtError"
                 glib:type-name="NMDeviceBtError"
                 glib:get-type="nm_device_bt_error_get_type"
                 c:type="NMDeviceBtError"
                 glib:error-domain="nm-device-bt-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_BT_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotBtConnection"
              value="1"
              c:identifier="NM_DEVICE_BT_ERROR_NOT_BT_CONNECTION"
              glib:nick="NotBtConnection">
        <doc xml:whitespace="preserve">the connection was not of bluetooth type</doc>
      </member>
      <member name="InvalidBtConnection"
              value="2"
              c:identifier="NM_DEVICE_BT_ERROR_INVALID_BT_CONNECTION"
              glib:nick="InvalidBtConnection">
        <doc xml:whitespace="preserve">the bluetooth connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_BT_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:whitespace="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_BT_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:whitespace="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <member name="MissingDeviceCaps"
              value="5"
              c:identifier="NM_DEVICE_BT_ERROR_MISSING_DEVICE_CAPS"
              glib:nick="MissingDeviceCaps">
        <doc xml:whitespace="preserve">the device missed required capabilities</doc>
      </member>
      <function name="quark" c:identifier="nm_device_bt_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceBt if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceBt errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="DeviceClass"
            c:type="NMDeviceClass"
            glib:is-gtype-struct-for="Device">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="state_changed">
        <callback name="state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
            <parameter name="new_state" transfer-ownership="none">
              <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
            </parameter>
            <parameter name="old_state" transfer-ownership="none">
              <type name="NetworkManager.DeviceState" c:type="NMDeviceState"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="NetworkManager.DeviceStateReason"
                    c:type="NMDeviceStateReason"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connection_compatible">
        <callback name="connection_compatible" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the connection may be activated with this device, %FALSE if is incompatible with the device's capabilities and characteristics.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="Device" c:type="NMDevice*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:whitespace="preserve">an #NMConnection to validate against @device</doc>
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="DeviceDeactivateFn" c:type="NMDeviceDeactivateFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <type name="Device" c:type="NMDevice*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DeviceEthernet"
           c:symbol-prefix="device_ethernet"
           c:type="NMDeviceEthernet"
           parent="Device"
           glib:type-name="NMDeviceEthernet"
           glib:get-type="nm_device_ethernet_get_type"
           glib:type-struct="DeviceEthernetClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_ethernet_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceEthernet.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_ethernet_get_carrier">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_ethernet_get_hw_address">
        <doc xml:whitespace="preserve">Gets the active hardware (MAC) address of the #NMDeviceEthernet</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the active hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permanent_hw_address"
              c:identifier="nm_device_ethernet_get_permanent_hw_address">
        <doc xml:whitespace="preserve">Gets the permanent hardware (MAC) address of the #NMDeviceEthernet</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the permanent hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_speed" c:identifier="nm_device_ethernet_get_speed">
        <doc xml:whitespace="preserve">Gets the speed of the #NMDeviceEthernet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the speed of the device</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceEthernet</doc>
            <type name="DeviceEthernet" c:type="NMDeviceEthernet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The active hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="perm-hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The permanent hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="speed" transfer-ownership="none">
        <doc xml:whitespace="preserve">The speed of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceEthernetClass"
            c:type="NMDeviceEthernetClass"
            glib:is-gtype-struct-for="DeviceEthernet">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceEthernetError"
                 glib:type-name="NMDeviceEthernetError"
                 glib:get-type="nm_device_ethernet_error_get_type"
                 c:type="NMDeviceEthernetError"
                 glib:error-domain="nm-device-ethernet-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotEthernetConnection"
              value="1"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_NOT_ETHERNET_CONNECTION"
              glib:nick="NotEthernetConnection">
        <doc xml:whitespace="preserve">the connection was not of ethernet or PPPoE type</doc>
      </member>
      <member name="InvalidEthernetConnection"
              value="2"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_INVALID_ETHERNET_CONNECTION"
              glib:nick="InvalidEthernetConnection">
        <doc xml:whitespace="preserve">the ethernet connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:whitespace="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_ETHERNET_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:whitespace="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_ethernet_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceEthernet if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceEthernet errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceInfiniband"
           c:symbol-prefix="device_infiniband"
           c:type="NMDeviceInfiniband"
           parent="Device"
           glib:type-name="NMDeviceInfiniband"
           glib:get-type="nm_device_infiniband_get_type"
           glib:type-struct="DeviceInfinibandClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_infiniband_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceInfiniband.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier"
              c:identifier="nm_device_infiniband_get_carrier">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceInfiniband</doc>
            <type name="DeviceInfiniband" c:type="NMDeviceInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_infiniband_get_hw_address">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the #NMDeviceInfiniband</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceInfiniband</doc>
            <type name="DeviceInfiniband" c:type="NMDeviceInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceInfinibandClass"
            c:type="NMDeviceInfinibandClass"
            glib:is-gtype-struct-for="DeviceInfiniband">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceInfinibandError"
                 glib:type-name="NMDeviceInfinibandError"
                 glib:get-type="nm_device_infiniband_error_get_type"
                 c:type="NMDeviceInfinibandError"
                 glib:error-domain="nm-device-infiniband-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotInfinibandConnection"
              value="1"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_NOT_INFINIBAND_CONNECTION"
              glib:nick="NotInfinibandConnection">
        <doc xml:whitespace="preserve">the connection was not of InfiniBand type</doc>
      </member>
      <member name="InvalidInfinibandConnection"
              value="2"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_INVALID_INFINIBAND_CONNECTION"
              glib:nick="InvalidInfinibandConnection">
        <doc xml:whitespace="preserve">the InfiniBand connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:whitespace="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_INFINIBAND_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:whitespace="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_infiniband_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceInfiniband if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceInfiniband errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceModem"
           c:symbol-prefix="device_modem"
           c:type="NMDeviceModem"
           parent="Device"
           glib:type-name="NMDeviceModem"
           glib:get-type="nm_device_modem_get_type"
           glib:type-struct="DeviceModemClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <method name="get_current_capabilities"
              c:identifier="nm_device_modem_get_current_capabilities">
        <doc xml:whitespace="preserve">Returns a bitfield of the generic access technology families the modem
supports without a firmware reload or reinitialization.  This value
represents the network types the modem can immediately connect to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the generic access technology families the modem supports without a firmware reload or other reinitialization</doc>
          <type name="NetworkManager.DeviceModemCapabilities"
                c:type="NMDeviceModemCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceModem</doc>
            <type name="DeviceModem" c:type="NMDeviceModem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modem_capabilities"
              c:identifier="nm_device_modem_get_modem_capabilities">
        <doc xml:whitespace="preserve">Returns a bitfield of the generic access technology families the modem
supports.  Not all capabilities are available concurrently however; some
may require a firmware reload or reinitialization.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the generic access technology families the modem supports</doc>
          <type name="NetworkManager.DeviceModemCapabilities"
                c:type="NMDeviceModemCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceModem</doc>
            <type name="DeviceModem" c:type="NMDeviceModem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="current-capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The generic family of access technologies the modem currently supports
without a firmware reload or reinitialization.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="modem-capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The generic family of access technologies the modem supports.  Not all
capabilities are available at the same time however; some modems require
a firmware reload or other reinitialization to switch between eg
CDMA/EVDO and GSM/UMTS.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceModemClass"
            c:type="NMDeviceModemClass"
            glib:is-gtype-struct-for="DeviceModem">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceModemError"
                 glib:type-name="NMDeviceModemError"
                 glib:get-type="nm_device_modem_error_get_type"
                 c:type="NMDeviceModemError"
                 glib:error-domain="nm-device-modem-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_MODEM_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotModemConnection"
              value="1"
              c:identifier="NM_DEVICE_MODEM_ERROR_NOT_MODEM_CONNECTION"
              glib:nick="NotModemConnection">
        <doc xml:whitespace="preserve">the connection was not of modem type</doc>
      </member>
      <member name="InvalidModemConnection"
              value="2"
              c:identifier="NM_DEVICE_MODEM_ERROR_INVALID_MODEM_CONNECTION"
              glib:nick="InvalidModemConnection">
        <doc xml:whitespace="preserve">the modem connection was invalid</doc>
      </member>
      <member name="MissingDeviceCaps"
              value="3"
              c:identifier="NM_DEVICE_MODEM_ERROR_MISSING_DEVICE_CAPS"
              glib:nick="MissingDeviceCaps">
        <doc xml:whitespace="preserve">the device missed required capabilities</doc>
      </member>
      <function name="quark" c:identifier="nm_device_modem_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceModem if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceModem errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceOlpcMesh"
           c:symbol-prefix="device_olpc_mesh"
           c:type="NMDeviceOlpcMesh"
           parent="Device"
           glib:type-name="NMDeviceOlpcMesh"
           glib:get-type="nm_device_olpc_mesh_get_type"
           glib:type-struct="DeviceOlpcMeshClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_olpc_mesh_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceOlpcMesh.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new OlpcMesh device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_active_channel"
              c:identifier="nm_device_olpc_mesh_get_active_channel">
        <doc xml:whitespace="preserve">Returns the active channel of the #NMDeviceOlpcMesh device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">active channel of the device</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_companion"
              c:identifier="nm_device_olpc_mesh_get_companion">
        <doc xml:whitespace="preserve">Gets the companion device of the #NMDeviceOlpcMesh.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the companion of the device of %NULL</doc>
          <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_olpc_mesh_get_hw_address">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the #NMDeviceOlpcMesh</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceOlpcMesh</doc>
            <type name="DeviceOlpcMesh" c:type="NMDeviceOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active-channel" transfer-ownership="none">
        <doc xml:whitespace="preserve">The device's active channel.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="companion" transfer-ownership="none">
        <doc xml:whitespace="preserve">The companion device.</doc>
        <type name="DeviceWifi"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceOlpcMeshClass"
            c:type="NMDeviceOlpcMeshClass"
            glib:is-gtype-struct-for="DeviceOlpcMesh">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceOlpcMeshError"
                 glib:type-name="NMDeviceOlpcMeshError"
                 glib:get-type="nm_device_olpc_mesh_error_get_type"
                 c:type="NMDeviceOlpcMeshError"
                 glib:error-domain="nm-device-olpc-mesh-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_OLPC_MESH_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotOlpcMeshConnection"
              value="1"
              c:identifier="NM_DEVICE_OLPC_MESH_ERROR_NOT_OLPC_MESH_CONNECTION"
              glib:nick="NotOlpcMeshConnection">
        <doc xml:whitespace="preserve">the connection was not of Olpc Mesh type</doc>
      </member>
      <member name="InvalidOlpcMeshConnection"
              value="2"
              c:identifier="NM_DEVICE_OLPC_MESH_ERROR_INVALID_OLPC_MESH_CONNECTION"
              glib:nick="InvalidOlpcMeshConnection">
        <doc xml:whitespace="preserve">the Olpc Mesh connection was invalid</doc>
      </member>
      <function name="quark" c:identifier="nm_device_olpc_mesh_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceOlpcMesh if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceOlpcMesh errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceVlan"
           c:symbol-prefix="device_vlan"
           c:type="NMDeviceVlan"
           parent="Device"
           glib:type-name="NMDeviceVlan"
           glib:get-type="nm_device_vlan_get_type"
           glib:type-struct="DeviceVlanClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_vlan_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceVlan.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_carrier" c:identifier="nm_device_vlan_get_carrier">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the device has carrier</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_vlan_get_hw_address">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the #NMDeviceVlan</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vlan_id" c:identifier="nm_device_vlan_get_vlan_id">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the device's VLAN ID</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceVlan</doc>
            <type name="DeviceVlan" c:type="NMDeviceVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="carrier" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the device has carrier.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vlan-id" transfer-ownership="none">
        <doc xml:whitespace="preserve">The device's VLAN ID.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
    </class>
    <record name="DeviceVlanClass"
            c:type="NMDeviceVlanClass"
            glib:is-gtype-struct-for="DeviceVlan">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceVlanError"
                 glib:type-name="NMDeviceVlanError"
                 glib:get-type="nm_device_vlan_error_get_type"
                 c:type="NMDeviceVlanError"
                 glib:error-domain="nm-device-vlan-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_VLAN_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotVlanConnection"
              value="1"
              c:identifier="NM_DEVICE_VLAN_ERROR_NOT_VLAN_CONNECTION"
              glib:nick="NotVlanConnection">
        <doc xml:whitespace="preserve">the connection was not of VLAN type</doc>
      </member>
      <member name="InvalidVlanConnection"
              value="2"
              c:identifier="NM_DEVICE_VLAN_ERROR_INVALID_VLAN_CONNECTION"
              glib:nick="InvalidVlanConnection">
        <doc xml:whitespace="preserve">the VLAN connection was invalid</doc>
      </member>
      <member name="IdMismatch"
              value="3"
              c:identifier="NM_DEVICE_VLAN_ERROR_ID_MISMATCH"
              glib:nick="IdMismatch">
        <doc xml:whitespace="preserve">the VLAN identifiers of the connection and the device mismatched</doc>
      </member>
      <member name="InterfaceMismatch"
              value="4"
              c:identifier="NM_DEVICE_VLAN_ERROR_INTERFACE_MISMATCH"
              glib:nick="InterfaceMismatch">
        <doc xml:whitespace="preserve">the interfaces of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_vlan_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceVlan if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceVlan errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="DeviceWifi"
           c:symbol-prefix="device_wifi"
           c:type="NMDeviceWifi"
           parent="Device"
           glib:type-name="NMDeviceWifi"
           glib:get-type="nm_device_wifi_get_type"
           glib:type-struct="DeviceWifiClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_wifi_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceWifi.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new WiFi device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="access_point_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="access_point_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="ap" transfer-ownership="none">
            <type name="AccessPoint" c:type="NMAccessPoint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_access_point_by_path"
              c:identifier="nm_device_wifi_get_access_point_by_path">
        <doc xml:whitespace="preserve">Gets a #NMAccessPoint by path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the access point or %NULL if none is found.</doc>
          <type name="AccessPoint" c:type="NMAccessPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the access point</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_access_points"
              c:identifier="nm_device_wifi_get_access_points">
        <doc xml:whitespace="preserve">Gets all the scanned access points of the #NMDeviceWifi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray containing all the scanned #NMAccessPoint&lt;!-- --&gt;s. The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="AccessPoint"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_active_access_point"
              c:identifier="nm_device_wifi_get_active_access_point">
        <doc xml:whitespace="preserve">Gets the active #NMAccessPoint.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the access point or %NULL if none is active</doc>
          <type name="AccessPoint" c:type="NMAccessPoint*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bitrate" c:identifier="nm_device_wifi_get_bitrate">
        <doc xml:whitespace="preserve">Gets the bit rate of the #NMDeviceWifi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bit rate</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_capabilities"
              c:identifier="nm_device_wifi_get_capabilities">
        <doc xml:whitespace="preserve">Gets the WIFI capabilities of the #NMDeviceWifi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the capabilities</doc>
          <type name="NetworkManager.DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_wifi_get_hw_address">
        <doc xml:whitespace="preserve">Gets the actual hardware (MAC) address of the #NMDeviceWifi</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the actual hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_device_wifi_get_mode">
        <doc xml:whitespace="preserve">Gets the #NMDeviceWifi mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the mode</doc>
          <type name="NetworkManager.80211Mode" c:type="NM80211Mode"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permanent_hw_address"
              c:identifier="nm_device_wifi_get_permanent_hw_address">
        <doc xml:whitespace="preserve">Gets the permanent hardware (MAC) address of the #NMDeviceWifi</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the permanent hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="request_scan_simple"
              c:identifier="nm_device_wifi_request_scan_simple">
        <doc xml:whitespace="preserve">Request NM to scan for access points on the #NMDeviceWifi. This function only
instructs NM to perform scanning. Use nm_device_wifi_get_access_points()
to get available access points.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="device" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWifi</doc>
            <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">the function to call when the call is done</doc>
            <type name="DeviceWifiRequestScanFn"
                  c:type="NMDeviceWifiRequestScanFn"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="active-access-point" transfer-ownership="none">
        <doc xml:whitespace="preserve">The active #NMAccessPoint of the device.</doc>
        <type name="AccessPoint"/>
      </property>
      <property name="bitrate" transfer-ownership="none">
        <doc xml:whitespace="preserve">The bit rate of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" transfer-ownership="none">
        <doc xml:whitespace="preserve">The mode of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="perm-hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wireless-capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The wireless capabilities of the device.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
      <glib:signal name="access-point-added" when="first">
        <doc xml:whitespace="preserve">Notifies that a #NMAccessPoint is added to the wifi device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new access point</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="access-point-removed" when="first">
        <doc xml:whitespace="preserve">Notifies that a #NMAccessPoint is removed from the wifi device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ap" transfer-ownership="none">
            <doc xml:whitespace="preserve">the removed access point</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DeviceWifiClass"
            c:type="NMDeviceWifiClass"
            glib:is-gtype-struct-for="DeviceWifi">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="access_point_added">
        <callback name="access_point_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
            </parameter>
            <parameter name="ap" transfer-ownership="none">
              <type name="AccessPoint" c:type="NMAccessPoint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="access_point_removed">
        <callback name="access_point_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="device" transfer-ownership="none">
              <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
            </parameter>
            <parameter name="ap" transfer-ownership="none">
              <type name="AccessPoint" c:type="NMAccessPoint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceWifiError"
                 glib:type-name="NMDeviceWifiError"
                 glib:get-type="nm_device_wifi_error_get_type"
                 c:type="NMDeviceWifiError"
                 glib:error-domain="nm-device-wifi-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_WIFI_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotWifiConnection"
              value="1"
              c:identifier="NM_DEVICE_WIFI_ERROR_NOT_WIFI_CONNECTION"
              glib:nick="NotWifiConnection">
        <doc xml:whitespace="preserve">the connection was not of Wi-Fi type</doc>
      </member>
      <member name="InvalidWifiConnection"
              value="2"
              c:identifier="NM_DEVICE_WIFI_ERROR_INVALID_WIFI_CONNECTION"
              glib:nick="InvalidWifiConnection">
        <doc xml:whitespace="preserve">the Wi-Fi connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_WIFI_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:whitespace="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_WIFI_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:whitespace="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <member name="MissingDeviceWpaCaps"
              value="5"
              c:identifier="NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_WPA_CAPS"
              glib:nick="MissingDeviceWpaCaps">
        <doc xml:whitespace="preserve">the device missed WPA capabilities required by the connection</doc>
      </member>
      <member name="MissingDeviceRsnCaps"
              value="6"
              c:identifier="NM_DEVICE_WIFI_ERROR_MISSING_DEVICE_RSN_CAPS"
              glib:nick="MissingDeviceRsnCaps">
        <doc xml:whitespace="preserve">the device missed RSN capabilities required by the connection</doc>
      </member>
      <function name="quark" c:identifier="nm_device_wifi_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceWifi if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceWifi errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <callback name="DeviceWifiRequestScanFn"
              c:type="NMDeviceWifiRequestScanFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <type name="DeviceWifi" c:type="NMDeviceWifi*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DeviceWimax"
           c:symbol-prefix="device_wimax"
           c:type="NMDeviceWimax"
           parent="Device"
           glib:type-name="NMDeviceWimax"
           glib:get-type="nm_device_wimax_get_type"
           glib:type-struct="DeviceWimaxClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_device_wimax_new">
        <doc xml:whitespace="preserve">Creates a new #NMDeviceWimax.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new WiMAX device</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus object path of the WiMAX device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="nsp_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="nsp" transfer-ownership="none">
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="nsp_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="nsp" transfer-ownership="none">
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_active_nsp"
              c:identifier="nm_device_wimax_get_active_nsp">
        <doc xml:whitespace="preserve">Gets the active #NMWimaxNsp.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the access point or %NULL if none is active</doc>
          <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bsid" c:identifier="nm_device_wimax_get_bsid">
        <doc xml:whitespace="preserve">Gets the ID of the serving Base Station when the device is connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the ID of the serving Base Station, or NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_center_frequency"
              c:identifier="nm_device_wimax_get_center_frequency">
        <doc xml:whitespace="preserve">Gets the center frequency (in KHz) of the radio channel the device is using
to communicate with the network when connected.  Has no meaning when the
device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the center frequency in KHz, or 0</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cinr" c:identifier="nm_device_wimax_get_cinr">
        <doc xml:whitespace="preserve">Gets the CINR (Carrier to Interference + Noise Ratio) of the current radio
link in dB.  CINR is a more accurate measure of radio link quality.  Has no
meaning when the device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the CINR in dB, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hw_address"
              c:identifier="nm_device_wimax_get_hw_address">
        <doc xml:whitespace="preserve">Gets the hardware (MAC) address of the #NMDeviceWimax</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hardware address. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nsp_by_path"
              c:identifier="nm_device_wimax_get_nsp_by_path">
        <doc xml:whitespace="preserve">Gets a #NMWimaxNsp by path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the access point or %NULL if none is found.</doc>
          <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the NSP</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_nsps" c:identifier="nm_device_wimax_get_nsps">
        <doc xml:whitespace="preserve">Gets all the scanned NSPs of the #NMDeviceWimax.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray containing all the scanned #NMWimaxNsp&lt;!-- --&gt;s. The returned array is owned by the client and should not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="WimaxNsp"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="wimax" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rssi" c:identifier="nm_device_wimax_get_rssi">
        <doc xml:whitespace="preserve">Gets the RSSI of the current radio link in dBm.  This value indicates how
strong the raw received RF signal from the base station is, but does not
indicate the overall quality of the radio link.  Has no meaning when the
device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the RSSI in dBm, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tx_power" c:identifier="nm_device_wimax_get_tx_power">
        <doc xml:whitespace="preserve">Average power of the last burst transmitted by the device, in units of
0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
-5.5 dBm.  Has no meaning when the device is not connected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the TX power in dBm, or 0</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMDeviceWimax</doc>
            <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="active-nsp" transfer-ownership="none">
        <doc xml:whitespace="preserve">The active #NMWimaxNsp of the device.</doc>
        <type name="WimaxNsp"/>
      </property>
      <property name="bsid" transfer-ownership="none">
        <doc xml:whitespace="preserve">The ID of the serving base station as received from the network.  Has
no meaning when the device is not connected.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="center-frequency" transfer-ownership="none">
        <doc xml:whitespace="preserve">The center frequency (in KHz) of the radio channel the device is using to
communicate with the network when connected.  Has no meaning when the
device is not connected.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="cinr" transfer-ownership="none">
        <doc xml:whitespace="preserve">CINR (Carrier to Interference + Noise Ratio) of the current radio link
in dB.  CINR is a more accurate measure of radio link quality.  Has no
meaning when the device is not connected.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="hw-address" transfer-ownership="none">
        <doc xml:whitespace="preserve">The hardware (MAC) address of the device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="rssi" transfer-ownership="none">
        <doc xml:whitespace="preserve">RSSI of the current radio link in dBm.  This value indicates how strong
the raw received RF signal from the base station is, but does not
indicate the overall quality of the radio link.  Has no meaning when the
device is not connected.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tx-power" transfer-ownership="none">
        <doc xml:whitespace="preserve">Average power of the last burst transmitted by the device, in units of
0.5 dBm.  i.e. a TxPower of -11 represents an actual device TX power of
-5.5 dBm.  Has no meaning when the device is not connected.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent">
        <type name="Device" c:type="NMDevice"/>
      </field>
      <glib:signal name="nsp-added" when="first">
        <doc xml:whitespace="preserve">Notifies that a #NMWimaxNsp is added to the wimax device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nsp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new NSP</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="nsp-removed" when="first">
        <doc xml:whitespace="preserve">Notifies that a #NMWimaxNsp is removed from the wimax device.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nsp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the removed NSP</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="DeviceWimaxClass"
            c:type="NMDeviceWimaxClass"
            glib:is-gtype-struct-for="DeviceWimax">
      <field name="parent">
        <type name="DeviceClass" c:type="NMDeviceClass"/>
      </field>
      <field name="nsp_added">
        <callback name="nsp_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
            </parameter>
            <parameter name="nsp" transfer-ownership="none">
              <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="nsp_removed">
        <callback name="nsp_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="DeviceWimax" c:type="NMDeviceWimax*"/>
            </parameter>
            <parameter name="nsp" transfer-ownership="none">
              <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="DeviceWimaxError"
                 glib:type-name="NMDeviceWimaxError"
                 glib:get-type="nm_device_wimax_error_get_type"
                 c:type="NMDeviceWimaxError"
                 glib:error-domain="nm-device-wimax-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_DEVICE_WIMAX_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="NotWimaxConnection"
              value="1"
              c:identifier="NM_DEVICE_WIMAX_ERROR_NOT_WIMAX_CONNECTION"
              glib:nick="NotWimaxConnection">
        <doc xml:whitespace="preserve">the connection was not of WiMax type</doc>
      </member>
      <member name="InvalidWimaxConnection"
              value="2"
              c:identifier="NM_DEVICE_WIMAX_ERROR_INVALID_WIMAX_CONNECTION"
              glib:nick="InvalidWimaxConnection">
        <doc xml:whitespace="preserve">the WiMax connection was invalid</doc>
      </member>
      <member name="InvalidDeviceMac"
              value="3"
              c:identifier="NM_DEVICE_WIMAX_ERROR_INVALID_DEVICE_MAC"
              glib:nick="InvalidDeviceMac">
        <doc xml:whitespace="preserve">the device's MAC was invalid</doc>
      </member>
      <member name="MacMismatch"
              value="4"
              c:identifier="NM_DEVICE_WIMAX_ERROR_MAC_MISMATCH"
              glib:nick="MacMismatch">
        <doc xml:whitespace="preserve">the MACs of the connection and the device mismatched</doc>
      </member>
      <function name="quark" c:identifier="nm_device_wimax_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceWimax if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMDeviceWimax errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="IP4Config"
           c:symbol-prefix="ip4_config"
           c:type="NMIP4Config"
           parent="Object"
           glib:type-name="NMIP4Config"
           glib:get-type="nm_ip4_config_get_type"
           glib:type-struct="IP4ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_ip4_config_new">
        <doc xml:whitespace="preserve">Creates a new #NMIP4Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new IP4 configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_addresses" c:identifier="nm_ip4_config_get_addresses">
        <doc xml:whitespace="preserve">Gets the IP4 addresses (containing the address, prefix, and gateway).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GSList containing #NMIP4Address&lt;!-- --&gt;es. This is the internal copy used by the configuration and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP4Address"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domains" c:identifier="nm_ip4_config_get_domains">
        <doc xml:whitespace="preserve">Gets the domain names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GPtrArray containing domains as strings. This is the internal copy used by the configuration, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nameservers"
              c:identifier="nm_ip4_config_get_nameservers">
        <doc xml:whitespace="preserve">Gets the domain name servers (DNS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GArray containing %guint32&lt;!-- --&gt;s. This is the internal copy used by the configuration and must not be modified.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint32"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_routes" c:identifier="nm_ip4_config_get_routes">
        <doc xml:whitespace="preserve">Gets the routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GSList containing #NMIP4Route&lt;!-- --&gt;s. This is the internal copy used by the configuration, and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP4Route"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wins_servers"
              c:identifier="nm_ip4_config_get_wins_servers">
        <doc xml:whitespace="preserve">Gets the Windows Internet Name Service servers (WINS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GArray containing %guint32&lt;!-- --&gt;s. This is the internal copy used by the configuration and must not be modified.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint32"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP4Config</doc>
            <type name="IP4Config" c:type="NMIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="addresses" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GPtrArray containing #NMSettingIP4Address&lt;!-- --&gt;es of the configuration.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="domains" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GPtrArray containing domain strings of the configuration.</doc>
        <type name="StringArray"/>
      </property>
      <property name="nameservers" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GArray containing name servers (%guint32&lt;!-- --&gt;es) of the configuration.</doc>
        <type name="UintArray"/>
      </property>
      <property name="routes" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GPtrArray containing #NMSettingIP4Route&lt;!-- --&gt;s of the configuration.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="wins-servers" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GArray containing WINS servers (%guint32&lt;!-- --&gt;es) of the configuration.</doc>
        <type name="UintArray"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="IP4ConfigClass"
            c:type="NMIP4ConfigClass"
            glib:is-gtype-struct-for="IP4Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="IP4_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_IP4_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_IP4_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_NAMESERVERS"
              value="nameservers"
              c:type="NM_IP4_CONFIG_NAMESERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_ROUTES"
              value="routes"
              c:type="NM_IP4_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP4_CONFIG_WINS_SERVERS"
              value="wins-servers"
              c:type="NM_IP4_CONFIG_WINS_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <glib:boxed glib:name="IP6AddressArray"
                c:symbol-prefix="ip6_address_array"
                glib:type-name="NMIP6AddressArray"
                glib:get-type="nm_ip6_address_array_get_type">
    </glib:boxed>
    <glib:boxed glib:name="IP6AddressObjectArray"
                c:symbol-prefix="ip6_address_object_array"
                glib:type-name="NMIP6AddressObjectArray"
                glib:get-type="nm_ip6_address_object_array_get_type">
    </glib:boxed>
    <class name="IP6Config"
           c:symbol-prefix="ip6_config"
           c:type="NMIP6Config"
           parent="Object"
           glib:type-name="NMIP6Config"
           glib:get-type="nm_ip6_config_get_type"
           glib:type-struct="IP6ConfigClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_ip6_config_new">
        <doc xml:whitespace="preserve">Creates a new #NMIP6Config.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new IP6 configuration</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the device</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_addresses" c:identifier="nm_ip6_config_get_addresses">
        <doc xml:whitespace="preserve">Gets the IP6 addresses (containing the address, prefix, and gateway).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GSList containing #NMIP6Address&lt;!-- --&gt;es. This is the internal copy used by the configuration and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP6Address"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domains" c:identifier="nm_ip6_config_get_domains">
        <doc xml:whitespace="preserve">Gets the domain names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GPtrArray containing domains as strings. This is the internal copy used by the configuration, and must not be modified.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nameservers"
              c:identifier="nm_ip6_config_get_nameservers"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets the domain name servers (DNS).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GSList containing elements of type 'struct in6_addr' which contain the addresses of nameservers of the configuration. This is the internal copy used by the configuration and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_routes" c:identifier="nm_ip6_config_get_routes">
        <doc xml:whitespace="preserve">Gets the routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GSList containing #NMIP6Route&lt;!-- --&gt;s. This is the internal copy used by the configuration, and must not be modified.</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <type name="NetworkManager.IP6Route"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMIP6Config</doc>
            <type name="IP6Config" c:type="NMIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="addresses" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GPtrArray containing the IPv6 addresses;  use
nm_utils_ip6_addresses_from_gvalue() to return a #GSList of
#NMSettingIP6Address objects that is more usable than the raw data.</doc>
        <type name="IP6AddressObjectArray"/>
      </property>
      <property name="domains" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GPtrArray containing domain strings of the configuration.</doc>
        <type name="StringArray"/>
      </property>
      <property name="nameservers" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GPtrArray containing elements of type 'struct ip6_addr' which
contain the addresses of nameservers of the configuration.</doc>
        <type name="IP6AddressArray"/>
      </property>
      <property name="routes" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GPtrArray containing the IPv6 routes;  use
nm_utils_ip6_routes_from_gvalue() to return a #GSList of
#NMSettingIP6Address objects that is more usable than the raw data.</doc>
        <type name="IP6RouteObjectArray"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="IP6ConfigClass"
            c:type="NMIP6ConfigClass"
            glib:is-gtype-struct-for="IP6Config">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <glib:boxed glib:name="IP6RouteObjectArray"
                c:symbol-prefix="ip6_route_object_array"
                glib:type-name="NMIP6RouteObjectArray"
                glib:get-type="nm_ip6_route_object_array_get_type">
    </glib:boxed>
    <constant name="IP6_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_IP6_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_IP6_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_NAMESERVERS"
              value="nameservers"
              c:type="NM_IP6_CONFIG_NAMESERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IP6_CONFIG_ROUTES"
              value="routes"
              c:type="NM_IP6_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="OBJECT_DBUS_CONNECTION"
              value="dbus-connection"
              c:type="NM_OBJECT_DBUS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="OBJECT_DBUS_PATH"
              value="dbus-path"
              c:type="NM_OBJECT_DBUS_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="NMObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMObject"
           glib:get-type="nm_object_get_type"
           glib:type-struct="ObjectClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <virtual-method name="object_creation_failed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="master_object" transfer-ownership="none">
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="failed_path" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_connection" c:identifier="nm_object_get_connection">
        <doc xml:whitespace="preserve">Gets the #NMObject's DBusGConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection</doc>
          <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMObject</doc>
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="nm_object_get_path">
        <doc xml:whitespace="preserve">Gets the DBus path of the #NMObject.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object's path. This is the internal string used by the device, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMObject</doc>
            <type name="Object" c:type="NMObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="dbus-connection"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="dbus-path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="object-creation-failed" when="first">
        <doc xml:whitespace="preserve">Indicates that an error occured while creating an #NMObject object
during property handling of @master_object.

Note: Be aware that the signal is private for libnm-glib's internal
      use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error that occured while creating object</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="failed_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">object path of the failed object</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <glib:boxed glib:name="ObjectArray"
                c:symbol-prefix="object_array"
                glib:type-name="NMObjectArray"
                glib:get-type="nm_object_array_get_type">
    </glib:boxed>
    <record name="ObjectClass"
            c:type="NMObjectClass"
            glib:is-gtype-struct-for="Object">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="object_creation_failed">
        <callback name="object_creation_failed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="master_object" transfer-ownership="none">
              <type name="Object" c:type="NMObject*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
            <parameter name="failed_path" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="ObjectError"
                 glib:type-name="NMObjectError"
                 glib:get-type="nm_object_error_get_type"
                 c:type="NMObjectError"
                 glib:error-domain="nm-object-error-quark">
      <doc xml:whitespace="preserve">Describes errors that may result from operations involving a #NMObject.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_OBJECT_ERROR_UNKNOWN"
              glib:nick="unknown">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="object_creation_failure"
              value="1"
              c:identifier="NM_OBJECT_ERROR_OBJECT_CREATION_FAILURE"
              glib:nick="object-creation-failure">
        <doc xml:whitespace="preserve">an error ocured while creating an #NMObject</doc>
      </member>
      <function name="quark" c:identifier="nm_object_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMObject if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMObject errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="REMOTE_CONNECTION_REMOVED"
              value="removed"
              c:type="NM_REMOTE_CONNECTION_REMOVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_CONNECTION_UPDATED"
              value="updated"
              c:type="NM_REMOTE_CONNECTION_UPDATED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_BUS"
              value="bus"
              c:type="NM_REMOTE_SETTINGS_BUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_CAN_MODIFY"
              value="can-modify"
              c:type="NM_REMOTE_SETTINGS_CAN_MODIFY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_CONNECTIONS_READ"
              value="connections-read"
              c:type="NM_REMOTE_SETTINGS_CONNECTIONS_READ">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_HOSTNAME"
              value="hostname"
              c:type="NM_REMOTE_SETTINGS_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_NEW_CONNECTION"
              value="new-connection"
              c:type="NM_REMOTE_SETTINGS_NEW_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="REMOTE_SETTINGS_SERVICE_RUNNING"
              value="service-running"
              c:type="NM_REMOTE_SETTINGS_SERVICE_RUNNING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="RemoteConnection"
           c:symbol-prefix="remote_connection"
           c:type="NMRemoteConnection"
           parent="NetworkManager.Connection"
           glib:type-name="NMRemoteConnection"
           glib:get-type="nm_remote_connection_get_type"
           glib:type-struct="RemoteConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_remote_connection_new">
        <doc xml:whitespace="preserve">Creates a new object representing the remote connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new remote connection object on success, or %NULL on failure</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a valid and connected D-Bus connection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus path of the connection as exported by the settings service</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="updated">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="new_settings" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="commit_changes"
              c:identifier="nm_remote_connection_commit_changes">
        <doc xml:whitespace="preserve">Save any local changes to the settings and properties of this connection and
save them in the settings service.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a function to be called when the commit completes</doc>
            <type name="RemoteConnectionCommitFunc"
                  c:type="NMRemoteConnectionCommitFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="nm_remote_connection_delete">
        <doc xml:whitespace="preserve">Delete the connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a function to be called when the delete completes</doc>
            <type name="RemoteConnectionDeleteFunc"
                  c:type="NMRemoteConnectionDeleteFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets"
              c:identifier="nm_remote_connection_get_secrets">
        <doc xml:whitespace="preserve">Request the connection's secrets.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMRemoteConnection</doc>
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </instance-parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMSetting object name to get secrets for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a function to be called when the update completes; must not be NULL</doc>
            <type name="RemoteConnectionGetSecretsFunc"
                  c:type="NMRemoteConnectionGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="dbus-connection"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="dbus-path"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="NetworkManager.Connection" c:type="NMConnection"/>
      </field>
      <glib:signal name="removed" when="first">
        <doc xml:whitespace="preserve">This signal is emitted when a connection is either deleted or becomes
invisible to the current user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="updated" when="first">
        <doc xml:whitespace="preserve">This signal is emitted when a connection changes, and it is
still visible to the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="visible" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="RemoteConnectionClass"
            c:type="NMRemoteConnectionClass"
            glib:is-gtype-struct-for="RemoteConnection">
      <field name="parent_class">
        <type name="NetworkManager.ConnectionClass"
              c:type="NMConnectionClass"/>
      </field>
      <field name="updated">
        <callback name="updated">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
            <parameter name="new_settings" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="removed">
        <callback name="removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="RemoteConnectionCommitFunc"
              c:type="NMRemoteConnectionCommitFunc">
      <doc xml:whitespace="preserve">Called when NetworkManager has committed outstanding changes to a connection
to backing storage as a result of nm_remote_connection_commit_changes().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection for which updates are to be committed</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">on failure, a descriptive error</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data passed to nm_remote_connection_commit_changes()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RemoteConnectionDeleteFunc"
              c:type="NMRemoteConnectionDeleteFunc">
      <doc xml:whitespace="preserve">Called when NetworkManager has deleted a connection as a result of
nm_remote_connection_delete().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection to be deleted</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">on failure, a descriptive error</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data passed to nm_remote_connection_delete()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="RemoteConnectionGetSecretsFunc"
              c:type="NMRemoteConnectionGetSecretsFunc">
      <doc xml:whitespace="preserve">Called when NetworkManager returns secrets in response to a request for
secrets via nm_remote_connection_get_secrets().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection for which secrets were requested</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </parameter>
        <parameter name="secrets" transfer-ownership="none">
          <doc xml:whitespace="preserve">on success, a hash table of hash tables, with each inner hash mapping a setting property to a #GValue containing that property's value</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">on failure, a descriptive error</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data passed to nm_remote_connection_get_secrets()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="RemoteSettings"
           c:symbol-prefix="remote_settings"
           c:type="NMRemoteSettings"
           parent="GObject.Object"
           glib:type-name="NMRemoteSettings"
           glib:get-type="nm_remote_settings_get_type"
           glib:type-struct="RemoteSettingsClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_remote_settings_new">
        <doc xml:whitespace="preserve">Creates a new object representing the remote settings service.

Note that this will do blocking D-Bus calls to initialize the
settings object. You can use nm_remote_settings_new_async() if you
want to avoid that.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new remote settings object on success, or %NULL on failure</doc>
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a valid and connected D-Bus connection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_finish"
                   c:identifier="nm_remote_settings_new_finish"
                   throws="1">
        <doc xml:whitespace="preserve">Gets the result of an nm_remote_settings_new_async() call.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #NMRemoteSettings object, or %NULL on error</doc>
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async" c:identifier="nm_remote_settings_new_async">
        <doc xml:whitespace="preserve">Creates a new object representing the remote settings service and
begins asynchronously initializing it. @callback will be called
when it is done; use nm_remote_settings_new_finish() to get the
result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a valid and connected D-Bus connection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">callback to call when the settings object is created</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="connections_read">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_connection">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_connection"
              c:identifier="nm_remote_settings_add_connection">
        <doc xml:whitespace="preserve">Requests that the remote settings service add the given settings to a new
connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the request was successful, FALSE if it failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the connection to add. Note that this object's settings will be added, not the object itself</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">callback to be called when the add operation completes</doc>
            <type name="RemoteSettingsAddConnectionFunc"
                  c:type="NMRemoteSettingsAddConnectionFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_by_path"
              c:identifier="nm_remote_settings_get_connection_by_path">
        <doc xml:whitespace="preserve">Returns the %NMRemoteConnection representing the connection at @path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the remote connection object on success, or NULL if the object was not known</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus object path of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_by_uuid"
              c:identifier="nm_remote_settings_get_connection_by_uuid">
        <doc xml:whitespace="preserve">Returns the %NMRemoteConnection identified by @uuid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the remote connection object on success, or NULL if the object was not known</doc>
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="uuid" transfer-ownership="none">
            <doc xml:whitespace="preserve">the UUID of the remote connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_connections"
              c:identifier="nm_remote_settings_list_connections">
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a list containing all connections provided by the remote settings service. Each element of the returned list is a %NMRemoteConnection instance, which is owned by the %NMRemoteSettings object and should not be freed by the caller. The returned list is, however, owned by the caller and should be freed using g_slist_free() when no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="RemoteConnection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save_hostname"
              c:identifier="nm_remote_settings_save_hostname">
        <doc xml:whitespace="preserve">Requests that the machine's persistent hostname be set to the specified value
or cleared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the request was successful, FALSE if it failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:whitespace="preserve">the %NMRemoteSettings</doc>
            <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new persistent hostname to set, or NULL to clear any existing persistent hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">callback to be called when the hostname operation completes</doc>
            <type name="RemoteSettingsSaveHostnameFunc"
                  c:type="NMRemoteSettingsSaveHostnameFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="can-modify" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="hostname" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service-running" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="connections-read" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="new-connection" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="RemoteSettingsAddConnectionFunc"
              c:type="NMRemoteSettingsAddConnectionFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="settings" transfer-ownership="none">
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="RemoteSettingsClass"
            c:type="NMRemoteSettingsClass"
            glib:is-gtype-struct-for="RemoteSettings">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="new_connection">
        <callback name="new_connection">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="RemoteConnection" c:type="NMRemoteConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connections_read">
        <callback name="connections_read">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="RemoteSettingsError"
                 glib:type-name="NMRemoteSettingsError"
                 glib:get-type="nm_remote_settings_error_get_type"
                 c:type="NMRemoteSettingsError"
                 glib:error-domain="nm-remote-settings-error-quark">
      <doc xml:whitespace="preserve">Describes errors that may result from operations involving a #NMRemoteSettings.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_REMOTE_SETTINGS_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:whitespace="preserve">unknown or unclassified error</doc>
      </member>
      <member name="ConnectionRemoved"
              value="1"
              c:identifier="NM_REMOTE_SETTINGS_ERROR_CONNECTION_REMOVED"
              glib:nick="ConnectionRemoved">
        <doc xml:whitespace="preserve">the #NMRemoteConnection object was removed before it was completely initialized</doc>
      </member>
      <member name="ConnectionUnavailable"
              value="2"
              c:identifier="NM_REMOTE_SETTINGS_ERROR_CONNECTION_UNAVAILABLE"
              glib:nick="ConnectionUnavailable">
        <doc xml:whitespace="preserve">the #NMRemoteConnection object is not visible or otherwise unreadable</doc>
      </member>
      <function name="quark" c:identifier="nm_remote_settings_error_quark">
        <doc xml:whitespace="preserve">Registers an error quark for #NMRemoteSettings if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the error quark used for #NMRemoteSettings errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <callback name="RemoteSettingsSaveHostnameFunc"
              c:type="NMRemoteSettingsSaveHostnameFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="settings" transfer-ownership="none">
          <type name="RemoteSettings" c:type="NMRemoteSettings*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="SECRET_AGENT_AUTO_REGISTER"
              value="auto-register"
              c:type="NM_SECRET_AGENT_AUTO_REGISTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_IDENTIFIER"
              value="identifier"
              c:type="NM_SECRET_AGENT_IDENTIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_REGISTERED"
              value="registered"
              c:type="NM_SECRET_AGENT_REGISTERED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SECRET_AGENT_REGISTRATION_RESULT"
              value="registration-result"
              c:type="NM_SECRET_AGENT_REGISTRATION_RESULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="SecretAgent"
           c:symbol-prefix="secret_agent"
           c:type="NMSecretAgent"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMSecretAgent"
           glib:get-type="nm_secret_agent_get_type"
           glib:type-struct="SecretAgentClass">
      <virtual-method name="cancel_get_secrets">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_secrets" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="3">
            <type name="SecretAgentDeleteSecretsFunc"
                  c:type="NMSecretAgentDeleteSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_secrets" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SecretAgentGetSecretsFlags"
                  c:type="NMSecretAgentGetSecretsFlags"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="6">
            <type name="SecretAgentGetSecretsFunc"
                  c:type="NMSecretAgentGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="6">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="registration_result">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save_secrets" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="connection_path" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="3">
            <type name="SecretAgentSaveSecretsFunc"
                  c:type="NMSecretAgentSaveSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="delete_secrets"
              c:identifier="nm_secret_agent_delete_secrets">
        <doc xml:whitespace="preserve">Asynchronously ask the agent to delete all saved secrets belonging to
@connection.

VFunc: delete_secrets</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentDeleteSecretsFunc"
                  c:type="NMSecretAgentDeleteSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_registered"
              c:identifier="nm_secret_agent_get_registered">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %TRUE if the agent is registered, %FALSE if it is not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secrets" c:identifier="nm_secret_agent_get_secrets">
        <doc xml:whitespace="preserve">Asyncronously retrieve secrets belonging to @connection for the
setting @setting_name.  @flags indicate specific behavior that the secret
agent should use when performing the request, for example returning only
existing secrets without user interaction, or requesting entirely new
secrets from the user.

VFunc: get_secrets</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #NMConnection for which we're asked secrets</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the secret setting</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:whitespace="preserve">hints to the agent</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags that modify the behavior of the request</doc>
            <type name="SecretAgentGetSecretsFlags"
                  c:type="NMSecretAgentGetSecretsFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentGetSecretsFunc"
                  c:type="NMSecretAgentGetSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="nm_secret_agent_register">
        <doc xml:whitespace="preserve">Registers the #NMSecretAgent with the NetworkManager secret manager,
indicating to NetworkManager that the agent is able to provide and save
secrets for connections on behalf of its user.  Registration is an
asynchronous operation and its success or failure is indicated via the
'registration-result' signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new %TRUE if registration was successfully requested (this does not mean registration itself was successful), %FALSE if registration was not successfully requested.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save_secrets" c:identifier="nm_secret_agent_save_secrets">
        <doc xml:whitespace="preserve">Asyncronously ensure that all secrets inside @connection
are stored to disk.

VFunc: save_secrets</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMConnection</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback, to be invoked when the operation is done</doc>
            <type name="SecretAgentSaveSecretsFunc"
                  c:type="NMSecretAgentSaveSecretsFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">caller-specific data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister" c:identifier="nm_secret_agent_unregister">
        <doc xml:whitespace="preserve">Unregisters the #NMSecretAgent with the NetworkManager secret manager,
indicating to NetworkManager that the agent is will no longer provide or
store secrets on behalf of this user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new %TRUE if unregistration was successful, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMSecretAgent</doc>
            <type name="SecretAgent" c:type="NMSecretAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="auto-register"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If TRUE, the agent will attempt to automatically register itself after
it is created (via an idle handler) and to re-register itself if
NetworkManager restarts.  If FALSE, the agent does not automatically
register with NetworkManager, and nm_secret_agent_register() must be
called.  If 'auto-register' is TRUE, calling nm_secret_agent_unregister()
will suppress auto-registration until nm_secret_agent_register() is
called, which re-enables auto-registration.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="identifier"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Identifies this agent; only one agent in each user session may use the
same identifier.  Identifier formatting follows the same rules as
D-Bus bus names with the exception that the ':' character is not
allowed.  The valid set of characters is "[A-Z][a-z][0-9]_-." and the
identifier is limited in length to 255 characters with a minimum
of 3 characters.  An example valid identifier is 'org.gnome.nm-applet'
(without quotes).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="registered" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the agent is registered with NetworkManager, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="registration-result" when="first">
        <doc xml:whitespace="preserve">Indicates the result of a registration request; if @error is NULL the
request was successful.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error, if any, that occured while registering</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SecretAgentClass"
            c:type="NMSecretAgentClass"
            glib:is-gtype-struct-for="SecretAgent">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_secrets" introspectable="0">
        <callback name="get_secrets" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="agent" transfer-ownership="none">
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="hints" transfer-ownership="none">
              <type name="utf8" c:type="const char**"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SecretAgentGetSecretsFlags"
                    c:type="NMSecretAgentGetSecretsFlags"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" closure="7">
              <type name="SecretAgentGetSecretsFunc"
                    c:type="NMSecretAgentGetSecretsFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="7">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cancel_get_secrets">
        <callback name="cancel_get_secrets">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="agent" transfer-ownership="none">
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="setting_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="save_secrets" introspectable="0">
        <callback name="save_secrets" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="agent" transfer-ownership="none">
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" closure="4">
              <type name="SecretAgentSaveSecretsFunc"
                    c:type="NMSecretAgentSaveSecretsFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_secrets" introspectable="0">
        <callback name="delete_secrets" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="agent" transfer-ownership="none">
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="NetworkManager.Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="connection_path" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" closure="4">
              <type name="SecretAgentDeleteSecretsFunc"
                    c:type="NMSecretAgentDeleteSecretsFunc"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="registration_result">
        <callback name="registration_result">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="agent" transfer-ownership="none">
              <type name="SecretAgent" c:type="NMSecretAgent*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="SecretAgentDeleteSecretsFunc"
              c:type="NMSecretAgentDeleteSecretsFunc">
      <doc xml:whitespace="preserve">Called as a result of a request by NM to delete secrets.  When the
#NMSecretAgent subclass has finished deleting the secrets, this function
should be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the secret agent object</doc>
          <type name="SecretAgent" c:type="NMSecretAgent*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection for which secrets were to be deleted, note that this object will be unrefed after the callback has returned, use g_object_ref()/g_object_unref() if you want to use this object after the callback has returned</doc>
          <type name="NetworkManager.Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">if the deleting secrets failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SecretAgentError"
                 glib:type-name="NMSecretAgentError"
                 glib:get-type="nm_secret_agent_error_get_type"
                 c:type="NMSecretAgentError"
                 glib:error-domain="nm-secret-agent-error">
      <doc xml:whitespace="preserve">#NMSecretAgentError values are passed by secret agents back to NetworkManager
when they encounter problems retrieving secrets on behalf of NM.</doc>
      <member name="NotAuthorized"
              value="0"
              c:identifier="NM_SECRET_AGENT_ERROR_NOT_AUTHORIZED"
              glib:nick="NotAuthorized">
        <doc xml:whitespace="preserve">the caller (ie, NetworkManager) is not authorized to make this request</doc>
      </member>
      <member name="InvalidConnection"
              value="1"
              c:identifier="NM_SECRET_AGENT_ERROR_INVALID_CONNECTION"
              glib:nick="InvalidConnection">
        <doc xml:whitespace="preserve">the connection for which secrets were requested could not be found</doc>
      </member>
      <member name="UserCanceled"
              value="2"
              c:identifier="NM_SECRET_AGENT_ERROR_USER_CANCELED"
              glib:nick="UserCanceled">
        <doc xml:whitespace="preserve">the request was canceled by the user</doc>
      </member>
      <member name="AgentCanceled"
              value="3"
              c:identifier="NM_SECRET_AGENT_ERROR_AGENT_CANCELED"
              glib:nick="AgentCanceled">
        <doc xml:whitespace="preserve">the agent canceled the request because it was requested to do so by NetworkManager</doc>
      </member>
      <member name="InternalError"
              value="4"
              c:identifier="NM_SECRET_AGENT_ERROR_INTERNAL_ERROR"
              glib:nick="InternalError">
        <doc xml:whitespace="preserve">some internal error in the agent caused the request to fail</doc>
      </member>
      <member name="NoSecrets"
              value="5"
              c:identifier="NM_SECRET_AGENT_ERROR_NO_SECRETS"
              glib:nick="NoSecrets">
        <doc xml:whitespace="preserve">the agent cannot find any secrets for this connection</doc>
      </member>
      <function name="quark" c:identifier="nm_secret_agent_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="SecretAgentGetSecretsFlags"
              glib:type-name="NMSecretAgentGetSecretsFlags"
              glib:get-type="nm_secret_agent_get_secrets_flags_get_type"
              c:type="NMSecretAgentGetSecretsFlags">
      <doc xml:whitespace="preserve">#NMSecretAgentGetSecretsFlags values modify the behavior of a GetSecrets request.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE"
              glib:nick="none">
        <doc xml:whitespace="preserve">no special behavior; by default no user interaction is allowed and requests for secrets are fulfilled from persistent storage, or if no secrets are available an error is returned.</doc>
      </member>
      <member name="allow_interaction"
              value="1"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION"
              glib:nick="allow-interaction">
        <doc xml:whitespace="preserve">allows the request to interact with the user, possibly prompting via UI for secrets if any are required, or if none are found in persistent storage.</doc>
      </member>
      <member name="request_new"
              value="2"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW"
              glib:nick="request-new">
        <doc xml:whitespace="preserve">explicitly prompt for new secrets from the user.  This flag signals that NetworkManager thinks any existing secrets are invalid or wrong.  This flag implies that interaction is allowed.</doc>
      </member>
      <member name="user_requested"
              value="4"
              c:identifier="NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED"
              glib:nick="user-requested">
        <doc xml:whitespace="preserve">set if the request was initiated by user-requested action via the D-Bus interface, as opposed to automatically initiated by NetworkManager in response to (for example) scan results or carrier changes.</doc>
      </member>
    </bitfield>
    <callback name="SecretAgentGetSecretsFunc"
              c:type="NMSecretAgentGetSecretsFunc">
      <doc xml:whitespace="preserve">Called as a result of a request by NM to retrieve secrets.  When the
#NMSecretAgent subclass has finished retrieving secrets and is ready to
return them, or to return an error, this function should be called with
those secrets or the error.

To easily create the hash table to return the WiFi PSK, you could do
something like this:
&lt;example&gt;
 &lt;title&gt;Creating a secrets hash&lt;/title&gt;
 &lt;programlisting&gt;
  NMConnection *secrets;
  NMSettingWirelessSecurity *s_wsec;
  GHashTable *secrets_hash;

  secrets = nm_connection_new ();
  s_wsec = (NMSettingWirelessSecurity *) nm_setting_wireless_security_new ();
  g_object_set (G_OBJECT (s_wsec),
                NM_SETTING_WIRELESS_SECURITY_PSK, "my really cool PSK",
                NULL);
  nm_connection_add_setting (secrets, NM_SETTING (s_wsec));
  secrets_hash = nm_connection_to_hash (secrets, NM_SETTING_HASH_FLAG_ALL);

  (call the NMSecretAgentGetSecretsFunc with secrets_hash)

  g_object_unref (secrets);
  g_hash_table_unref (secrets_hash);
 &lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the secret agent object</doc>
          <type name="SecretAgent" c:type="NMSecretAgent*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection for which secrets were requested, note that this object will be unrefed after the callback has returned, use g_object_ref()/g_object_unref() if you want to use this object after the callback has returned</doc>
          <type name="NetworkManager.Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="secrets" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GHashTable containing the requested secrets in the same format as an #NMConnection hash (as created by nm_connection_to_hash() for example).  Each key in @secrets should be the name of a #NMSetting object (like "802-11-wireless-security") and each value should be a #GHashTable.  The sub-hashes map string:#GValue where the string is the setting property name (like "psk") and the value is the secret</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">if the secrets request failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:whitespace="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SecretAgentSaveSecretsFunc"
              c:type="NMSecretAgentSaveSecretsFunc">
      <doc xml:whitespace="preserve">Called as a result of a request by NM to save secrets.  When the
#NMSecretAgent subclass has finished saving the secrets, this function
should be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the secret agent object</doc>
          <type name="SecretAgent" c:type="NMSecretAgent*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection for which secrets were to be saved, note that this object will be unrefed after the callback has returned, use g_object_ref()/g_object_unref() if you want to use this object after the callback has returned</doc>
          <type name="NetworkManager.Connection" c:type="NMConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">if the saving secrets failed, give a descriptive error here</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">caller-specific data to be passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <glib:boxed glib:name="Ssid"
                c:symbol-prefix="ssid"
                glib:type-name="NMSsid"
                glib:get-type="nm_ssid_get_type">
    </glib:boxed>
    <glib:boxed glib:name="StringArray"
                c:symbol-prefix="string_array"
                glib:type-name="NMStringArray"
                glib:get-type="nm_string_array_get_type">
    </glib:boxed>
    <glib:boxed glib:name="UintArray"
                c:symbol-prefix="uint_array"
                glib:type-name="NMUintArray"
                glib:get-type="nm_uint_array_get_type">
    </glib:boxed>
    <class name="VPNConnection"
           c:symbol-prefix="vpn_connection"
           c:type="NMVPNConnection"
           parent="ActiveConnection"
           glib:type-name="NMVPNConnection"
           glib:get-type="nm_vpn_connection_get_type"
           glib:type-struct="VPNConnectionClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_vpn_connection_new">
        <doc xml:whitespace="preserve">Creates a new #NMVPNConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new connection object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the DBus object path of the new connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="vpn_state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="VPNConnection" c:type="NMVPNConnection*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <type name="NetworkManager.VPNConnectionState"
                  c:type="NMVPNConnectionState"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <type name="NetworkManager.VPNConnectionStateReason"
                  c:type="NMVPNConnectionStateReason"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_banner" c:identifier="nm_vpn_connection_get_banner">
        <doc xml:whitespace="preserve">Gets the VPN login banner of the active #NMVPNConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the VPN login banner of the VPN connection. This is the internal string used by the connection, and must not be modified.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vpn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMVPNConnection</doc>
            <type name="VPNConnection" c:type="NMVPNConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpn_state"
              c:identifier="nm_vpn_connection_get_vpn_state">
        <doc xml:whitespace="preserve">Gets the current #NMVPNConnection state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the VPN state of the active VPN connection.</doc>
          <type name="NetworkManager.VPNConnectionState"
                c:type="NMVPNConnectionState"/>
        </return-value>
        <parameters>
          <instance-parameter name="vpn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMVPNConnection</doc>
            <type name="VPNConnection" c:type="NMVPNConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="banner" transfer-ownership="none">
        <doc xml:whitespace="preserve">The VPN login banner of the active VPN connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vpn-state" transfer-ownership="none">
        <doc xml:whitespace="preserve">The VPN state of the active VPN connection.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="ActiveConnection" c:type="NMActiveConnection"/>
      </field>
      <glib:signal name="vpn-state-changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="VPNConnectionClass"
            c:type="NMVPNConnectionClass"
            glib:is-gtype-struct-for="VPNConnection">
      <field name="parent">
        <type name="ActiveConnectionClass" c:type="NMActiveConnectionClass"/>
      </field>
      <field name="vpn_state_changed">
        <callback name="vpn_state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="VPNConnection" c:type="NMVPNConnection*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <type name="NetworkManager.VPNConnectionState"
                    c:type="NMVPNConnectionState"/>
            </parameter>
            <parameter name="reason" transfer-ownership="none">
              <type name="NetworkManager.VPNConnectionStateReason"
                    c:type="NMVPNConnectionStateReason"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <constant name="VPN_CONNECTION_BANNER"
              value="banner"
              c:type="NM_VPN_CONNECTION_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_CONNECTION_VPN_STATE"
              value="vpn-state"
              c:type="NM_VPN_CONNECTION_VPN_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_NAME" value="name" c:type="NM_WIMAX_NSP_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_NETWORK_TYPE"
              value="network-type"
              c:type="NM_WIMAX_NSP_NETWORK_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="WIMAX_NSP_SIGNAL_QUALITY"
              value="signal-quality"
              c:type="NM_WIMAX_NSP_SIGNAL_QUALITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="WimaxNsp"
           c:symbol-prefix="wimax_nsp"
           c:type="NMWimaxNsp"
           parent="Object"
           glib:type-name="NMWimaxNsp"
           glib:get-type="nm_wimax_nsp_get_type"
           glib:type-struct="WimaxNspClass">
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="nm_wimax_nsp_new">
        <doc xml:whitespace="preserve">Creates a new #NMWimaxNsp.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new WiMAX NSP</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #DBusGConnection</doc>
            <type name="DBusGLib.Connection" c:type="DBusGConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus object path of the WiMAX NSP</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="connection_valid"
              c:identifier="nm_wimax_nsp_connection_valid">
        <doc xml:whitespace="preserve">Validates a given connection against a given WiMAX NSP to ensure that the
connection may be activated with that NSP.  The connection must match the
@nsp's network name and other attributes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection may be activated with this WiMAX NSP, %FALSE if it cannot be.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMWimaxNsp to validate @connection against</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMConnection to validate against @nsp</doc>
            <type name="NetworkManager.Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_connections"
              c:identifier="nm_wimax_nsp_filter_connections">
        <doc xml:whitespace="preserve">Filters a given list of connections for a given #NMWimaxNsp object and
return connections which may be activated with the access point.  Any
returned connections will match the @nsp's network name and other attributes.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a list of #NMConnection objects that could be activated with the given @nsp. The elements of the list are owned by their creator and should not be freed by the caller, but the returned list itself is owned by the caller and should be freed with g_slist_free() when it is no longer required.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="NetworkManager.Connection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #NMWimaxNsp to filter connections for</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
          <parameter name="connections" transfer-ownership="none">
            <doc xml:whitespace="preserve">a list of #NMConnection objects to filter</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="NetworkManager.Connection"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_wimax_nsp_get_name">
        <doc xml:whitespace="preserve">Gets the name of the wimax NSP</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_type"
              c:identifier="nm_wimax_nsp_get_network_type">
        <doc xml:whitespace="preserve">Gets the network type of the wimax NSP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the network type</doc>
          <type name="WimaxNspNetworkType" c:type="NMWimaxNspNetworkType"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_signal_quality"
              c:identifier="nm_wimax_nsp_get_signal_quality">
        <doc xml:whitespace="preserve">Gets the WPA signal quality of the wimax NSP.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the signal quality</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="nsp" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #NMWimaxNsp</doc>
            <type name="WimaxNsp" c:type="NMWimaxNsp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="name" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the WiMAX NSP.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="network-type" transfer-ownership="none">
        <doc xml:whitespace="preserve">The network type of the WiMAX NSP.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="signal-quality" transfer-ownership="none">
        <doc xml:whitespace="preserve">The signal quality of the WiMAX NSP.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="NMObject"/>
      </field>
    </class>
    <record name="WimaxNspClass"
            c:type="NMWimaxNspClass"
            glib:is-gtype-struct-for="WimaxNsp">
      <field name="parent">
        <type name="ObjectClass" c:type="NMObjectClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved5" introspectable="0">
        <callback name="_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved6" introspectable="0">
        <callback name="_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="WimaxNspNetworkType"
                 glib:type-name="NMWimaxNspNetworkType"
                 glib:get-type="nm_wimax_nsp_network_type_get_type"
                 c:type="NMWimaxNspNetworkType">
      <member name="unknown"
              value="0"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN"
              glib:nick="unknown">
      </member>
      <member name="home"
              value="1"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_HOME"
              glib:nick="home">
      </member>
      <member name="partner"
              value="2"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_PARTNER"
              glib:nick="partner">
      </member>
      <member name="roaming_partner"
              value="3"
              c:identifier="NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER"
              glib:nick="roaming-partner">
      </member>
    </enumeration>
    <function name="device_adsl_error_quark"
              c:identifier="nm_device_adsl_error_quark"
              moved-to="DeviceAdslError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceAdsl if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceAdsl errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_bond_error_quark"
              c:identifier="nm_device_bond_error_quark"
              moved-to="DeviceBondError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceBond if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceBond errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_bridge_error_quark"
              c:identifier="nm_device_bridge_error_quark"
              moved-to="DeviceBridgeError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceBridge if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceBridge errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_bt_error_quark"
              c:identifier="nm_device_bt_error_quark"
              moved-to="DeviceBtError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceBt if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceBt errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_ethernet_error_quark"
              c:identifier="nm_device_ethernet_error_quark"
              moved-to="DeviceEthernetError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceEthernet if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceEthernet errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_infiniband_error_quark"
              c:identifier="nm_device_infiniband_error_quark"
              moved-to="DeviceInfinibandError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceInfiniband if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceInfiniband errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_modem_error_quark"
              c:identifier="nm_device_modem_error_quark"
              moved-to="DeviceModemError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceModem if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceModem errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_olpc_mesh_error_quark"
              c:identifier="nm_device_olpc_mesh_error_quark"
              moved-to="DeviceOlpcMeshError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceOlpcMesh if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceOlpcMesh errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_vlan_error_quark"
              c:identifier="nm_device_vlan_error_quark"
              moved-to="DeviceVlanError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceVlan if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceVlan errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_wifi_error_quark"
              c:identifier="nm_device_wifi_error_quark"
              moved-to="DeviceWifiError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceWifi if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceWifi errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="device_wimax_error_quark"
              c:identifier="nm_device_wimax_error_quark"
              moved-to="DeviceWimaxError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMDeviceWimax if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMDeviceWimax errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="object_error_quark"
              c:identifier="nm_object_error_quark"
              moved-to="ObjectError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMObject if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMObject errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="remote_settings_error_quark"
              c:identifier="nm_remote_settings_error_quark"
              moved-to="RemoteSettingsError.quark">
      <doc xml:whitespace="preserve">Registers an error quark for #NMRemoteSettings if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the error quark used for #NMRemoteSettings errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="secret_agent_error_quark"
              c:identifier="nm_secret_agent_error_quark"
              moved-to="SecretAgentError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
  </namespace>
</repository>
