<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <namespace name="TotemPlParser"
             version="1.0"
             shared-library="libtotem-plparser.so.17"
             c:identifier-prefixes="TotemPl,TotemDisc,TotemCd"
             c:symbol-prefixes="totem_pl,totem_disc,totem_cd">
    <alias name="ParserMetadata"
           c:type="TotemPlParserMetadata"
           introspectable="0">
      <doc xml:whitespace="preserve">An alias for #GHashTable, used in the #TotemPlParser::entry-parsed and
#TotemPlParser::playlist-started signals due to #GHashTable not being a
boxed type when totem-pl-parser was originally written.

The hash table is a mapping from field names (such as
%TOTEM_PL_PARSER_FIELD_ALBUM) to their associated values.

It is safe to use #GHashTable instead of #TotemPlParserMetadata everywhere.</doc>
      <type name="GLib.HashTable" c:type="GHashTable"/>
    </alias>
    <enumeration name="MediaType"
                 glib:type-name="TotemDiscMediaType"
                 glib:get-type="totem_disc_media_type_get_type"
                 c:type="TotemDiscMediaType">
      <doc xml:whitespace="preserve">Gives the media type of a disc, or %MEDIA_TYPE_ERROR if the media type
could not be determined.</doc>
      <member name="error"
              value="-1"
              c:identifier="MEDIA_TYPE_ERROR"
              glib:nick="error"/>
      <member name="data"
              value="1"
              c:identifier="MEDIA_TYPE_DATA"
              glib:nick="data"/>
      <member name="cdda"
              value="2"
              c:identifier="MEDIA_TYPE_CDDA"
              glib:nick="cdda"/>
      <member name="vcd"
              value="3"
              c:identifier="MEDIA_TYPE_VCD"
              glib:nick="vcd"/>
      <member name="dvd"
              value="4"
              c:identifier="MEDIA_TYPE_DVD"
              glib:nick="dvd"/>
      <member name="dvb"
              value="5"
              c:identifier="MEDIA_TYPE_DVB"
              glib:nick="dvb"/>
      <function name="quark" c:identifier="totem_disc_media_type_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="PARSER_FIELD_ABSTRACT"
              value="abstract"
              c:type="TOTEM_PL_PARSER_FIELD_ABSTRACT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_ALBUM"
              value="album"
              c:type="TOTEM_PL_PARSER_FIELD_ALBUM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_AUTHOR"
              value="author"
              c:type="TOTEM_PL_PARSER_FIELD_AUTHOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_AUTOPLAY"
              value="autoplay"
              c:type="TOTEM_PL_PARSER_FIELD_AUTOPLAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_BASE"
              value="base"
              c:type="TOTEM_PL_PARSER_FIELD_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_CONTACT"
              value="contact"
              c:type="TOTEM_PL_PARSER_FIELD_CONTACT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_CONTENT_TYPE"
              value="content-type"
              c:type="TOTEM_PL_PARSER_FIELD_CONTENT_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_COPYRIGHT"
              value="copyright"
              c:type="TOTEM_PL_PARSER_FIELD_COPYRIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_DESCRIPTION"
              value="description"
              c:type="TOTEM_PL_PARSER_FIELD_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_DOWNLOAD_URI"
              value="download-url"
              c:type="TOTEM_PL_PARSER_FIELD_DOWNLOAD_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_DURATION"
              value="duration"
              c:type="TOTEM_PL_PARSER_FIELD_DURATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_DURATION_MS"
              value="duration-ms"
              c:type="TOTEM_PL_PARSER_FIELD_DURATION_MS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_ENDTIME"
              value="endtime"
              c:type="TOTEM_PL_PARSER_FIELD_ENDTIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_FILESIZE"
              value="filesize"
              c:type="TOTEM_PL_PARSER_FIELD_FILESIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_GENRE"
              value="genre"
              c:type="TOTEM_PL_PARSER_FIELD_GENRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_ID"
              value="id"
              c:type="TOTEM_PL_PARSER_FIELD_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_IMAGE_URI"
              value="image-url"
              c:type="TOTEM_PL_PARSER_FIELD_IMAGE_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_IS_PLAYLIST"
              value="is-playlist"
              c:type="TOTEM_PL_PARSER_FIELD_IS_PLAYLIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_LANGUAGE"
              value="language"
              c:type="TOTEM_PL_PARSER_FIELD_LANGUAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_MOREINFO"
              value="moreinfo"
              c:type="TOTEM_PL_PARSER_FIELD_MOREINFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_PUB_DATE"
              value="publication-date"
              c:type="TOTEM_PL_PARSER_FIELD_PUB_DATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_SCREENSIZE"
              value="screensize"
              c:type="TOTEM_PL_PARSER_FIELD_SCREENSIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_STARTTIME"
              value="starttime"
              c:type="TOTEM_PL_PARSER_FIELD_STARTTIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_SUBTITLE_URI"
              value="subtitle-uri"
              c:type="TOTEM_PL_PARSER_FIELD_SUBTITLE_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_TITLE"
              value="title"
              c:type="TOTEM_PL_PARSER_FIELD_TITLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_UI_MODE"
              value="ui-mode"
              c:type="TOTEM_PL_PARSER_FIELD_UI_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_URI"
              value="url"
              c:type="TOTEM_PL_PARSER_FIELD_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_FIELD_VOLUME"
              value="volume"
              c:type="TOTEM_PL_PARSER_FIELD_VOLUME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PARSER_VERSION_MAJOR"
              value="3"
              c:type="TOTEM_PL_PARSER_VERSION_MAJOR">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARSER_VERSION_MICRO"
              value="2"
              c:type="TOTEM_PL_PARSER_VERSION_MICRO">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARSER_VERSION_MINOR"
              value="4"
              c:type="TOTEM_PL_PARSER_VERSION_MINOR">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Parser"
           c:symbol-prefix="parser"
           c:type="TotemPlParser"
           parent="GObject.Object"
           glib:type-name="TotemPlParser"
           glib:get-type="totem_pl_parser_get_type"
           glib:type-struct="ParserClass">
      <doc xml:whitespace="preserve">All the fields in the #TotemPlParser structure are private and should never be accessed directly.</doc>
      <constructor name="new" c:identifier="totem_pl_parser_new">
        <doc xml:whitespace="preserve">Creates a #TotemPlParser object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TotemPlParser</doc>
          <type name="Parser" c:type="TotemPlParser*"/>
        </return-value>
      </constructor>
      <function name="can_parse_from_data"
                c:identifier="totem_pl_parser_can_parse_from_data">
        <doc xml:whitespace="preserve">Checks if the first @len bytes of @data can be parsed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @data can be parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to check for parsability</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of data to check</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if debug statements should be printed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="can_parse_from_filename"
                c:identifier="totem_pl_parser_can_parse_from_filename">
        <doc xml:whitespace="preserve">Checks if the file can be parsed. Files can be parsed if:
&lt;itemizedlist&gt;
 &lt;listitem&gt;&lt;para&gt;they have a special mimetype, or&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;they have a mimetype which could be a video or a playlist.&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @filename can be parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the file to check for parsability</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if debug statements should be printed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="can_parse_from_uri"
                c:identifier="totem_pl_parser_can_parse_from_uri">
        <doc xml:whitespace="preserve">Checks if the remote URI can be parsed. Note that this does
not actually try to open the remote URI, or deduce its mime-type
from filename, as this would bring too many false positives.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @uri could be parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the remote URI to check for parsability</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if debug statements should be printed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_date" c:identifier="totem_pl_parser_parse_date">
        <doc xml:whitespace="preserve">Parses the given date string and returns it as a &lt;type&gt;gint64&lt;/type&gt;
denoting the date in seconds since the UNIX Epoch.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the date in seconds, or -1 on error</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <parameter name="date_str" transfer-ownership="none">
            <doc xml:whitespace="preserve">the date string to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if debug statements should be printed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_duration"
                c:identifier="totem_pl_parser_parse_duration">
        <doc xml:whitespace="preserve">Parses the given duration string and returns it as a &lt;type&gt;gint64&lt;/type&gt;
denoting the duration in seconds.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the duration in seconds, or -1 on error</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration string to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if debug statements should be printed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="entry_parsed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="metadata" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="playlist_ended">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="playlist_started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="metadata" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_ignored_mimetype"
              c:identifier="totem_pl_parser_add_ignored_mimetype">
        <doc xml:whitespace="preserve">Adds a mimetype to the list of mimetypes to ignore, so that
any URI of that mimetype is ignored during playlist parsing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mimetype" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mimetype to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_ignored_scheme"
              c:identifier="totem_pl_parser_add_ignored_scheme">
        <doc xml:whitespace="preserve">Adds a scheme to the list of schemes to ignore, so that
any URI using that scheme is ignored during playlist parsing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">the scheme to ignore</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse" c:identifier="totem_pl_parser_parse">
        <doc xml:whitespace="preserve">Parses a playlist given by the absolute URI @uri. This method is
synchronous, and will block on (e.g.) network requests to slow
servers. totem_pl_parser_parse_async() is recommended instead.

Return values are as totem_pl_parser_parse_with_base().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TotemPlParserResult</doc>
          <type name="ParserResult" c:type="TotemPlParserResult"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI of the playlist to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fallback" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the parser should add the playlist URI to the end of the playlist on parse failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_async" c:identifier="totem_pl_parser_parse_async">
        <doc xml:whitespace="preserve">Starts asynchronous parsing of a playlist given by the absolute URI @uri. @parser and @uri are both reffed/copied
when this function is called, so can safely be freed after this function returns.

For more details, see totem_pl_parser_parse(), which is the synchronous version of this function.

When the operation is finished, @callback will be called. You can then call totem_pl_parser_parse_finish()
to get the results of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI of the playlist to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fallback" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the parser should add the playlist URI to the end of the playlist on parse failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when parsing is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to the @callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_finish"
              c:identifier="totem_pl_parser_parse_finish"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous playlist parsing operation started with totem_pl_parser_parse_async()
or totem_pl_parser_parse_with_base_async().

If parsing of the playlist is cancelled part-way through, %TOTEM_PL_PARSER_RESULT_CANCELLED is returned when
this function is called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TotemPlParserResult</doc>
          <type name="ParserResult" c:type="TotemPlParserResult"/>
        </return-value>
        <parameters>
          <parameter name="async_result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_with_base"
              c:identifier="totem_pl_parser_parse_with_base">
        <doc xml:whitespace="preserve">Parses a playlist given by the absolute URI @uri, using
@base to resolve relative paths where appropriate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TotemPlParserResult</doc>
          <type name="ParserResult" c:type="TotemPlParserResult"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI of the playlist to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="base" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the base path for relative filenames, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fallback" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the parser should add the playlist URI to the end of the playlist on parse failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_with_base_async"
              c:identifier="totem_pl_parser_parse_with_base_async">
        <doc xml:whitespace="preserve">Starts asynchronous parsing of a playlist given by the absolute URI @uri, using @base to resolve relative paths where appropriate.
@parser and @uri are both reffed/copied when this function is called, so can safely be freed after this function returns.

For more details, see totem_pl_parser_parse_with_base(), which is the synchronous version of this function.

When the operation is finished, @callback will be called. You can then call totem_pl_parser_parse_finish()
to get the results of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI of the playlist to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="base" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the base path for relative filenames, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fallback" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the parser should add the playlist URI to the end of the playlist on parse failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when parsing is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to the @callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="totem_pl_parser_save" throws="1">
        <doc xml:whitespace="preserve">Writes the playlist held by @parser and @playlist out to the path
pointed by @dest. The playlist is written in the format @type and is
given the title @title.

If the @output file is a directory the #G_IO_ERROR_IS_DIRECTORY error
will be returned, and if the file is some other form of non-regular file
then a #G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some file
systems don't allow all file names, and may return a
#G_IO_ERROR_INVALID_FILENAME error, and if the name is too long,
#G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible
too, and depend on what kind of filesystem the file is on.

In extreme cases, a #G_IO_ERROR_INVALID_ARGUMENT error can be returned, if
parts of the playlist to be written are too long.

If writing a PLA playlist and there is an error converting a URI's encoding,
a code from #GConvertError will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="playlist" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TotemPlPlaylist</doc>
            <type name="Playlist" c:type="TotemPlPlaylist*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">output #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:whitespace="preserve">the playlist title</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TotemPlParserType for the outputted playlist</doc>
            <type name="ParserType" c:type="TotemPlParserType"/>
          </parameter>
        </parameters>
      </method>
      <property name="debug" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the parser will output debug information.</doc>
        <type name="gboolean"/>
      </property>
      <property name="disable-unsafe" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the parser will not parse unsafe locations, such as local devices
and local files if the playlist isn't local. This is useful if the library
is parsing a playlist from a remote location such as a website.</doc>
        <type name="gboolean"/>
      </property>
      <property name="force" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the parser will attempt to parse a playlist, even if it
appears to be unsupported (usually because of its filename extension).</doc>
        <type name="gboolean"/>
      </property>
      <property name="recurse"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the parser will recursively fetch playlists linked to by
the current one.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ParserPrivate" c:type="TotemPlParserPrivate*"/>
      </field>
      <glib:signal name="entry-parsed" when="last">
        <doc xml:whitespace="preserve">The ::entry-parsed signal is emitted when a new entry is parsed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI of the entry parsed</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="metadata" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable of metadata relating to the entry added</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="playlist-ended" when="last">
        <doc xml:whitespace="preserve">The ::playlist-ended signal is emitted when a playlist is finished
parsing. It is only called when #TotemPlParser::playlist-started
has been called for that playlist.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI of the playlist that finished parsing.</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="playlist-started" when="last">
        <doc xml:whitespace="preserve">The ::playlist-started signal is emitted when a playlist parsing has
started. This signal isn't emitted for all types of playlists, but
can be relied on to be called for playlists which support playlist
metadata, such as title.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI of the new playlist started</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="metadata" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GHashTable of metadata relating to the playlist that started.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ParserClass"
            c:type="TotemPlParserClass"
            glib:is-gtype-struct-for="Parser">
      <doc xml:whitespace="preserve">The class structure for the #TotemPlParser type.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="entry_parsed">
        <callback name="entry_parsed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="TotemPlParser*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="metadata" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="playlist_started">
        <callback name="playlist_started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="TotemPlParser*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="metadata" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="playlist_ended">
        <callback name="playlist_ended">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="Parser" c:type="TotemPlParser*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="ParserError"
                 glib:type-name="TotemPlParserError"
                 glib:get-type="totem_pl_parser_error_get_type"
                 c:type="TotemPlParserError"
                 glib:error-domain="totem_pl_parser_error">
      <doc xml:whitespace="preserve">Allows you to differentiate between different
errors occurring during file operations in a #TotemPlParser.</doc>
      <member name="no_disc"
              value="0"
              c:identifier="TOTEM_PL_PARSER_ERROR_NO_DISC"
              glib:nick="no-disc"/>
      <member name="mount_failed"
              value="1"
              c:identifier="TOTEM_PL_PARSER_ERROR_MOUNT_FAILED"
              glib:nick="mount-failed"/>
      <member name="empty_playlist"
              value="2"
              c:identifier="TOTEM_PL_PARSER_ERROR_EMPTY_PLAYLIST"
              glib:nick="empty-playlist"/>
      <function name="quark" c:identifier="totem_pl_parser_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ParserPrivate" c:type="TotemPlParserPrivate" disguised="1">
    </record>
    <enumeration name="ParserResult"
                 glib:type-name="TotemPlParserResult"
                 glib:get-type="totem_pl_parser_result_get_type"
                 c:type="TotemPlParserResult">
      <doc xml:whitespace="preserve">Gives the result of parsing a playlist.</doc>
      <member name="unhandled"
              value="0"
              c:identifier="TOTEM_PL_PARSER_RESULT_UNHANDLED"
              glib:nick="unhandled"/>
      <member name="error"
              value="1"
              c:identifier="TOTEM_PL_PARSER_RESULT_ERROR"
              glib:nick="error"/>
      <member name="success"
              value="2"
              c:identifier="TOTEM_PL_PARSER_RESULT_SUCCESS"
              glib:nick="success"/>
      <member name="ignored"
              value="3"
              c:identifier="TOTEM_PL_PARSER_RESULT_IGNORED"
              glib:nick="ignored"/>
      <member name="cancelled"
              value="4"
              c:identifier="TOTEM_PL_PARSER_RESULT_CANCELLED"
              glib:nick="cancelled"/>
    </enumeration>
    <enumeration name="ParserType"
                 glib:type-name="TotemPlParserType"
                 glib:get-type="totem_pl_parser_type_get_type"
                 c:type="TotemPlParserType">
      <doc xml:whitespace="preserve">The type of playlist a #TotemPlParser will parse.</doc>
      <member name="pls"
              value="0"
              c:identifier="TOTEM_PL_PARSER_PLS"
              glib:nick="pls"/>
      <member name="m3u"
              value="1"
              c:identifier="TOTEM_PL_PARSER_M3U"
              glib:nick="m3u"/>
      <member name="m3u_dos"
              value="2"
              c:identifier="TOTEM_PL_PARSER_M3U_DOS"
              glib:nick="m3u-dos"/>
      <member name="xspf"
              value="3"
              c:identifier="TOTEM_PL_PARSER_XSPF"
              glib:nick="xspf"/>
      <member name="iriver_pla"
              value="4"
              c:identifier="TOTEM_PL_PARSER_IRIVER_PLA"
              glib:nick="iriver-pla"/>
    </enumeration>
    <class name="Playlist"
           c:symbol-prefix="playlist"
           c:type="TotemPlPlaylist"
           parent="GObject.Object"
           glib:type-name="TotemPlPlaylist"
           glib:get-type="totem_pl_playlist_get_type"
           glib:type-struct="PlaylistClass">
      <doc xml:whitespace="preserve">All the fields in the #TotemPlPlaylist structure are private and should never be accessed directly.</doc>
      <constructor name="new" c:identifier="totem_pl_playlist_new">
        <return-value transfer-ownership="full">
          <type name="Playlist" c:type="TotemPlPlaylist*"/>
        </return-value>
      </constructor>
      <method name="append" c:identifier="totem_pl_playlist_append">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get"
              c:identifier="totem_pl_playlist_get"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist"
              c:identifier="totem_pl_playlist_get_valist"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="totem_pl_playlist_get_value">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="totem_pl_playlist_insert">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="position" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_first" c:identifier="totem_pl_playlist_iter_first">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_next" c:identifier="totem_pl_playlist_iter_next">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_prev" c:identifier="totem_pl_playlist_iter_prev">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend" c:identifier="totem_pl_playlist_prepend">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set"
              c:identifier="totem_pl_playlist_set"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="totem_pl_playlist_set_valist"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="totem_pl_playlist_set_value">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <type name="PlaylistIter" c:type="TotemPlPlaylistIter*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="totem_pl_playlist_size">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="PlaylistClass"
            c:type="TotemPlPlaylistClass"
            glib:is-gtype-struct-for="Playlist">
      <doc xml:whitespace="preserve">All the fields in the #TotemPlPlaylistClass structure are private and should never be accessed directly.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="PlaylistIter" c:type="TotemPlPlaylistIter">
      <doc xml:whitespace="preserve">All the fields in the #TotemPlPlaylistIter structure are private and should never be accessed directly.</doc>
      <field name="data1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="data2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <function name="detect_type"
              c:identifier="totem_cd_detect_type"
              throws="1">
      <doc xml:whitespace="preserve">Detects the disc's type, given its device node path.

Possible error codes are as per totem_cd_detect_type_with_url().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#TotemDiscMediaType corresponding to the disc's type, or #MEDIA_TYPE_ERROR on failure</doc>
        <type name="MediaType" c:type="TotemDiscMediaType"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <doc xml:whitespace="preserve">a device node path</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="detect_type_from_dir"
              c:identifier="totem_cd_detect_type_from_dir"
              throws="1">
      <doc xml:whitespace="preserve">Detects the disc's type, given its mount directory URI. If
a string pointer is passed to @mrl, it will return the disc's
MRL as from totem_cd_mrl_from_type().

Note that this function does synchronous I/O.

If no disc is present in the drive, a #TOTEM_PL_PARSER_ERROR_NO_DISC
error will be returned. On unknown mounting errors, a
#TOTEM_PL_PARSER_ERROR_MOUNT_FAILED error will be returned. On other
I/O errors, or if resolution of symlinked mount paths failed, a code from
#GIOErrorEnum will be returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#TotemDiscMediaType corresponding to the disc's type, or #MEDIA_TYPE_ERROR on failure</doc>
        <type name="MediaType" c:type="TotemDiscMediaType"/>
      </return-value>
      <parameters>
        <parameter name="dir" transfer-ownership="none">
          <doc xml:whitespace="preserve">a directory URI</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="mrl"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">return location for the disc's MRL, or %NULL</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="detect_type_with_url"
              c:identifier="totem_cd_detect_type_with_url"
              throws="1">
      <doc xml:whitespace="preserve">Detects the disc's type, given its device node path. If
a string pointer is passed to @mrl, it will return the disc's
MRL as from totem_cd_mrl_from_type().

Note that this function does synchronous I/O.

Possible error codes are as per totem_cd_detect_type_from_dir().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#TotemDiscMediaType corresponding to the disc's type, or #MEDIA_TYPE_ERROR on failure</doc>
        <type name="MediaType" c:type="TotemDiscMediaType"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <doc xml:whitespace="preserve">a device node path</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="mrl"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">return location for the disc's MRL, or %NULL</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_human_readable_name"
              c:identifier="totem_cd_get_human_readable_name">
      <doc xml:whitespace="preserve">Returns the human-readable name for the given
#TotemDiscMediaType.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the disc media type's readable name, which must not be freed, or %NULL for unhandled media types</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TotemDiscMediaType</doc>
          <type name="MediaType" c:type="TotemDiscMediaType"/>
        </parameter>
      </parameters>
    </function>
    <function name="has_medium" c:identifier="totem_cd_has_medium">
      <doc xml:whitespace="preserve">Returns whether the disc has a physical medium.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the disc physically exists</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="device" transfer-ownership="none">
          <doc xml:whitespace="preserve">a device node path</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="media_type_quark"
              c:identifier="totem_disc_media_type_quark"
              moved-to="MediaType.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="mrl_from_type" c:identifier="totem_cd_mrl_from_type">
      <doc xml:whitespace="preserve">Builds an MRL using the scheme @scheme and the given URI @dir,
taking the filename from the URI if it's a &lt;filename&gt;file://&lt;/filename&gt; and just
using the whole URI otherwise.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly-allocated string containing the MRL</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="scheme" transfer-ownership="none">
          <doc xml:whitespace="preserve">a scheme (e.g. "dvd")</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="dir" transfer-ownership="none">
          <doc xml:whitespace="preserve">a directory URI</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="parser_error_quark"
              c:identifier="totem_pl_parser_error_quark"
              moved-to="ParserError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="parser_metadata_get_type"
              c:identifier="totem_pl_parser_metadata_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
  </namespace>
</repository>
