<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="libsecret-1"/>
  <c:include name="libsecret/secret.h"/>
  <namespace name="Secret"
             version="1"
             shared-library="libsecret-1.so.0"
             c:identifier-prefixes="Secret"
             c:symbol-prefixes="secret">
    <constant name="COLLECTION_DEFAULT"
              value="default"
              c:type="SECRET_COLLECTION_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="COLLECTION_SESSION"
              value="session"
              c:type="SECRET_COLLECTION_SESSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="Error" c:type="SecretError">
      <member name="protocol" value="1" c:identifier="SECRET_ERROR_PROTOCOL">
      </member>
      <member name="is_locked" value="2" c:identifier="SECRET_ERROR_IS_LOCKED">
      </member>
      <member name="no_such_object"
              value="3"
              c:identifier="SECRET_ERROR_NO_SUCH_OBJECT">
      </member>
      <member name="already_exists"
              value="4"
              c:identifier="SECRET_ERROR_ALREADY_EXISTS">
      </member>
    </enumeration>
    <record name="Schema"
            c:type="SecretSchema"
            stability="Stable"
            glib:type-name="SecretSchema"
            glib:get-type="secret_schema_get_type"
            c:symbol-prefix="schema">
      <doc xml:space="preserve">Represents a set of attributes that are stored with an item. These schemas
are used for interoperability between various services storing the same types
of items.

Each schema has a name like "org.gnome.keyring.NetworkPassword", and defines
a set of attributes, and types (string, integer, boolean) for those attributes.

Attributes are stored as strings in the Secret Service, and the attribute
types simply define standard ways to store integer and boolean values as strings.
Attributes are represented in libsecret via a #GHashTable with string keys and
values. Even for values that defined as an integer or boolean in the schema,
the attribute values in the #GHashTable are strings. Boolean values are stored
as the strings 'true' and 'false'. Integer values are stored in decimal, with
a preceeding negative sign for negative integers.

Schemas are handled entirely on the client side by this library. The name of the
schema is automatically stored as an attribute on the item.

Normally when looking up passwords only those with matching schema names are
returned. If the schema @flags contain the %SECRET_SCHEMA_DONT_MATCH_NAME flag,
then lookups will not check that the schema name matches that on the item, only
the schema's attributes are matched. This is useful when you are looking up items
that are not stored by the libsecret library. Other libraries such as libgnome-keyring
don't store the schema name.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="SchemaFlags" c:type="SecretSchemaFlags"/>
      </field>
      <field name="attributes" writable="1">
        <array zero-terminated="0"
               c:type="SecretSchemaAttribute"
               fixed-size="32">
          <type name="SchemaAttribute" c:type="SecretSchemaAttribute"/>
        </array>
      </field>
      <field name="reserved" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="reserved1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved7" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="secret_schema_new"
                   shadowed-by="newv"
                   introspectable="0">
        <doc xml:space="preserve">Using this function is not normally necessary from C code.

A schema represents a set of attributes that are stored with an item. These
schemas are used for interoperability between various services storing the
same types of items.

Each schema has an @name like "org.gnome.keyring.NetworkPassword", and
defines a set of attributes names, and types (string, integer, boolean) for
those attributes.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) integers from the
#SecretSchemaAttributeType enumeration, representing the attribute type for
each attribute name. The list of attribtues should be terminated with a %NULL.

Normally when looking up passwords only those with matching schema names are
returned. If the schema @flags contain the %SECRET_SCHEMA_DONT_MATCH_NAME flag,
then lookups will not check that the schema name matches that on the item, only
the schema's attributes are matched. This is useful when you are looking up items
that are not stored by the libsecret library. Other libraries such as libgnome-keyring
don't store the schema name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new schema, which should be unreferenced with secret_schema_unref() when done</doc>
          <type name="Schema" c:type="SecretSchema*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the dotted name of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags for the schema</doc>
            <type name="SchemaFlags" c:type="SecretSchemaFlags"/>
          </parameter>
          <parameter name="arg2" transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv" c:identifier="secret_schema_newv" shadows="new">
        <doc xml:space="preserve">Using this function is not normally necessary from C code. This is useful
for constructing #SecretSchema structures in bindings.

A schema represents a set of attributes that are stored with an item. These
schemas are used for interoperability between various services storing the
same types of items.

Each schema has an @name like "org.gnome.keyring.NetworkPassword", and
defines a set of attributes names, and types (string, integer, boolean) for
those attributes.

Each key in the @attributes table should be a attribute name strings, and
the values in the table should be integers from the #SecretSchemaAttributeType
enumeration, representing the attribute type for each attribute name.

Normally when looking up passwords only those with matching schema names are
returned. If the schema @flags contain the %SECRET_SCHEMA_DONT_MATCH_NAME flag,
then lookups will not check that the schema name matches that on the item, only
the schema's attributes are matched. This is useful when you are looking up items
that are not stored by the libsecret library. Other libraries such as libgnome-keyring
don't store the schema name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new schema, which should be unreferenced with secret_schema_unref() when done</doc>
          <type name="Schema" c:type="SecretSchema*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the dotted name of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the flags for the schema</doc>
            <type name="SchemaFlags" c:type="SecretSchemaFlags"/>
          </parameter>
          <parameter name="attribute_names_and_types"
                     transfer-ownership="none">
            <doc xml:space="preserve">the attribute names and types of those attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="SchemaAttributeType"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <method name="ref" c:identifier="secret_schema_ref">
        <doc xml:space="preserve">Adds a reference to the #SecretSchema.

It is not normally necessary to call this function from C code, and is
mainly present for the sake of bindings. If the @schema was statically
allocated, then this function will copy the schema.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the referenced schema, which should be later unreferenced with secret_schema_unref()</doc>
          <type name="Schema" c:type="SecretSchema*"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">the schema to reference</doc>
            <type name="Schema" c:type="SecretSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="secret_schema_unref">
        <doc xml:space="preserve">Releases a reference to the #SecretSchema. If the last reference is
released then the schema will be freed.

It is not normally necessary to call this function from C code, and is
mainly present for the sake of bindings. It is an error to call this for
a @schema that was statically allocated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve">the schema to reference</doc>
            <type name="Schema" c:type="SecretSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="SchemaAttribute"
            c:type="SecretSchemaAttribute"
            glib:type-name="SecretSchemaAttribute"
            glib:get-type="secret_schema_attribute_get_type"
            c:symbol-prefix="schema_attribute">
      <doc xml:space="preserve">An attribute in a #SecretSchema.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="type" writable="1">
        <type name="SchemaAttributeType" c:type="SecretSchemaAttributeType"/>
      </field>
    </record>
    <enumeration name="SchemaAttributeType" c:type="SecretSchemaAttributeType">
      <doc xml:space="preserve">The type of an attribute in a #SecretSchema. Attributes are stored as strings
in the Secret Service, and the attribute types simply define standard ways
to store integer and boolean values as strings.</doc>
      <member name="string"
              value="0"
              c:identifier="SECRET_SCHEMA_ATTRIBUTE_STRING">
        <doc xml:space="preserve">a utf-8 string attribute</doc>
      </member>
      <member name="integer"
              value="1"
              c:identifier="SECRET_SCHEMA_ATTRIBUTE_INTEGER">
        <doc xml:space="preserve">an integer attribute, stored as a decimal</doc>
      </member>
      <member name="boolean"
              value="2"
              c:identifier="SECRET_SCHEMA_ATTRIBUTE_BOOLEAN">
        <doc xml:space="preserve">a boolean attribute, stored as 'true' or 'false'</doc>
      </member>
    </enumeration>
    <bitfield name="SchemaFlags" c:type="SecretSchemaFlags">
      <doc xml:space="preserve">Flags for a #SecretSchema definition.</doc>
      <member name="none" value="0" c:identifier="SECRET_SCHEMA_NONE">
        <doc xml:space="preserve">no flags for the schema</doc>
      </member>
      <member name="dont_match_name"
              value="2"
              c:identifier="SECRET_SCHEMA_DONT_MATCH_NAME">
        <doc xml:space="preserve">don't match the schema name when looking up or removing passwords</doc>
      </member>
    </bitfield>
    <function name="attributes_build"
              c:identifier="secret_attributes_build"
              introspectable="0">
      <doc xml:space="preserve">Build up a hash table of attribute values.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attribtues should be terminated with a %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new table of attributes, to be released with g_hash_table_unref()</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="arg1" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="attributes_buildv"
              c:identifier="secret_attributes_buildv"
              introspectable="0">
      <doc xml:space="preserve">Build up a hash table of attribute values.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attribtues should be terminated with a %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new table of attributes, to be released with g_hash_table_unref()</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="va" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values, terminated with %NULL</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_get_quark" c:identifier="secret_error_get_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="password_clear"
              c:identifier="secret_password_clear"
              shadowed-by="password_clearv"
              introspectable="0">
      <doc xml:space="preserve">Clear unlocked matching passwords from the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attribtues should be terminated with a %NULL.

All unlocked items that match the attributes will be deleted.

This method will return immediately and complete asynchronously.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:space="preserve">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="arg4" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="password_clear_finish"
              c:identifier="secret_password_clear_finish"
              throws="1">
      <doc xml:space="preserve">Finish an asynchronous operation to remove passwords from the secret
service.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether any passwords were removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_clear_sync"
              c:identifier="secret_password_clear_sync"
              shadowed-by="password_clearv_sync"
              introspectable="0">
      <doc xml:space="preserve">Remove unlocked matching passwords from the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attribtues should be terminated with a %NULL.

All unlocked items that match the attributes will be deleted.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the any passwords were removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="arg3" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="password_clearv"
              c:identifier="secret_password_clearv"
              shadows="password_clear">
      <doc xml:space="preserve">Remove unlocked matching passwords from the secret service.

The @attributes should be a set of key and value string pairs.

All unlocked items that match the attributes will be deleted.

This method will return immediately and complete asynchronously.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="4">
          <doc xml:space="preserve">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_clearv_sync"
              c:identifier="secret_password_clearv_sync"
              shadows="password_clear_sync"
              throws="1">
      <doc xml:space="preserve">Remove unlocked matching passwords from the secret service.

The @attributes should be a set of key and value string pairs.

All unlocked items that match the attributes will be deleted.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether any passwords were removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_free"
              c:identifier="secret_password_free"
              introspectable="0">
      <doc xml:space="preserve">Clear the memory used by a password, and then free it.

This function must be used to free nonpageable memory returned by
secret_password_lookup_nonpageable_finish(),
secret_password_lookup_nonpageable_sync() or
secret_password_lookupv_nonpageable_sync().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="password" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">password to free</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup"
              c:identifier="secret_password_lookup"
              shadowed-by="password_lookupv"
              introspectable="0">
      <doc xml:space="preserve">Lookup a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attribtues should be terminated with a %NULL.

If no secret is found then %NULL is returned.

This method will return immediately and complete asynchronously.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:space="preserve">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="arg4" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_finish"
              c:identifier="secret_password_lookup_finish"
              throws="1">
      <doc xml:space="preserve">Finish an asynchronous operation to lookup a password in the secret service.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new password string which should be freed with secret_password_free() or may be freed with g_free() when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_nonpageable_finish"
              c:identifier="secret_password_lookup_nonpageable_finish"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Finish an asynchronous operation to lookup a password in the secret service.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new password string stored in nonpageable memory which must be freed with secret_password_free() when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_nonpageable_sync"
              c:identifier="secret_password_lookup_nonpageable_sync"
              introspectable="0">
      <doc xml:space="preserve">Lookup a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attribtues should be terminated with a %NULL.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new password string stored in nonpageable memory which must be freed with secret_password_free() when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="arg3" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_sync"
              c:identifier="secret_password_lookup_sync"
              shadowed-by="password_lookupv_sync"
              introspectable="0">
      <doc xml:space="preserve">Lookup a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attribtues should be terminated with a %NULL.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new password string which should be freed with secret_password_free() or may be freed with g_free() when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="arg3" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookupv"
              c:identifier="secret_password_lookupv"
              shadows="password_lookup">
      <doc xml:space="preserve">Lookup a password in the secret service.

The @attributes should be a set of key and value string pairs.

If no secret is found then %NULL is returned.

This method will return immediately and complete asynchronously.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="4">
          <doc xml:space="preserve">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookupv_nonpageable_sync"
              c:identifier="secret_password_lookupv_nonpageable_sync"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Lookup a password in the secret service.

The @attributes should be a set of key and value string pairs.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new password string stored in non pageable memory which should be freed with secret_password_free() when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookupv_sync"
              c:identifier="secret_password_lookupv_sync"
              shadows="password_lookup_sync"
              throws="1">
      <doc xml:space="preserve">Lookup a password in the secret service.

The @attributes should be a set of key and value string pairs.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new password string which should be freed with secret_password_free() or may be freed with g_free() when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_store"
              c:identifier="secret_password_store"
              shadowed-by="password_storev"
              introspectable="0">
      <doc xml:space="preserve">Store a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the @schema.
The list of attribtues should be terminated with a %NULL.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use #SECRET_COLLECTION_SESSION to store the password in the session
collection, which doesn't get stored across login sessions.

This method will return immediately and complete asynchronously.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="collection" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">a collection alias, or D-Bus object path of the collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="6">
          <doc xml:space="preserve">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="arg7" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="password_store_finish"
              c:identifier="secret_password_store_finish"
              throws="1">
      <doc xml:space="preserve">Finish asynchronous operation to store a password in the secret service.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_store_sync"
              c:identifier="secret_password_store_sync"
              shadowed-by="password_storev_sync"
              introspectable="0">
      <doc xml:space="preserve">Store a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the @schema.
The list of attribtues should be terminated with a %NULL.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use #SECRET_COLLECTION_SESSION to store the password in the session
collection, which doesn't get stored across login sessions.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="collection" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">a collection alias, or D-Bus object path of the collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="arg6" transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="password_storev"
              c:identifier="secret_password_storev"
              shadows="password_store">
      <doc xml:space="preserve">Store a password in the secret service.

The @attributes should be a set of key and value string pairs.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use #SECRET_COLLECTION_SESSION to store the password in the session
collection, which doesn't get stored across login sessions.

This method will return immediately and complete asynchronously.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="collection" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">a collection alias, or D-Bus object path of the collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="7">
          <doc xml:space="preserve">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_storev_sync"
              c:identifier="secret_password_storev_sync"
              shadows="password_store_sync"
              throws="1">
      <doc xml:space="preserve">Store a password in the secret service.

The @attributes should be a set of key and value string pairs.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use #SECRET_COLLECTION_SESSION to store the password in the session
collection, which doesn't get stored across login sessions.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="collection" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">a collection alias, or D-Bus object path of the collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_wipe" c:identifier="secret_password_wipe">
      <doc xml:space="preserve">Clear the memory used by a password.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="password" transfer-ownership="none" allow-none="1">
          <doc xml:space="preserve">password to clear</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
