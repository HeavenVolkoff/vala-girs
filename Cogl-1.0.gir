<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GL" version="1.0"/>
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <package name="cogl-1.0"/>
  <c:include name="cogl/cogl.h"/>
  <namespace name="Cogl"
             version="1.0"
             shared-library="libcogl.so.6"
             c:identifier-prefixes="Cogl"
             c:symbol-prefixes="cogl">
    <alias name="Angle" c:type="CoglAngle">
      <doc xml:whitespace="preserve">Integer representation of an angle such that 1024 corresponds to
full circle (i.e., 2 * pi).</doc>
      <type name="gint32" c:type="gint32"/>
    </alias>
    <alias name="Handle" c:type="CoglHandle">
      <doc xml:whitespace="preserve">Type used for storing references to cogl objects, the CoglHandle is
a fully opaque type without any public data members.</doc>
      <type name="gpointer" c:type="gpointer"/>
    </alias>
    <constant name="AFIRST_BIT" value="64" c:type="COGL_AFIRST_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="A_BIT" value="16" c:type="COGL_A_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Attribute" c:type="CoglAttribute" disguised="1">
      <method name="get_buffer"
              c:identifier="cogl_attribute_get_buffer"
              version="1.10"
              introspectable="0">
        <doc xml:whitespace="preserve">cogl_attribute_set_buffer() or cogl_attribute_new().</doc>
        <return-value>
          <doc xml:whitespace="preserve">the #CoglAttributeBuffer that was set with</doc>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
      </method>
      <method name="get_normalized"
              c:identifier="cogl_attribute_get_normalized"
              version="1.10">
        <doc xml:whitespace="preserve">cogl_attribute_set_normalized().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the normalized property set with</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_buffer"
              c:identifier="cogl_attribute_set_buffer"
              version="1.10">
        <doc xml:whitespace="preserve">Sets a new #CoglAttributeBuffer for the attribute.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute_buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglAttributeBuffer</doc>
            <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_normalized"
              c:identifier="cogl_attribute_set_normalized"
              version="1.10">
        <doc xml:whitespace="preserve">Sets whether fixed point attribute types are mapped to the range
0→1. For example when this property is TRUE and a
%COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE type is used then the value 255
will be mapped to 1.0.

The default value of this property depends on the name of the
attribute. For the builtin properties cogl_color_in and
cogl_normal_in it will default to TRUE and for all other names it
will default to FALSE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="normalized" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value for the normalized property.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="cogl_attribute_new"
                version="1.4"
                introspectable="0">
        <doc xml:whitespace="preserve">Describes the layout for a list of vertex attribute values (For
example, a list of texture coordinates or colors).

The @name is used to access the attribute inside a GLSL vertex
shader and there are some special names you should use if they are
applicable:
&lt;itemizedlist&gt;
&lt;listitem&gt;"cogl_position_in" (used for vertex positions)&lt;/listitem&gt;
&lt;listitem&gt;"cogl_color_in" (used for vertex colors)&lt;/listitem&gt;
&lt;listitem&gt;"cogl_tex_coord0_in", "cogl_tex_coord1", ...
(used for vertex texture coordinates)&lt;/listitem&gt;
&lt;listitem&gt;"cogl_normal_in" (used for vertex normals)&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The attribute values corresponding to different vertices can either
be tightly packed or interleaved with other attribute values. For
example it's common to define a structure for a single vertex like:
|[
typedef struct
{
float x, y, z; /&lt;!-- --&gt;* position attribute *&lt;!-- --&gt;/
float s, t; /&lt;!-- --&gt;* texture coordinate attribute *&lt;!-- --&gt;/
} MyVertex;
]|

And then create an array of vertex data something like:
|[
MyVertex vertices[100] = { .... }
]|

In this case, to describe either the position or texture coordinate
attribute you have to move &lt;pre&gt;sizeof (MyVertex)&lt;/pre&gt; bytes to
move from one vertex to the next.  This is called the attribute
@stride. If you weren't interleving attributes and you instead had
a packed array of float x, y pairs then the attribute stride would
be &lt;pre&gt;(2 * sizeof (float))&lt;/pre&gt;. So the @stride is the number of
bytes to move to find the attribute value of the next vertex.

Normally a list of attributes starts at the beginning of an array.
So for the &lt;pre&gt;MyVertex&lt;/pre&gt; example above the @offset is the
offset inside the &lt;pre&gt;MyVertex&lt;/pre&gt; structure to the first
component of the attribute. For the texture coordinate attribute
the offset would be &lt;pre&gt;offsetof (MyVertex, s)&lt;/pre&gt; or instead of
using the offsetof macro you could use &lt;pre&gt;sizeof (float) * 3&lt;/pre&gt;.
If you've divided your @array into blocks of non-interleved
attributes then you will need to calculate the @offset as the
number of bytes in blocks preceding the attribute you're
describing.

An attribute often has more than one component. For example a color
is often comprised of 4 red, green, blue and alpha @components, and a
position may be comprised of 2 x and y @components. You should aim
to keep the number of components to a minimum as more components
means more data needs to be mapped into the GPU which can be a
bottlneck when dealing with a large number of vertices.

Finally you need to specify the component data type. Here you
should aim to use the smallest type that meets your precision
requirements. Again the larger the type then more data needs to be
mapped into the GPU which can be a bottlneck when dealing with
a large number of vertices.

layout for a list of attribute values stored in @array.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglAttribute describing the</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attribute_buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #CoglAttributeBuffer containing the actual attribute data</doc>
            <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="stride" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of bytes to jump to get to the next attribute value for the next vertex. (Usually &lt;pre&gt;sizeof (MyVertex)&lt;/pre&gt;)</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset from the start of @attribute_buffer for the first attribute value. (Usually &lt;pre&gt;offsetof (MyVertex, component0)&lt;/pre&gt;</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="components" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of components (e.g. 4 for an rgba color or 3 for and (x,y,z) position)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">FIXME</doc>
            <type name="AttributeType" c:type="CoglAttributeType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="AttributeBuffer" c:type="CoglAttributeBuffer" disguised="1">
      <function name="new"
                c:identifier="cogl_attribute_buffer_new"
                version="1.4"
                introspectable="0">
        <doc xml:whitespace="preserve">Declares a new #CoglAttributeBuffer of @size bytes to contain arrays of vertex
attribute data. Once declared, data can be set using cogl_buffer_set_data()
or by mapping it into the application's address space using cogl_buffer_map().

If @data isn't %NULL then @size bytes will be read from @data and
immediately copied into the new buffer.</doc>
        <return-value>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An optional pointer to vertex data to upload immediately.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="AttributeType"
                 version="1.0"
                 glib:type-name="CoglAttributeType"
                 glib:get-type="cogl_attribute_type_get_type"
                 c:type="CoglAttributeType">
      <doc xml:whitespace="preserve">Data types for the components of a vertex attribute.</doc>
      <member name="byte"
              value="5120"
              c:identifier="COGL_ATTRIBUTE_TYPE_BYTE"
              glib:nick="byte"/>
      <member name="unsigned_byte"
              value="5121"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE"
              glib:nick="unsigned-byte"/>
      <member name="short"
              value="5122"
              c:identifier="COGL_ATTRIBUTE_TYPE_SHORT"
              glib:nick="short"/>
      <member name="unsigned_short"
              value="5123"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT"
              glib:nick="unsigned-short"/>
      <member name="float"
              value="5126"
              c:identifier="COGL_ATTRIBUTE_TYPE_FLOAT"
              glib:nick="float"/>
    </enumeration>
    <constant name="BGR_BIT" value="32" c:type="COGL_BGR_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Bitmap" c:type="CoglBitmap" disguised="1">
      <function name="get_size_from_file"
                c:identifier="cogl_bitmap_get_size_from_file"
                version="1.0">
        <doc xml:whitespace="preserve">Parses an image file enough to extract the width and height
of the bitmap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the image was successfully parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the file to check</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the bitmap width, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the bitmap height, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_file"
                c:identifier="cogl_bitmap_new_from_file"
                version="1.0"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Loads an image file from disk. This function can be safely called from
within a thread.

%NULL if loading the image failed.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #CoglBitmap to the new loaded image data, or</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the file to load.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="BitmapError"
                 version="1.4"
                 glib:type-name="CoglBitmapError"
                 glib:get-type="cogl_bitmap_error_get_type"
                 c:type="CoglBitmapError"
                 glib:error-domain="cogl-bitmap-error-quark">
      <doc xml:whitespace="preserve">Error codes that can be thrown when performing bitmap
operations. Note that gdk_pixbuf_new_from_file() can also throw
errors directly from the underlying image loading library. For
example, if GdkPixbuf is used then errors #GdkPixbufError&lt;!-- --&gt;s
will be used directly.</doc>
      <member name="failed"
              value="0"
              c:identifier="COGL_BITMAP_ERROR_FAILED"
              glib:nick="failed"/>
      <member name="unknown_type"
              value="1"
              c:identifier="COGL_BITMAP_ERROR_UNKNOWN_TYPE"
              glib:nick="unknown-type"/>
      <member name="corrupt_image"
              value="2"
              c:identifier="COGL_BITMAP_ERROR_CORRUPT_IMAGE"
              glib:nick="corrupt-image"/>
      <function name="quark" c:identifier="cogl_bitmap_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="BlendStringError"
                 version="1.0"
                 glib:type-name="CoglBlendStringError"
                 glib:get-type="cogl_blend_string_error_get_type"
                 c:type="CoglBlendStringError"
                 glib:error-domain="cogl-blend-string-error-quark">
      <doc xml:whitespace="preserve">Error enumeration for the blend strings parser</doc>
      <member name="parse_error"
              value="0"
              c:identifier="COGL_BLEND_STRING_ERROR_PARSE_ERROR"
              glib:nick="parse-error"/>
      <member name="argument_parse_error"
              value="1"
              c:identifier="COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR"
              glib:nick="argument-parse-error"/>
      <member name="invalid_error"
              value="2"
              c:identifier="COGL_BLEND_STRING_ERROR_INVALID_ERROR"
              glib:nick="invalid-error"/>
      <member name="gpu_unsupported_error"
              value="3"
              c:identifier="COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR"
              glib:nick="gpu-unsupported-error"/>
      <function name="quark" c:identifier="cogl_blend_string_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="Buffer" c:type="CoglBuffer" disguised="1">
      <method name="get_size"
              c:identifier="cogl_buffer_get_size"
              version="1.2">
        <doc xml:whitespace="preserve">Retrieves the size of buffer</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the buffer in bytes</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
      </method>
      <method name="get_update_hint"
              c:identifier="cogl_buffer_get_update_hint"
              version="1.2">
        <doc xml:whitespace="preserve">Retrieves the update hints set using cogl_buffer_set_update_hint()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #CoglBufferUpdateHint currently used by the buffer</doc>
          <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
        </return-value>
      </method>
      <method name="map"
              c:identifier="cogl_buffer_map"
              version="1.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Maps the buffer into the application address space for direct access.

It is strongly recommended that you pass
%COGL_BUFFER_MAP_HINT_DISCARD as a hint if you are going to replace
all the buffer's data. This way if the buffer is currently being
used by the GPU then the driver won't have to stall the CPU and
wait for the hardware to finish because it can instead allocate a
new buffer to map.

The behaviour is undefined if you access the buffer in a way
conflicting with the @access mask you pass. It is also an error to
release your last reference while the buffer is mapped.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A pointer to the mapped memory or %NULL is the call fails</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="access" transfer-ownership="none">
            <doc xml:whitespace="preserve">how the mapped buffer will be used by the application</doc>
            <type name="BufferAccess" c:type="CoglBufferAccess"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:whitespace="preserve">A mask of #CoglBufferMapHint&lt;!-- --&gt;s that tell Cogl how the data will be modified once mapped.</doc>
            <type name="BufferMapHint" c:type="CoglBufferMapHint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data"
              c:identifier="cogl_buffer_set_data"
              version="1.2">
        <doc xml:whitespace="preserve">Updates part of the buffer with new data from @data. Where to put this new
data is controlled by @offset and @offset + @data should be less than the
buffer size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE is the operation succeeded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">destination offset (in bytes) in the buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the data to be copied into the buffer</doc>
            <array length="2" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of bytes to copy</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_update_hint"
              c:identifier="cogl_buffer_set_update_hint"
              version="1.2">
        <doc xml:whitespace="preserve">Sets the update hint on a buffer. See #CoglBufferUpdateHint for a description
of the available hints.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new hint</doc>
            <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmap" c:identifier="cogl_buffer_unmap" version="1.2">
        <doc xml:whitespace="preserve">Unmaps a buffer previously mapped by cogl_buffer_map().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="BufferAccess"
              version="1.2"
              glib:type-name="CoglBufferAccess"
              glib:get-type="cogl_buffer_access_get_type"
              c:type="CoglBufferAccess">
      <doc xml:whitespace="preserve">The access hints for cogl_buffer_set_update_hint()</doc>
      <member name="read"
              value="1"
              c:identifier="COGL_BUFFER_ACCESS_READ"
              glib:nick="read"/>
      <member name="write"
              value="2"
              c:identifier="COGL_BUFFER_ACCESS_WRITE"
              glib:nick="write"/>
      <member name="read_write"
              value="3"
              c:identifier="COGL_BUFFER_ACCESS_READ_WRITE"
              glib:nick="read-write"/>
    </bitfield>
    <bitfield name="BufferBit"
              version="1.0"
              glib:type-name="CoglBufferBit"
              glib:get-type="cogl_buffer_bit_get_type"
              c:type="CoglBufferBit">
      <doc xml:whitespace="preserve">Types of auxiliary buffers</doc>
      <member name="color"
              value="1"
              c:identifier="COGL_BUFFER_BIT_COLOR"
              glib:nick="color"/>
      <member name="depth"
              value="2"
              c:identifier="COGL_BUFFER_BIT_DEPTH"
              glib:nick="depth"/>
      <member name="stencil"
              value="4"
              c:identifier="COGL_BUFFER_BIT_STENCIL"
              glib:nick="stencil"/>
    </bitfield>
    <bitfield name="BufferMapHint"
              version="1.4"
              glib:type-name="CoglBufferMapHint"
              glib:get-type="cogl_buffer_map_hint_get_type"
              c:type="CoglBufferMapHint">
      <doc xml:whitespace="preserve">Hints to Cogl about how you are planning to modify the data once it
is mapped.</doc>
      <member name="discard"
              value="1"
              c:identifier="COGL_BUFFER_MAP_HINT_DISCARD"
              glib:nick="discard"/>
    </bitfield>
    <bitfield name="BufferTarget"
              version="0.8"
              glib:type-name="CoglBufferTarget"
              glib:get-type="cogl_buffer_target_get_type"
              c:type="CoglBufferTarget">
      <doc xml:whitespace="preserve">Target flags for FBOs.</doc>
      <member name="window_buffer"
              value="2"
              c:identifier="COGL_WINDOW_BUFFER"
              glib:nick="window-buffer"/>
      <member name="offscreen_buffer"
              value="4"
              c:identifier="COGL_OFFSCREEN_BUFFER"
              glib:nick="offscreen-buffer"/>
    </bitfield>
    <enumeration name="BufferUpdateHint"
                 version="1.2"
                 glib:type-name="CoglBufferUpdateHint"
                 glib:get-type="cogl_buffer_update_hint_get_type"
                 c:type="CoglBufferUpdateHint">
      <doc xml:whitespace="preserve">The update hint on a buffer allows the user to give some detail on how often
the buffer data is going to be updated.</doc>
      <member name="static"
              value="0"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STATIC"
              glib:nick="static"/>
      <member name="dynamic"
              value="1"
              c:identifier="COGL_BUFFER_UPDATE_HINT_DYNAMIC"
              glib:nick="dynamic"/>
      <member name="stream"
              value="2"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STREAM"
              glib:nick="stream"/>
    </enumeration>
    <record name="Color" c:type="CoglColor" version="1.0">
      <doc xml:whitespace="preserve">A structure for holding a color definition. The contents of
the CoglColor structure are private and should never by accessed
directly.</doc>
      <field name="red" readable="0" private="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="green" readable="0" private="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="blue" readable="0" private="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="alpha" readable="0" private="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="padding0" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding1" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding2" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <method name="copy"
              c:identifier="cogl_color_copy"
              version="1.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a copy of @color

to free the allocate resources</doc>
        <return-value>
          <doc xml:whitespace="preserve">a newly-allocated #CoglColor. Use cogl_color_free()</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="cogl_color_free" version="1.0">
        <doc xml:whitespace="preserve">Frees the resources allocated by cogl_color_new() and cogl_color_copy()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_alpha"
              c:identifier="cogl_color_get_alpha"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the alpha channel of @color as a fixed point
value between 0 and %1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_alpha_byte"
              c:identifier="cogl_color_get_alpha_byte"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the alpha channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the alpha channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_alpha_float"
              c:identifier="cogl_color_get_alpha_float"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the alpha channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_blue" c:identifier="cogl_color_get_blue" version="1.0">
        <doc xml:whitespace="preserve">Retrieves the blue channel of @color as a fixed point
value between 0 and %1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_blue_byte"
              c:identifier="cogl_color_get_blue_byte"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the blue channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the blue channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_blue_float"
              c:identifier="cogl_color_get_blue_float"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the blue channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_green"
              c:identifier="cogl_color_get_green"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the green channel of @color as a fixed point
value between 0 and %1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_green_byte"
              c:identifier="cogl_color_get_green_byte"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the green channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the green channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_green_float"
              c:identifier="cogl_color_get_green_float"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the green channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_red" c:identifier="cogl_color_get_red" version="1.0">
        <doc xml:whitespace="preserve">Retrieves the red channel of @color as a fixed point
value between 0 and %1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_red_byte"
              c:identifier="cogl_color_get_red_byte"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the red channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the red channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
      </method>
      <method name="get_red_float"
              c:identifier="cogl_color_get_red_float"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the red channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="init_from_4f"
              c:identifier="cogl_color_init_from_4f"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the values of the passed channels into a #CoglColor</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the red channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the green channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the blue channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the alpha channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4fv"
              c:identifier="cogl_color_init_from_4fv"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the values of the passed channels into a #CoglColor</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color_array" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to an array of 4 float color components</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4ub"
              c:identifier="cogl_color_init_from_4ub"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the values of the passed channels into a #CoglColor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="premultiply"
              c:identifier="cogl_color_premultiply"
              version="1.0">
        <doc xml:whitespace="preserve">Converts a non-premultiplied color to a pre-multiplied color. For
example, semi-transparent red is (1.0, 0, 0, 0.5) when non-premultiplied
and (0.5, 0, 0, 0.5) when premultiplied.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_alpha"
              c:identifier="cogl_color_set_alpha"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the alpha channel of @color to @alpha.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_byte"
              c:identifier="cogl_color_set_alpha_byte"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the alpha channel of @color to @alpha.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_float"
              c:identifier="cogl_color_set_alpha_float"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the alpha channel of @color to @alpha.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue" c:identifier="cogl_color_set_blue" version="1.4">
        <doc xml:whitespace="preserve">Sets the blue channel of @color to @blue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_byte"
              c:identifier="cogl_color_set_blue_byte"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the blue channel of @color to @blue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_float"
              c:identifier="cogl_color_set_blue_float"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the blue channel of @color to @blue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4f"
              c:identifier="cogl_color_set_from_4f"
              version="1.0"
              deprecated="Use cogl_color_init_from_4f instead."
              deprecated-version="1.4">
        <doc xml:whitespace="preserve">Sets the values of the passed channels into a #CoglColor</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the red channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the green channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the blue channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the alpha channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4ub"
              c:identifier="cogl_color_set_from_4ub"
              version="1.0"
              deprecated="Use cogl_color_init_from_4ub instead."
              deprecated-version="1.4">
        <doc xml:whitespace="preserve">Sets the values of the passed channels into a #CoglColor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green"
              c:identifier="cogl_color_set_green"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the green channel of @color to @green.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_byte"
              c:identifier="cogl_color_set_green_byte"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the green channel of @color to @green.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_float"
              c:identifier="cogl_color_set_green_float"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the green channel of @color to @green.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red" c:identifier="cogl_color_set_red" version="1.4">
        <doc xml:whitespace="preserve">Sets the red channel of @color to @red.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_byte"
              c:identifier="cogl_color_set_red_byte"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the red channel of @color to @red.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_float"
              c:identifier="cogl_color_set_red_float"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the red channel of @color to @red.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpremultiply"
              c:identifier="cogl_color_unpremultiply"
              version="1.4">
        <doc xml:whitespace="preserve">Converts a pre-multiplied color to a non-premultiplied color. For
example, semi-transparent red is (0.5, 0, 0, 0.5) when premultiplied
and (1.0, 0, 0, 0.5) when non-premultiplied.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <function name="equal" c:identifier="cogl_color_equal" version="1.0">
        <doc xml:whitespace="preserve">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the two colors are the same.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglColor</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglColor</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new"
                c:identifier="cogl_color_new"
                version="1.0"
                introspectable="0">
        <doc xml:whitespace="preserve">Creates a new (empty) color

to free the allocated resources</doc>
        <return-value>
          <doc xml:whitespace="preserve">a newly-allocated #CoglColor. Use cogl_color_free()</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </function>
    </record>
    <bitfield name="ColorMask"
              glib:type-name="CoglColorMask"
              glib:get-type="cogl_color_mask_get_type"
              c:type="CoglColorMask">
      <doc xml:whitespace="preserve">Defines a bit mask of color channels. This can be used with
cogl_pipeline_set_color_mask() for example to define which color
channels should be written to the current framebuffer when
drawing something.</doc>
      <member name="none"
              value="0"
              c:identifier="COGL_COLOR_MASK_NONE"
              glib:nick="none"/>
      <member name="red"
              value="1"
              c:identifier="COGL_COLOR_MASK_RED"
              glib:nick="red"/>
      <member name="green"
              value="2"
              c:identifier="COGL_COLOR_MASK_GREEN"
              glib:nick="green"/>
      <member name="blue"
              value="4"
              c:identifier="COGL_COLOR_MASK_BLUE"
              glib:nick="blue"/>
      <member name="alpha"
              value="8"
              c:identifier="COGL_COLOR_MASK_ALPHA"
              glib:nick="alpha"/>
      <member name="all"
              value="15"
              c:identifier="COGL_COLOR_MASK_ALL"
              glib:nick="all"/>
    </bitfield>
    <callback name="DebugObjectForeachTypeCallback"
              c:type="CoglDebugObjectForeachTypeCallback"
              version="1.8">
      <doc xml:whitespace="preserve">A callback function to use for cogl_debug_object_foreach_type().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to a struct containing information about the type.</doc>
          <type name="DebugObjectTypeInfo" c:type="CoglDebugObjectTypeInfo*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DebugObjectTypeInfo"
            c:type="CoglDebugObjectTypeInfo"
            version="1.8">
      <doc xml:whitespace="preserve">This struct is used to pass information to the callback when
cogl_debug_object_foreach_type() is called.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="instance_count" writable="1">
        <type name="guint" c:type="unsigned"/>
      </field>
    </record>
    <record name="DepthState" c:type="CoglDepthState">
      <field name="magic" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="test_enabled" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="test_function" writable="1">
        <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
      </field>
      <field name="write_enabled" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="range_near" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="range_far" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding0" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding1" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding2" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding3" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding4" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding5" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding6" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding7" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding8" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding9" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <method name="get_range"
              c:identifier="cogl_depth_state_get_range"
              version="2.0">
        <doc xml:whitespace="preserve">Gets the current range to which normalized depth values are mapped
before writing to the depth buffer. This corresponds to the range
set with cogl_pipeline_set_depth_range().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="near_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to store the near component of the depth range</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="far_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to store the far component of the depth range</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_test_enabled"
              c:identifier="cogl_depth_state_get_test_enabled"
              version="2.0">
        <doc xml:whitespace="preserve">Gets the current depth test enabled state as previously set by
cogl_depth_state_set_test_enabled().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The pipeline's current depth test enabled state.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_test_function"
              c:identifier="cogl_depth_state_get_test_function"
              version="2.0">
        <doc xml:whitespace="preserve">Gets the current depth test enable state as previously set via
cogl_pipeline_set_depth_test_enabled().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current depth test enable state.</doc>
          <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
        </return-value>
      </method>
      <method name="get_write_enabled"
              c:identifier="cogl_depth_state_get_write_enabled"
              version="2.0">
        <doc xml:whitespace="preserve">Gets the depth writing enable state as set by the corresponding
cogl_pipeline_set_depth_writing_enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current depth writing enable state</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="init" c:identifier="cogl_depth_state_init" version="2.0">
        <doc xml:whitespace="preserve">Initializes the members of @state to their default values.

You should never pass an un initialized #CoglDepthState structure
to cogl_pipeline_set_depth_state().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_range"
              c:identifier="cogl_depth_state_set_range"
              version="2.0">
        <doc xml:whitespace="preserve">Sets the range to map depth values in normalized device coordinates
to before writing out to a depth buffer.

After your geometry has be transformed, clipped and had perspective
division applied placing it in normalized device
coordinates all depth values between the near and far z clipping
planes are in the range -1 to 1. Before writing any depth value to
the depth buffer though the value is mapped into the range [0, 1].

With this function you can change the range which depth values are
mapped too although the range must still lye within the range [0,
1].

If your driver does not support this feature (for example you are
using GLES 1 drivers) then if you don't use the default range
values you will get an error reported when calling
cogl_pipeline_set_depth_state (). You can check ahead of time for
the %COGL_FEATURE_ID_DEPTH_RANGE feature with
cogl_has_feature() to know if this function will succeed.

By default normalized device coordinate depth values are mapped to
the full range of depth buffer values, [0, 1].

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="near_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">The near component of the desired depth range which will be clamped to the range [0, 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">The far component of the desired depth range which will be clamped to the range [0, 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_test_enabled"
              c:identifier="cogl_depth_state_set_test_enabled"
              version="2.0">
        <doc xml:whitespace="preserve">Enables or disables depth testing according to the value of
@enable.

If depth testing is enable then the #CoglDepthTestFunction set
using cogl_pipeline_set_depth_test_function() us used to evaluate
the depth value of incoming fragments against the corresponding
value stored in the current depth buffer, and if the test passes
then the fragments depth value is used to update the depth buffer.
(unless you have disabled depth writing via
cogl_pipeline_set_depth_writing_enabled ())

By default depth testing is disabled.

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:whitespace="preserve">The enable state you want</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_test_function"
              c:identifier="cogl_depth_state_set_test_function"
              version="2.0">
        <doc xml:whitespace="preserve">Sets the #CoglDepthTestFunction used to compare the depth value of
an incoming fragment against the corresponding value in the current
depth buffer.

By default the depth test function is %COGL_DEPTH_TEST_FUNCTION_LESS

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #CoglDepthTestFunction to set</doc>
            <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_write_enabled"
              c:identifier="cogl_depth_state_set_write_enabled"
              version="2.0">
        <doc xml:whitespace="preserve">Enables or disables depth buffer writing according to the value of
@enable. Normally when depth testing is enabled and the comparison
between a fragment's depth value and the corresponding depth buffer
value passes then the fragment's depth is written to the depth
buffer unless writing is disabled here.

By default depth writing is enabled

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:whitespace="preserve">The enable state you want</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DepthTestFunction"
                 glib:type-name="CoglDepthTestFunction"
                 glib:get-type="cogl_depth_test_function_get_type"
                 c:type="CoglDepthTestFunction">
      <doc xml:whitespace="preserve">When using depth testing one of these functions is used to compare
the depth of an incoming fragment against the depth value currently
stored in the depth buffer. The function is changed using
cogl_material_set_depth_test_function().

The test is only done when depth testing is explicitly enabled. (See
cogl_material_set_depth_test_enabled())</doc>
      <member name="never"
              value="512"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NEVER"
              glib:nick="never"/>
      <member name="less"
              value="513"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LESS"
              glib:nick="less"/>
      <member name="equal"
              value="514"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_EQUAL"
              glib:nick="equal"/>
      <member name="lequal"
              value="515"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LEQUAL"
              glib:nick="lequal"/>
      <member name="greater"
              value="516"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GREATER"
              glib:nick="greater"/>
      <member name="notequal"
              value="517"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL"
              glib:nick="notequal"/>
      <member name="gequal"
              value="518"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GEQUAL"
              glib:nick="gequal"/>
      <member name="always"
              value="519"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_ALWAYS"
              glib:nick="always"/>
    </enumeration>
    <enumeration name="Error"
                 version="1.4"
                 glib:type-name="CoglError"
                 glib:get-type="cogl_error_get_type"
                 c:type="CoglError">
      <doc xml:whitespace="preserve">Error enumeration for Cogl

The @COGL_ERROR_UNSUPPORTED error can be thrown for a variety of
reasons. For example:

&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;You've tried to use a feature that is not
advertised by cogl_get_features(). This could happen if you create
a 2d texture with a non-power-of-two size when
%COGL_FEATURE_TEXTURE_NPOT is not advertised.&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;The GPU can not handle the configuration you have
requested. An example might be if you try to use too many texture
layers in a single #CoglPipeline&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;The driver does not support some
configuration.&lt;/para&gt;&lt;/listiem&gt;
&lt;/itemizedlist&gt;

Currently this is only used by Cogl API marked as experimental so
this enum should also be considered experimental.</doc>
      <member name="unsupported"
              value="0"
              c:identifier="COGL_ERROR_UNSUPPORTED"
              glib:nick="unsupported"/>
      <member name="no_memory"
              value="1"
              c:identifier="COGL_ERROR_NO_MEMORY"
              glib:nick="no-memory"/>
    </enumeration>
    <record name="Euler" c:type="CoglEuler" version="2.0">
      <doc xml:whitespace="preserve">Represents an ordered rotation first of @heading degrees around an
object's y axis, then @pitch degrees around an object's x axis and
finally @roll degrees around an object's z axis.

&lt;note&gt;It's important to understand the that axis are associated
with the object being rotated, so the axis also rotate in sequence
with the rotations being applied.&lt;/note&gt;

The members of a #CoglEuler can be initialized, for example, with
cogl_euler_init() and cogl_euler_init_from_quaternion ().

You may also want to look at cogl_quaternion_init_from_euler() if
you want to do interpolation between 3d rotations.</doc>
      <field name="heading" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="pitch" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="roll" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding0" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding1" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding2" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding3" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding4" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <method name="copy"
              c:identifier="cogl_euler_copy"
              version="2.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Allocates a new #CoglEuler and initilizes it with the component
angles of @src. The newly allocated euler should be freed using
cogl_euler_free().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglEuler</doc>
          <type name="Euler" c:type="CoglEuler*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="cogl_euler_free" version="2.0">
        <doc xml:whitespace="preserve">Frees a #CoglEuler that was previously allocated using
cogl_euler_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init" c:identifier="cogl_euler_init" version="2.0">
        <doc xml:whitespace="preserve">Initializes @euler to represent a rotation of @x_angle degrees
around the x axis, then @y_angle degrees around the y_axis and
@z_angle degrees around the z axis.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="heading" transfer-ownership="none">
            <doc xml:whitespace="preserve">Angle to rotate around an object's y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="pitch" transfer-ownership="none">
            <doc xml:whitespace="preserve">Angle to rotate around an object's x axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="roll" transfer-ownership="none">
            <doc xml:whitespace="preserve">Angle to rotate around an object's z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_matrix"
              c:identifier="cogl_euler_init_from_matrix">
        <doc xml:whitespace="preserve">Extracts a euler rotation from the given @matrix and
initializses @euler with the component x, y and z rotation angles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglMatrix containing a rotation, but no scaling, mirroring or skewing.</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_quaternion"
              c:identifier="cogl_euler_init_from_quaternion">
        <doc xml:whitespace="preserve">Initializes a @euler rotation with the equivalent rotation
represented by the given @quaternion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglEuler with the rotation to initialize with</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_euler_equal" version="2.0">
        <doc xml:whitespace="preserve">Compares the two given euler angles @v1 and @v1 and it they are
equal returns %TRUE else %FALSE.

&lt;note&gt;This function only checks that all three components rotations
are numerically equal, it does not consider that some rotations
can be represented with different component rotations&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @v1 and @v2 are equal else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:whitespace="preserve">The second euler angle to compare</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="FIXED_0_5" value="32768" c:type="COGL_FIXED_0_5">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_1" value="1" c:type="COGL_FIXED_1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_2_PI" value="411775" c:type="COGL_FIXED_2_PI">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_BITS" value="32" c:type="COGL_FIXED_BITS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_EPSILON" value="1" c:type="COGL_FIXED_EPSILON">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_MAX" value="2147483647" c:type="COGL_FIXED_MAX">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_MIN" value="2147483648" c:type="COGL_FIXED_MIN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_PI" value="205887" c:type="COGL_FIXED_PI">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_PI_2" value="102944" c:type="COGL_FIXED_PI_2">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_PI_4" value="51472" c:type="COGL_FIXED_PI_4">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_Q" value="-16" c:type="COGL_FIXED_Q">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="FeatureFlags"
              version="0.8"
              glib:type-name="CoglFeatureFlags"
              glib:get-type="cogl_feature_flags_get_type"
              c:type="CoglFeatureFlags">
      <doc xml:whitespace="preserve">Flags for the supported features.</doc>
      <member name="texture_rectangle"
              value="2"
              c:identifier="COGL_FEATURE_TEXTURE_RECTANGLE"
              glib:nick="texture-rectangle"/>
      <member name="texture_npot"
              value="4"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT"
              glib:nick="texture-npot"/>
      <member name="texture_yuv"
              value="8"
              c:identifier="COGL_FEATURE_TEXTURE_YUV"
              glib:nick="texture-yuv"/>
      <member name="texture_read_pixels"
              value="16"
              c:identifier="COGL_FEATURE_TEXTURE_READ_PIXELS"
              glib:nick="texture-read-pixels"/>
      <member name="shaders_glsl"
              value="32"
              c:identifier="COGL_FEATURE_SHADERS_GLSL"
              glib:nick="shaders-glsl"/>
      <member name="offscreen"
              value="64"
              c:identifier="COGL_FEATURE_OFFSCREEN"
              glib:nick="offscreen"/>
      <member name="offscreen_multisample"
              value="128"
              c:identifier="COGL_FEATURE_OFFSCREEN_MULTISAMPLE"
              glib:nick="offscreen-multisample"/>
      <member name="offscreen_blit"
              value="256"
              c:identifier="COGL_FEATURE_OFFSCREEN_BLIT"
              glib:nick="offscreen-blit"/>
      <member name="four_clip_planes"
              value="512"
              c:identifier="COGL_FEATURE_FOUR_CLIP_PLANES"
              glib:nick="four-clip-planes"/>
      <member name="stencil_buffer"
              value="1024"
              c:identifier="COGL_FEATURE_STENCIL_BUFFER"
              glib:nick="stencil-buffer"/>
      <member name="vbos"
              value="2048"
              c:identifier="COGL_FEATURE_VBOS"
              glib:nick="vbos"/>
      <member name="pbos"
              value="4096"
              c:identifier="COGL_FEATURE_PBOS"
              glib:nick="pbos"/>
      <member name="unsigned_int_indices"
              value="8192"
              c:identifier="COGL_FEATURE_UNSIGNED_INT_INDICES"
              glib:nick="unsigned-int-indices"/>
      <member name="depth_range"
              value="16384"
              c:identifier="COGL_FEATURE_DEPTH_RANGE"
              glib:nick="depth-range"/>
      <member name="texture_npot_basic"
              value="32768"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_BASIC"
              glib:nick="texture-npot-basic"/>
      <member name="texture_npot_mipmap"
              value="65536"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_MIPMAP"
              glib:nick="texture-npot-mipmap"/>
      <member name="texture_npot_repeat"
              value="131072"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_REPEAT"
              glib:nick="texture-npot-repeat"/>
      <member name="point_sprite"
              value="262144"
              c:identifier="COGL_FEATURE_POINT_SPRITE"
              glib:nick="point-sprite"/>
      <member name="texture_3d"
              value="524288"
              c:identifier="COGL_FEATURE_TEXTURE_3D"
              glib:nick="texture-3d"/>
      <member name="shaders_arbfp"
              value="1048576"
              c:identifier="COGL_FEATURE_SHADERS_ARBFP"
              glib:nick="shaders-arbfp"/>
      <member name="map_buffer_for_read"
              value="2097152"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_READ"
              glib:nick="map-buffer-for-read"/>
      <member name="map_buffer_for_write"
              value="4194304"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_WRITE"
              glib:nick="map-buffer-for-write"/>
      <member name="onscreen_multiple"
              value="8388608"
              c:identifier="COGL_FEATURE_ONSCREEN_MULTIPLE"
              glib:nick="onscreen-multiple"/>
    </bitfield>
    <enumeration name="FeatureID"
                 version="1.10"
                 glib:type-name="CoglFeatureID"
                 glib:get-type="cogl_feature_id_get_type"
                 c:type="CoglFeatureID">
      <doc xml:whitespace="preserve">All the capabilities that can vary between different GPUs supported
by Cogl. Applications that depend on any of these features should explicitly
check for them using cogl_has_feature() or cogl_has_features().</doc>
      <member name="cogl_feature_id_texture_npot_basic"
              value="1"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT_BASIC"
              glib:nick="cogl-feature-id-texture-npot-basic"/>
      <member name="cogl_feature_id_texture_npot_mipmap"
              value="2"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT_MIPMAP"
              glib:nick="cogl-feature-id-texture-npot-mipmap"/>
      <member name="cogl_feature_id_texture_npot_repeat"
              value="3"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT_REPEAT"
              glib:nick="cogl-feature-id-texture-npot-repeat"/>
      <member name="cogl_feature_id_texture_npot"
              value="4"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT"
              glib:nick="cogl-feature-id-texture-npot"/>
      <member name="cogl_feature_id_texture_rectangle"
              value="5"
              c:identifier="COGL_FEATURE_ID_TEXTURE_RECTANGLE"
              glib:nick="cogl-feature-id-texture-rectangle"/>
      <member name="cogl_feature_id_texture_3d"
              value="6"
              c:identifier="COGL_FEATURE_ID_TEXTURE_3D"
              glib:nick="cogl-feature-id-texture-3d"/>
      <member name="cogl_feature_id_glsl"
              value="7"
              c:identifier="COGL_FEATURE_ID_GLSL"
              glib:nick="cogl-feature-id-glsl"/>
      <member name="cogl_feature_id_arbfp"
              value="8"
              c:identifier="COGL_FEATURE_ID_ARBFP"
              glib:nick="cogl-feature-id-arbfp"/>
      <member name="cogl_feature_id_offscreen"
              value="9"
              c:identifier="COGL_FEATURE_ID_OFFSCREEN"
              glib:nick="cogl-feature-id-offscreen"/>
      <member name="cogl_feature_id_offscreen_multisample"
              value="10"
              c:identifier="COGL_FEATURE_ID_OFFSCREEN_MULTISAMPLE"
              glib:nick="cogl-feature-id-offscreen-multisample"/>
      <member name="cogl_feature_id_onscreen_multiple"
              value="11"
              c:identifier="COGL_FEATURE_ID_ONSCREEN_MULTIPLE"
              glib:nick="cogl-feature-id-onscreen-multiple"/>
      <member name="cogl_feature_id_unsigned_int_indices"
              value="12"
              c:identifier="COGL_FEATURE_ID_UNSIGNED_INT_INDICES"
              glib:nick="cogl-feature-id-unsigned-int-indices"/>
      <member name="cogl_feature_id_depth_range"
              value="13"
              c:identifier="COGL_FEATURE_ID_DEPTH_RANGE"
              glib:nick="cogl-feature-id-depth-range"/>
      <member name="cogl_feature_id_point_sprite"
              value="14"
              c:identifier="COGL_FEATURE_ID_POINT_SPRITE"
              glib:nick="cogl-feature-id-point-sprite"/>
      <member name="cogl_feature_id_map_buffer_for_read"
              value="15"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_READ"
              glib:nick="cogl-feature-id-map-buffer-for-read"/>
      <member name="cogl_feature_id_map_buffer_for_write"
              value="16"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_WRITE"
              glib:nick="cogl-feature-id-map-buffer-for-write"/>
      <member name="cogl_feature_id_mirrored_repeat"
              value="17"
              c:identifier="COGL_FEATURE_ID_MIRRORED_REPEAT"
              glib:nick="cogl-feature-id-mirrored-repeat"/>
      <member name="cogl_feature_id_swap_buffers_event"
              value="18"
              c:identifier="COGL_FEATURE_ID_SWAP_BUFFERS_EVENT"
              glib:nick="cogl-feature-id-swap-buffers-event"/>
      <member name="_cogl_n_feature_ids"
              value="19"
              c:identifier="_COGL_N_FEATURE_IDS"
              glib:nick="-cogl-n-feature-ids"/>
    </enumeration>
    <enumeration name="FilterReturn" c:type="CoglFilterReturn">
      <member name="continue" value="0" c:identifier="COGL_FILTER_CONTINUE"/>
      <member name="remove" value="1" c:identifier="COGL_FILTER_REMOVE"/>
    </enumeration>
    <class name="Fixed"
           c:symbol-prefix="fixed"
           glib:type-name="CoglFixed"
           glib:get-type="cogl_fixed_get_type"
           glib:fundamental="1">
      <doc xml:whitespace="preserve">Fixed point number using a (16.16) notation.</doc>
      <function name="log2"
                c:identifier="cogl_fixed_log2"
                version="1.0"
                introspectable="0">
        <doc xml:whitespace="preserve">Calculates base 2 logarithm.

This function is some 2.5 times faster on x86, and over 12 times faster on
fpu-less arm, than using libc log().</doc>
        <return-value>
          <doc xml:whitespace="preserve">base 2 logarithm.</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">value to calculate base 2 logarithm from</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </function>
      <function name="pow" c:identifier="cogl_fixed_pow" version="1.0">
        <doc xml:whitespace="preserve">Calculates @x to the @y power.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the power of @x to the @y</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">base</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">#CoglFixed exponent</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </function>
      <method name="atan"
              c:identifier="cogl_fixed_atan"
              version="1.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Computes the arc tangent of @a.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the arc tangent of the passed value, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
      </method>
      <method name="atan2"
              c:identifier="cogl_fixed_atan2"
              version="1.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Computes the arc tangent of @a / @b but uses the sign of both
arguments to return the angle in right quadrant.

notation</doc>
        <return-value>
          <doc xml:whitespace="preserve">the arc tangent of the passed fraction, in fixed point</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">the denominator as a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="cos"
              c:identifier="cogl_fixed_cos"
              version="1.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Computes the cosine of @angle.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the cosine of the passed angle, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
      </method>
      <method name="div" c:identifier="cogl_fixed_div" introspectable="0">
        <return-value>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="mul" c:identifier="cogl_fixed_mul" introspectable="0">
        <return-value>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="mul_div"
              c:identifier="cogl_fixed_mul_div"
              introspectable="0">
        <return-value>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="pow2" c:identifier="cogl_fixed_pow2" version="1.0">
        <doc xml:whitespace="preserve">Calculates 2 to the @x power.

This function is around 11 times faster on x86, and around 22 times faster
on fpu-less arm than libc pow(2, x).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the power of 2 to the passed value</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
      </method>
      <method name="sin"
              c:identifier="cogl_fixed_sin"
              version="1.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Computes the sine of @angle.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the sine of the passed angle, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
      </method>
      <method name="sqrt"
              c:identifier="cogl_fixed_sqrt"
              version="1.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Computes the square root of @x.

notation</doc>
        <return-value>
          <doc xml:whitespace="preserve">the square root of the passed value, in floating point</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
      </method>
      <method name="tan"
              c:identifier="cogl_fixed_tan"
              version="1.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Computes the tangent of @angle.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the tangent of the passed angle, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
      </method>
    </class>
    <enumeration name="FogMode"
                 version="1.0"
                 glib:type-name="CoglFogMode"
                 glib:get-type="cogl_fog_mode_get_type"
                 c:type="CoglFogMode">
      <doc xml:whitespace="preserve">The fog mode determines the equation used to calculate the fogging blend
factor while fogging is enabled. The simplest %COGL_FOG_MODE_LINEAR mode
determines f as:

|[
f = end - eye_distance / end - start
]|

Where eye_distance is the distance of the current fragment in eye
coordinates from the origin.</doc>
      <member name="linear"
              value="0"
              c:identifier="COGL_FOG_MODE_LINEAR"
              glib:nick="linear"/>
      <member name="exponential"
              value="1"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL"
              glib:nick="exponential"/>
      <member name="exponential_squared"
              value="2"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL_SQUARED"
              glib:nick="exponential-squared"/>
    </enumeration>
    <record name="Framebuffer" c:type="CoglFramebuffer" disguised="1">
      <method name="add_swap_buffers_callback_EXP"
              c:identifier="cogl_framebuffer_add_swap_buffers_callback_EXP"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <type name="SwapBuffersNotify" c:type="CoglSwapBuffersNotify"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_swap_buffers_callback_EXP"
              c:identifier="cogl_framebuffer_remove_swap_buffers_callback_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_buffers_EXP"
              c:identifier="cogl_framebuffer_swap_buffers_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="swap_region_EXP"
              c:identifier="cogl_framebuffer_swap_region_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rectangles" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="FramebufferError"
                 glib:type-name="CoglFramebufferError"
                 glib:get-type="cogl_framebuffer_error_get_type"
                 c:type="CoglFramebufferError">
      <member name="allocate"
              value="0"
              c:identifier="COGL_FRAMEBUFFER_ERROR_ALLOCATE"
              glib:nick="allocate"/>
      <function name="quark_EXP"
                c:identifier="cogl_framebuffer_error_quark_EXP">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <callback name="FuncPtr" c:type="CoglFuncPtr">
      <doc xml:whitespace="preserve">The type used by cogl for function pointers, note that this type
is used as a generic catch-all cast for function pointers and the
actual arguments and return type may be different.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <record name="IndexBuffer" c:type="CoglIndexBuffer" disguised="1">
      <function name="new"
                c:identifier="cogl_index_buffer_new"
                version="1.4"
                introspectable="0">
        <doc xml:whitespace="preserve">Declares a new #CoglIndexBuffer of @size bytes to contain vertex
indices. Once declared, data can be set using
cogl_buffer_set_data() or by mapping it into the application's
address space using cogl_buffer_map().</doc>
        <return-value>
          <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Indices" c:type="CoglIndices" disguised="1">
      <method name="get_buffer"
              c:identifier="cogl_indices_get_buffer"
              introspectable="0">
        <return-value>
          <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
        </return-value>
      </method>
      <method name="get_offset" c:identifier="cogl_indices_get_offset">
        <return-value transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </return-value>
      </method>
      <method name="set_offset" c:identifier="cogl_indices_set_offset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="cogl_indices_new" introspectable="0">
        <return-value>
          <type name="Indices" c:type="CoglIndices*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <type name="IndicesType" c:type="CoglIndicesType"/>
          </parameter>
          <parameter name="indices_data" transfer-ownership="none">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="n_indices" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_buffer"
                c:identifier="cogl_indices_new_for_buffer"
                introspectable="0">
        <return-value>
          <type name="Indices" c:type="CoglIndices*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <type name="IndicesType" c:type="CoglIndicesType"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="IndicesType"
                 glib:type-name="CoglIndicesType"
                 glib:get-type="cogl_indices_type_get_type"
                 c:type="CoglIndicesType">
      <doc xml:whitespace="preserve">You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.

Note that %COGL_INDICES_TYPE_UNSIGNED_INT is only supported if the
%COGL_FEATURE_UNSIGNED_INT_INDICES feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized.</doc>
      <member name="byte"
              value="0"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_BYTE"
              glib:nick="byte"/>
      <member name="short"
              value="1"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_SHORT"
              glib:nick="short"/>
      <member name="int"
              value="2"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_INT"
              glib:nick="int"/>
    </enumeration>
    <record name="Material" c:type="CoglMaterial" disguised="1">
      <method name="copy"
              c:identifier="cogl_material_copy"
              version="1.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a new material with the configuration copied from the
source material.

We would strongly advise developers to always aim to use
cogl_material_copy() instead of cogl_material_new() whenever there will
be any similarity between two materials. Copying a material helps Cogl
keep track of a materials ancestry which we may use to help minimize GPU
state changes.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer to the newly allocated #CoglMaterial</doc>
          <type name="Material" c:type="CoglMaterial*"/>
        </return-value>
      </method>
      <method name="get_ambient"
              c:identifier="cogl_material_get_ambient"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the current ambient color for @material</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:whitespace="preserve">The location to store the ambient color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color"
              c:identifier="cogl_material_get_color"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the current material color.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">The location to store the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_diffuse"
              c:identifier="cogl_material_get_diffuse"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the current diffuse color for @material</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:whitespace="preserve">The location to store the diffuse color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_emission"
              c:identifier="cogl_material_get_emission"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the materials current emission color.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:whitespace="preserve">The location to store the emission color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_point_sprite_coords_enabled"
              c:identifier="cogl_material_get_layer_point_sprite_coords_enabled"
              version="1.4">
        <doc xml:whitespace="preserve">Gets whether point sprite coordinate generation is enabled for this
texture layer.

point sprite coordinates.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the texture coordinates will be replaced with</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to check.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_p"
              c:identifier="cogl_material_get_layer_wrap_mode_p"
              version="1.6">
        <doc xml:whitespace="preserve">Returns the wrap mode for the 'p' coordinate of texture lookups on this
layer.

this layer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the wrap mode for the 'p' coordinate of texture lookups on</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_s"
              c:identifier="cogl_material_get_layer_wrap_mode_s"
              version="1.6">
        <doc xml:whitespace="preserve">Returns the wrap mode for the 's' coordinate of texture lookups on this
layer.

this layer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the wrap mode for the 's' coordinate of texture lookups on</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_t"
              c:identifier="cogl_material_get_layer_wrap_mode_t"
              version="1.6">
        <doc xml:whitespace="preserve">Returns the wrap mode for the 't' coordinate of texture lookups on this
layer.

this layer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the wrap mode for the 't' coordinate of texture lookups on</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layers" c:identifier="cogl_material_get_layers">
        <doc xml:whitespace="preserve">This function lets you access a material's internal list of layers
for iteration.

&lt;note&gt;You should avoid using this API if possible since it was only
made public by mistake and will be deprecated when we have
suitable alternative.&lt;/note&gt;

&lt;note&gt;It's important to understand that the list returned may not
remain valid if you modify the material or any of the layers in any
way and so you would have to re-get the list in that
situation.&lt;/note&gt;

list of #CoglMaterialLayer&lt;!-- --&gt;'s that can be passed to the
cogl_material_layer_* functions. The list is owned by Cogl and it
should not be modified or freed</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="MaterialLayer"/>
          </type>
        </return-value>
      </method>
      <method name="get_n_layers"
              c:identifier="cogl_material_get_n_layers"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the number of layers defined for the given @material</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of layers</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_point_size"
              c:identifier="cogl_material_get_point_size"
              version="1.4">
        <doc xml:whitespace="preserve">Get the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the point size of the material.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_shininess"
              c:identifier="cogl_material_get_shininess"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the materials current emission color.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The materials current shininess value</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_specular"
              c:identifier="cogl_material_get_specular"
              version="1.0">
        <doc xml:whitespace="preserve">Retrieves the materials current specular color.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:whitespace="preserve">The location to store the specular color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_program"
              c:identifier="cogl_material_get_user_program"
              version="1.4">
        <doc xml:whitespace="preserve">Queries what user program has been associated with the given
@material using cogl_material_set_user_program().

or %COGL_INVALID_HANDLE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current user program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
      </method>
      <method name="remove_layer" c:identifier="cogl_material_remove_layer">
        <doc xml:whitespace="preserve">This function removes a layer from your material</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">Specifies the layer you want to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_test_function"
              c:identifier="cogl_material_set_alpha_test_function"
              version="1.0">
        <doc xml:whitespace="preserve">Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.

The default is %COGL_MATERIAL_ALPHA_FUNC_ALWAYS</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="alpha_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">A @CoglMaterialAlphaFunc constant</doc>
            <type name="MaterialAlphaFunc" c:type="CoglMaterialAlphaFunc"/>
          </parameter>
          <parameter name="alpha_reference" transfer-ownership="none">
            <doc xml:whitespace="preserve">A reference point that the chosen alpha function uses to compare incoming fragments to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient"
              c:identifier="cogl_material_set_ambient"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the material's ambient color, in the standard OpenGL lighting
model. The ambient color affects the overall color of the object.

Since the diffuse color will be intense when the light hits the surface
directly, the ambient will be most apparent where the light hits at a
slant.

The default value is (0.2, 0.2, 0.2, 1.0)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:whitespace="preserve">The components of the desired ambient color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient_and_diffuse"
              c:identifier="cogl_material_set_ambient_and_diffuse"
              version="1.0">
        <doc xml:whitespace="preserve">Conveniently sets the diffuse and ambient color of @material at the same
time. See cogl_material_set_ambient() and cogl_material_set_diffuse().

The default ambient color is (0.2, 0.2, 0.2, 1.0)

The default diffuse color is (0.8, 0.8, 0.8, 1.0)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color" transfer-ownership="none">
            <doc xml:whitespace="preserve">The components of the desired ambient and diffuse colors</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend"
              c:identifier="cogl_material_set_blend"
              version="1.0"
              throws="1">
        <doc xml:whitespace="preserve">If not already familiar; please refer &lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt;
for an overview of what blend strings are, and their syntax.

Blending occurs after the alpha test function, and combines fragments with
the framebuffer.
Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:

|[
&amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
]|

&lt;warning&gt;The brackets around blend factors are currently not
optional!&lt;/warning&gt;

This is the list of source-names usable as blend factors:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;para&gt;SRC_COLOR: The color of the in comming fragment&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;DST_COLOR: The color of the framebuffer&lt;/para&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;para&gt;CONSTANT: The constant set via cogl_material_set_blend_constant()&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The source names can be used according to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source and factor syntax&lt;/link&gt;,
so for example "(1-SRC_COLOR[A])" would be a valid factor, as would
"(CONSTANT[RGB])"

These can also be used as factors:
&lt;itemizedlist&gt;
&lt;listitem&gt;0: (0, 0, 0, 0)&lt;/listitem&gt;
&lt;listitem&gt;1: (1, 1, 1, 1)&lt;/listitem&gt;
&lt;listitem&gt;SRC_ALPHA_SATURATE_FACTOR: (f,f,f,1) where f = MIN(SRC_COLOR[A],1-DST_COLOR[A])&lt;/listitem&gt;
&lt;/itemizedlist&gt;

&lt;note&gt;Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.&lt;/note&gt;

&lt;example id="cogl-Blend-Strings-blend-unpremul"&gt;
&lt;title&gt;Blend Strings/1&lt;/title&gt;
&lt;para&gt;Blend a non-premultiplied source over a destination with
premultiplied alpha:&lt;/para&gt;
&lt;programlisting&gt;
"RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
"A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
&lt;/programlisting&gt;
&lt;/example&gt;

&lt;example id="cogl-Blend-Strings-blend-premul"&gt;
&lt;title&gt;Blend Strings/2&lt;/title&gt;
&lt;para&gt;Blend a premultiplied source over a destination with
premultiplied alpha&lt;/para&gt;
&lt;programlisting&gt;
"RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
&lt;/programlisting&gt;
&lt;/example&gt;

The default blend string is:
|[
RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
]|

That gives normal alpha-blending when the calculated color for the material
is in premultiplied form.

described blending is supported by the underlying driver/hardware. If
there was an error, %FALSE is returned and @error is set accordingly (if
present).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the blend string was successfully parsed, and the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:whitespace="preserve">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt; describing the desired blend function.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend_constant"
              c:identifier="cogl_material_set_blend_constant"
              version="1.0">
        <doc xml:whitespace="preserve">When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="constant_color" transfer-ownership="none">
            <doc xml:whitespace="preserve">The constant color you want</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color"
              c:identifier="cogl_material_set_color"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the basic color of the material, used when no lighting is enabled.

Note that if you don't add any layers to the material then the color
will be blended unmodified with the destination; the default blend
expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
semi-transparent red. See cogl_color_premultiply().

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color" transfer-ownership="none">
            <doc xml:whitespace="preserve">The components of the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4f"
              c:identifier="cogl_material_set_color4f"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the basic color of the material, used when no lighting is enabled.

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">The red component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">The green component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">The blue component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">The alpha component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4ub"
              c:identifier="cogl_material_set_color4ub"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the basic color of the material, used when no lighting is enabled.

The default value is (0xff, 0xff, 0xff, 0xff)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="red" transfer-ownership="none">
            <doc xml:whitespace="preserve">The red component</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:whitespace="preserve">The green component</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:whitespace="preserve">The blue component</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:whitespace="preserve">The alpha component</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_diffuse"
              c:identifier="cogl_material_set_diffuse"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the material's diffuse color, in the standard OpenGL lighting
model. The diffuse color is most intense where the light hits the
surface directly - perpendicular to the surface.

The default value is (0.8, 0.8, 0.8, 1.0)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:whitespace="preserve">The components of the desired diffuse color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_emission"
              c:identifier="cogl_material_set_emission"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the material's emissive color, in the standard OpenGL lighting
model. It will look like the surface is a light source emitting this
color.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:whitespace="preserve">The components of the desired emissive color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer"
              c:identifier="cogl_material_set_layer"
              version="1.0">
        <doc xml:whitespace="preserve">In addition to the standard OpenGL lighting model a Cogl material may have
one or more layers comprised of textures that can be blended together in
order, with a number of different texture combine modes. This function
defines a new texture layer.

The index values of multiple layers do not have to be consecutive; it is
only their relative order that is important.

&lt;note&gt;In the future, we may define other types of material layers, such
as purely GLSL based layers.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the layer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglHandle for the layer object</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine"
              c:identifier="cogl_material_set_layer_combine"
              version="1.0"
              throws="1">
        <doc xml:whitespace="preserve">If not already familiar; you can refer
&lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt; for an overview of what blend
strings are and there syntax.

These are all the functions available for texture combining:
&lt;itemizedlist&gt;
&lt;listitem&gt;REPLACE(arg0) = arg0&lt;/listitem&gt;
&lt;listitem&gt;MODULATE(arg0, arg1) = arg0 x arg1&lt;/listitem&gt;
&lt;listitem&gt;ADD(arg0, arg1) = arg0 + arg1&lt;/listitem&gt;
&lt;listitem&gt;ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5&lt;/listitem&gt;
&lt;listitem&gt;INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)&lt;/listitem&gt;
&lt;listitem&gt;SUBTRACT(arg0, arg1) = arg0 - arg1&lt;/listitem&gt;
&lt;listitem&gt;
&lt;programlisting&gt;
DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
(arg0[G] - 0.5)) * (arg1[G] - 0.5) +
(arg0[B] - 0.5)) * (arg1[B] - 0.5))
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;programlisting&gt;
DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
(arg0[G] - 0.5)) * (arg1[G] - 0.5) +
(arg0[B] - 0.5)) * (arg1[B] - 0.5))
&lt;/programlisting&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Refer to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source syntax&lt;/link&gt; for
describing the arguments. The valid source names for texture combining
are:
&lt;variablelist&gt;
&lt;varlistentry&gt;
&lt;term&gt;TEXTURE&lt;/term&gt;
&lt;listitem&gt;Use the color from the current texture layer&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;TEXTURE_0, TEXTURE_1, etc&lt;/term&gt;
&lt;listitem&gt;Use the color from the specified texture layer&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;CONSTANT&lt;/term&gt;
&lt;listitem&gt;Use the color from the constant given with
cogl_material_set_layer_constant()&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;PRIMARY&lt;/term&gt;
&lt;listitem&gt;Use the color of the material as set with
cogl_material_set_color()&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;varlistentry&gt;
&lt;term&gt;PREVIOUS&lt;/term&gt;
&lt;listitem&gt;Either use the texture color from the previous layer, or
if this is layer 0, use the color of the material as set with
cogl_material_set_color()&lt;/listitem&gt;
&lt;/varlistentry&gt;
&lt;/variablelist&gt;

&lt;refsect2 id="cogl-Layer-Combine-Examples"&gt;
&lt;title&gt;Layer Combine Examples&lt;/title&gt;
&lt;para&gt;This is effectively what the default blending is:&lt;/para&gt;
&lt;informalexample&gt;&lt;programlisting&gt;
RGBA = MODULATE (PREVIOUS, TEXTURE)
&lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;para&gt;This could be used to cross-fade between two images, using
the alpha component of a constant as the interpolator. The constant
color is given by calling cogl_material_set_layer_constant.&lt;/para&gt;
&lt;informalexample&gt;&lt;programlisting&gt;
RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
&lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;/refsect2&gt;

&lt;note&gt;You can't give a multiplication factor for arguments as you can
with blending.&lt;/note&gt;

described texture combining is supported by the underlying driver and
or hardware. On failure, %FALSE is returned and @error is set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the blend string was successfully parsed, and the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">Specifies the layer you want define a combine function for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:whitespace="preserve">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt; describing the desired texture combine function.</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine_constant"
              c:identifier="cogl_material_set_layer_combine_constant"
              version="1.0">
        <doc xml:whitespace="preserve">When you are using the 'CONSTANT' color source in a layer combine
description then you can use this function to define its value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">Specifies the layer you want to specify a constant used for texture combining</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:whitespace="preserve">The constant color you want</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_filters"
              c:identifier="cogl_material_set_layer_filters">
        <doc xml:whitespace="preserve">Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">the filter used when scaling a texture down.</doc>
            <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">the filter used when magnifying a texture.</doc>
            <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_matrix"
              c:identifier="cogl_material_set_layer_matrix">
        <doc xml:whitespace="preserve">This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a material used to fill your geometry.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index for the layer inside @material</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:whitespace="preserve">the transformation matrix for the layer</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_point_sprite_coords_enabled"
              c:identifier="cogl_material_set_layer_point_sprite_coords_enabled"
              version="1.4"
              throws="1">
        <doc xml:whitespace="preserve">When rendering points, if @enable is %TRUE then the texture
coordinates for this layer will be replaced with coordinates that
vary from 0.0 to 1.0 across the primitive. The top left of the
point will have the coordinates 0.0,0.0 and the bottom right will
have 1.0,1.0. If @enable is %FALSE then the coordinates will be
fixed for the entire point.

This function will only work if %COGL_FEATURE_POINT_SPRITE is
available. If the feature is not available then the function will
return %FALSE and set @error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the function succeeds, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to enable point sprite coord generation.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode"
              c:identifier="cogl_material_set_layer_wrap_mode"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the wrap mode for all three coordinates of texture lookups on
this layer. This is equivalent to calling
cogl_material_set_layer_wrap_mode_s(),
cogl_material_set_layer_wrap_mode_t() and
cogl_material_set_layer_wrap_mode_p() separately.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_p"
              c:identifier="cogl_material_set_layer_wrap_mode_p"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_s"
              c:identifier="cogl_material_set_layer_wrap_mode_s"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_t"
              c:identifier="cogl_material_set_layer_wrap_mode_t"
              version="1.4">
        <doc xml:whitespace="preserve">Sets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_point_size"
              c:identifier="cogl_material_set_point_size"
              version="1.4">
        <doc xml:whitespace="preserve">Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API. Note that typically the GPU will
only support a limited minimum and maximum range of point sizes. If
the chosen point size is outside that range then the nearest value
within that range will be used instead. The size of a point is in
screen space so it will be the same regardless of any
transformations. The default point size is 1.0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="point_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new point size.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_shininess"
              c:identifier="cogl_material_set_shininess"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the shininess of the material, in the standard OpenGL lighting
model, which determines the size of the specular highlights. A
higher @shininess will produce smaller highlights which makes the
object appear more shiny.

The default value is 0.0</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="shininess" transfer-ownership="none">
            <doc xml:whitespace="preserve">The desired shininess; must be &gt;= 0.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_specular"
              c:identifier="cogl_material_set_specular"
              version="1.0">
        <doc xml:whitespace="preserve">Sets the material's specular color, in the standard OpenGL lighting
model. The intensity of the specular color depends on the viewport
position, and is brightest along the lines of reflection.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:whitespace="preserve">The components of the desired specular color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_program"
              c:identifier="cogl_material_set_user_program"
              version="1.4">
        <doc xml:whitespace="preserve">Associates a linked CoglProgram with the given material so that the
program can take full control of vertex and/or fragment processing.

This is an example of how it can be used to associate an ARBfp
program with a #CoglMaterial:
|[
CoglHandle shader;
CoglHandle program;
CoglMaterial *material;

shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
cogl_shader_source (shader,
"!!ARBfp1.0\n"
"MOV result.color,fragment.color;\n"
"END\n");
cogl_shader_compile (shader);

program = cogl_create_program ();
cogl_program_attach_shader (program, shader);
cogl_program_link (program);

material = cogl_material_new ();
cogl_material_set_user_program (material, program);

cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
cogl_rectangle (0, 0, 100, 100);
]|

It is possibly worth keeping in mind that this API is not part of
the long term design for how we want to expose shaders to Cogl
developers (We are planning on deprecating the cogl_program and
cogl_shader APIs in favour of a "snippet" framework) but in the
meantime we hope this will handle most practical GLSL and ARBfp
requirements.

Also remember you need to check for either the
%COGL_FEATURE_SHADERS_GLSL or %COGL_FEATURE_SHADERS_ARBFP before
using the cogl_program or cogl_shader API.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="program" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglHandle to a linked CoglProgram</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="cogl_material_new" introspectable="0">
        <doc xml:whitespace="preserve">Allocates and initializes a blank white material</doc>
        <return-value>
          <doc xml:whitespace="preserve">a pointer to a new #CoglMaterial</doc>
          <type name="Material" c:type="CoglMaterial*"/>
        </return-value>
      </function>
      <function name="ref"
                c:identifier="cogl_material_ref"
                version="1.0"
                introspectable="0"
                deprecated="Use cogl_object_ref() instead"
                deprecated-version="1.2">
        <doc xml:whitespace="preserve">Increment the reference count for a #CoglMaterial.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the @material.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <parameter name="material" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglMaterial object.</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_material_unref"
                version="1.0"
                deprecated="Use cogl_object_unref() instead"
                deprecated-version="1.2">
        <doc xml:whitespace="preserve">Decrement the reference count for a #CoglMaterial.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="material" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglMaterial object.</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="MaterialAlphaFunc"
                 glib:type-name="CoglMaterialAlphaFunc"
                 glib:get-type="cogl_material_alpha_func_get_type"
                 c:type="CoglMaterialAlphaFunc">
      <doc xml:whitespace="preserve">Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglMaterialAlphaFunc
determines how the comparison is done.</doc>
      <member name="never"
              value="512"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NEVER"
              glib:nick="never"/>
      <member name="less"
              value="513"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LESS"
              glib:nick="less"/>
      <member name="equal"
              value="514"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_EQUAL"
              glib:nick="equal"/>
      <member name="lequal"
              value="515"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LEQUAL"
              glib:nick="lequal"/>
      <member name="greater"
              value="516"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GREATER"
              glib:nick="greater"/>
      <member name="notequal"
              value="517"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL"
              glib:nick="notequal"/>
      <member name="gequal"
              value="518"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GEQUAL"
              glib:nick="gequal"/>
      <member name="always"
              value="519"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_ALWAYS"
              glib:nick="always"/>
    </enumeration>
    <enumeration name="MaterialFilter"
                 glib:type-name="CoglMaterialFilter"
                 glib:get-type="cogl_material_filter_get_type"
                 c:type="CoglMaterialFilter">
      <doc xml:whitespace="preserve">Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel.</doc>
      <member name="nearest"
              value="9728"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST"
              glib:nick="nearest"/>
      <member name="linear"
              value="9729"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR"
              glib:nick="linear"/>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST"
              glib:nick="nearest-mipmap-nearest"/>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST"
              glib:nick="linear-mipmap-nearest"/>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR"
              glib:nick="nearest-mipmap-linear"/>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR"
              glib:nick="linear-mipmap-linear"/>
    </enumeration>
    <record name="MaterialLayer" c:type="CoglMaterialLayer" disguised="1">
      <method name="get_mag_filter"
              c:identifier="cogl_material_layer_get_mag_filter">
        <doc xml:whitespace="preserve">Queries the currently set downscaling filter for a material later</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current downscaling filter</doc>
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </return-value>
      </method>
      <method name="get_min_filter"
              c:identifier="cogl_material_layer_get_min_filter">
        <doc xml:whitespace="preserve">Queries the currently set downscaling filter for a material layer</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current downscaling filter</doc>
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </return-value>
      </method>
      <method name="get_texture"
              c:identifier="cogl_material_layer_get_texture">
        <doc xml:whitespace="preserve">Extracts a texture handle for a specific layer.

&lt;note&gt;In the future Cogl may support purely GLSL based layers; for those
layers this function which will likely return %COGL_INVALID_HANDLE if you
try to get the texture handle from them. Considering this scenario, you
should call cogl_material_layer_get_type() first in order check it is of
type %COGL_MATERIAL_LAYER_TYPE_TEXTURE before calling this function.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for the texture inside the layer</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
      </method>
      <method name="get_wrap_mode_p"
              c:identifier="cogl_material_layer_get_wrap_mode_p"
              version="1.4">
        <doc xml:whitespace="preserve">Gets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the wrap mode value for the p coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
      </method>
      <method name="get_wrap_mode_s"
              c:identifier="cogl_material_layer_get_wrap_mode_s"
              version="1.4">
        <doc xml:whitespace="preserve">Gets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the wrap mode value for the s coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
      </method>
      <method name="get_wrap_mode_t"
              c:identifier="cogl_material_layer_get_wrap_mode_t"
              version="1.4">
        <doc xml:whitespace="preserve">Gets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the wrap mode value for the t coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
      </method>
    </record>
    <enumeration name="MaterialLayerType"
                 version="1.0"
                 glib:type-name="CoglMaterialLayerType"
                 glib:get-type="cogl_material_layer_type_get_type"
                 c:type="CoglMaterialLayerType">
      <doc xml:whitespace="preserve">Available types of layers for a #CoglMaterial. This enumeration
might be expanded in later versions.</doc>
      <member name="texture"
              value="0"
              c:identifier="COGL_MATERIAL_LAYER_TYPE_TEXTURE"
              glib:nick="texture"/>
    </enumeration>
    <enumeration name="MaterialWrapMode"
                 version="1.4"
                 glib:type-name="CoglMaterialWrapMode"
                 glib:get-type="cogl_material_wrap_mode_get_type"
                 c:type="CoglMaterialWrapMode">
      <doc xml:whitespace="preserve">The wrap mode specifies what happens when texture coordinates
outside the range 0→1 are used. Note that if the filter mode is
anything but %COGL_MATERIAL_FILTER_NEAREST then texels outside the
range 0→1 might be used even when the coordinate is exactly 0 or 1
because OpenGL will try to sample neighbouring pixels. For example
if you are trying to render the full texture then you may get
artifacts around the edges when the pixels from the other side are
merged in if the wrap mode is set to repeat.</doc>
      <member name="repeat"
              value="10497"
              c:identifier="COGL_MATERIAL_WRAP_MODE_REPEAT"
              glib:nick="repeat"/>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE"
              glib:nick="clamp-to-edge"/>
      <member name="automatic"
              value="519"
              c:identifier="COGL_MATERIAL_WRAP_MODE_AUTOMATIC"
              glib:nick="automatic"/>
    </enumeration>
    <record name="Matrix" c:type="CoglMatrix">
      <doc xml:whitespace="preserve">A CoglMatrix holds a 4x4 transform matrix. This is a single precision,
column-major matrix which means it is compatible with what OpenGL expects.

A CoglMatrix can represent transforms such as, rotations, scaling,
translation, sheering, and linear projections. You can combine these
transforms by multiplying multiple matrices in the order you want them
applied.

The transformation of a vertex (x, y, z, w) by a CoglMatrix is given by:

|[
x_new = xx * x + xy * y + xz * z + xw * w
y_new = yx * x + yy * y + yz * z + yw * w
z_new = zx * x + zy * y + zz * z + zw * w
w_new = wx * x + wy * y + wz * z + ww * w
]|

Where w is normally 1

&lt;note&gt;You must consider the members of the CoglMatrix structure read only,
and all matrix modifications must be done via the cogl_matrix API. This
allows Cogl to annotate the matrices internally. Violation of this will give
undefined results. If you need to initialize a matrix with a constant other
than the identity matrix you can use cogl_matrix_init_from_array().&lt;/note&gt;</doc>
      <field name="xx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ww" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="inv" readable="0" private="1">
        <array zero-terminated="0" c:type="gfloat" fixed-size="16">
          <type name="gfloat" c:type="float"/>
        </array>
      </field>
      <field name="type" readable="0" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="_padding3" readable="0" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <method name="copy"
              c:identifier="cogl_matrix_copy"
              version="1.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Allocates a new #CoglMatrix on the heap and initializes it with
the same values as @matrix.

cogl_matrix_free()</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglMatrix which should be freed using</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="cogl_matrix_free" version="1.6">
        <doc xml:whitespace="preserve">Frees a #CoglMatrix that was previously allocated via a call to
cogl_matrix_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="frustum" c:identifier="cogl_matrix_frustum">
        <doc xml:whitespace="preserve">Multiplies @matrix by the given frustum perspective matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="left" transfer-ownership="none">
            <doc xml:whitespace="preserve">X position of the left clipping plane where it intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">X position of the right clipping plane where it intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y position of the bottom clipping plane where it intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y position of the top clipping plane where it intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:whitespace="preserve">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:whitespace="preserve">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array" c:identifier="cogl_matrix_get_array">
        <doc xml:whitespace="preserve">Casts @matrix to a float array which can be directly passed to OpenGL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the float array</doc>
          <type name="gfloat" c:type="float*"/>
        </return-value>
      </method>
      <method name="get_inverse"
              c:identifier="cogl_matrix_get_inverse"
              version="1.2">
        <doc xml:whitespace="preserve">Gets the inverse transform of a given matrix and uses it to initialize
a new #CoglMatrix.

&lt;note&gt;Although the first parameter is annotated as const to indicate
that the transform it represents isn't modified this function may
technically save a copy of the inverse transform within the given
#CoglMatrix so that subsequent requests for the inverse transform may
avoid costly inversion calculations.&lt;/note&gt;

for degenerate transformations that can't be inverted (in this case the
@inverse matrix will simply be initialized with the identity matrix)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the inverse was successfully calculated or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="inverse"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">The destination for a 4x4 inverse transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_array"
              c:identifier="cogl_matrix_init_from_array">
        <doc xml:whitespace="preserve">Initializes @matrix with the contents of @array</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:whitespace="preserve">A linear array of 16 floats (column-major order)</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity" c:identifier="cogl_matrix_init_identity">
        <doc xml:whitespace="preserve">Resets matrix to the identity matrix:

|[
.xx=1; .xy=0; .xz=0; .xw=0;
.yx=0; .yy=1; .yz=0; .yw=0;
.zx=0; .zy=0; .zz=1; .zw=0;
.wx=0; .wy=0; .wz=0; .ww=1;
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="is_identity"
              c:identifier="cogl_matrix_is_identity"
              version="1.8">
        <doc xml:whitespace="preserve">Determines if the given matrix is an identity matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @matrix is an identity matrix else %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="look_at_EXP" c:identifier="cogl_matrix_look_at_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="eye_position_x" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_y" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_z" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_x" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_y" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_z" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_x" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_y" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_z" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="cogl_matrix_multiply">
        <doc xml:whitespace="preserve">Multiplies the two supplied matrices together and stores
the resulting matrix inside @result.

&lt;note&gt;It is possible to multiply the @a matrix in-place, so
@result can be equal to @a but can't be equal to @b.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="a" transfer-ownership="none">
            <doc xml:whitespace="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ortho"
              c:identifier="cogl_matrix_ortho"
              deprecated="Use cogl_matrix_orthographic()"
              deprecated-version="1.10">
        <doc xml:whitespace="preserve">Multiplies @matrix by a parallel projection matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="left" transfer-ownership="none">
            <doc xml:whitespace="preserve">The coordinate for the left clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The coordinate for the right clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:whitespace="preserve">The coordinate for the bottom clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:whitespace="preserve">The coordinate for the top clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:whitespace="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:whitespace="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="cogl_matrix_perspective">
        <doc xml:whitespace="preserve">Multiplies @matrix by the described perspective matrix

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fov_y" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:whitespace="preserve">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:whitespace="preserve">The distance to the near clipping plane (Must be positive, and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:whitespace="preserve">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_matrix_rotate">
        <doc xml:whitespace="preserve">Multiplies @matrix with a rotation matrix that applies a rotation
of @angle degrees around the specified 3D vector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The angle you want to rotate in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:whitespace="preserve">Z component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_matrix_scale">
        <doc xml:whitespace="preserve">Multiplies @matrix with a transform matrix that scales along the X,
Y and Z axis.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sx" transfer-ownership="none">
            <doc xml:whitespace="preserve">The X scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <doc xml:whitespace="preserve">The Y scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sz" transfer-ownership="none">
            <doc xml:whitespace="preserve">The Z scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="cogl_matrix_transform_point">
        <doc xml:whitespace="preserve">Transforms a point whos position is given and returned as four float
components.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The X component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="y"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The Y component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="z"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The Z component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="w"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The W component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_matrix_translate">
        <doc xml:whitespace="preserve">Multiplies @matrix with a transform matrix that translates along
the X, Y and Z axis.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">The X translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">The Y translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:whitespace="preserve">The Z translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transpose"
              c:identifier="cogl_matrix_transpose"
              version="1.10">
        <doc xml:whitespace="preserve">Replaces @matrix with its transpose. Ie, every element (i,j) in the
new matrix is taken from element (j,i) in the old matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <function name="equal" c:identifier="cogl_matrix_equal" version="1.4">
        <doc xml:whitespace="preserve">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:whitespace="preserve">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:whitespace="preserve">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="MetaTexture" c:type="CoglMetaTexture" disguised="1">
    </record>
    <callback name="MetaTextureCallback"
              c:type="CoglMetaTextureCallback"
              version="1.10">
      <doc xml:whitespace="preserve">A callback used with cogl_meta_texture_foreach_in_region() to
retrieve details of all the low-level #CoglTexture&lt;!-- --&gt;s that
make up a given #CoglMetaTexture.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="sub_texture" transfer-ownership="none">
          <doc xml:whitespace="preserve">A low-level #CoglTexture making up part of a #CoglMetaTexture.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
        <parameter name="sub_texture_coords" transfer-ownership="none">
          <doc xml:whitespace="preserve">A float 4-tuple ordered like (tx1,ty1,tx2,ty2) defining what region of the current @sub_texture maps to a sub-region of a #CoglMetaTexture. (tx1,ty1) is the top-left sub-region coordinate and (tx2,ty2) is the bottom-right. These are low-level texture coordinates.</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="meta_coords" transfer-ownership="none">
          <doc xml:whitespace="preserve">A float 4-tuple ordered like (tx1,ty1,tx2,ty2) defining what sub-region of a #CoglMetaTexture this low-level @sub_texture maps too. (tx1,ty1) is the top-left sub-region coordinate and (tx2,ty2) is the bottom-right. These are high-level meta-texture coordinates.</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">A private pointer passed to cogl_meta_texture_foreach_in_region().</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Object" c:type="CoglObject" disguised="1">
      <method name="get_user_data"
              c:identifier="cogl_object_get_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:whitespace="preserve">Finds the user data previously associated with @object using
the given @key. If no user data has been associated with @object
for the given @key this function returns NULL.

with @object using the given @key; or %NULL if no associated
data is found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The user data previously associated</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">The address of a #CoglUserDataKey which provides a unique value with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cogl_object_set_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:whitespace="preserve">Associates some private @user_data with a given #CoglObject. To
later remove the association call cogl_object_set_user_data() with
the same @key but NULL for the @user_data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">The address of a #CoglUserDataKey which provides a unique value with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">The data to associate with the given object, or %NULL to remove a previous association.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglUserDataDestroyCallback to call if the object is destroyed or if the association is removed by later setting %NULL data for the same key.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <function name="ref" c:identifier="cogl_object_ref" introspectable="0">
        <doc xml:whitespace="preserve">Increases the reference count of @handle by 1</doc>
        <return-value>
          <doc xml:whitespace="preserve">the @object, with its reference count increased</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_object_unref"
                introspectable="0">
        <doc xml:whitespace="preserve">Drecreases the reference count of @object by 1; if the reference
count reaches 0, the resources allocated by @object will be freed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Onscreen" c:type="CoglOnscreen" disguised="1">
      <method name="hide_EXP" c:identifier="cogl_onscreen_hide_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_swap_throttled_EXP"
              c:identifier="cogl_onscreen_set_swap_throttled_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="throttled" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="show_EXP" c:identifier="cogl_onscreen_show_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <function name="clutter_backend_set_size_CLUTTER"
                c:identifier="cogl_onscreen_clutter_backend_set_size_CLUTTER">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="cogl_onscreen_new" introspectable="0">
        <return-value>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="OnscreenX11MaskCallback"
              c:type="CoglOnscreenX11MaskCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="event_mask" transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="PIXEL_FORMAT_24" value="2" c:type="COGL_PIXEL_FORMAT_24">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PIXEL_FORMAT_32" value="3" c:type="COGL_PIXEL_FORMAT_32">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PREMULT_BIT" value="128" c:type="COGL_PREMULT_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Path" c:type="CoglPath" disguised="1">
      <method name="copy" c:identifier="cogl_path_copy" introspectable="0">
        <doc xml:whitespace="preserve">Returns a new copy of the path in @path. The new path has a
reference count of 1 so you should unref it with
cogl_object_unref() if you no longer need it.

Internally the path will share the data until one of the paths is
modified so copying paths should be relatively cheap.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of the path in @path.</doc>
          <type name="Path" c:type="CoglPath*"/>
        </return-value>
      </method>
      <function name="arc" c:identifier="cogl_path_arc">
        <doc xml:whitespace="preserve">Adds an elliptical arc segment to the current path. A straight line
segment will link the current pen location with the first vertex
of the arc. If you perform a move_to to the arcs start just before
drawing it you create a free standing arc.

The angles are measured in degrees where 0° is in the direction of
the positive X axis and 90° is in the direction of the positive Y
axis. The angle of the arc begins at @angle_1 and heads towards
@angle_2 (so if @angle_2 is less than @angle_1 it will decrease,
otherwise it will increase).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="center_x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the elliptical arc center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="center_y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the elliptical arc center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="radius_x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X radius of the elliptical arc</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="radius_y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y radius of the elliptical arc</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="angle_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">Angle in degrees at which the arc begin</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="angle_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">Angle in degrees at which the arc ends</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="close" c:identifier="cogl_path_close">
        <doc xml:whitespace="preserve">Closes the path being constructed by adding a straight line segment
to it that ends at the first vertex of the path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="curve_to" c:identifier="cogl_path_curve_to">
        <doc xml:whitespace="preserve">Adds a cubic bezier curve segment to the current path with the given
second, third and fourth control points and using current pen location
as the first control point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the second bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the second bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the third bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the third bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_3" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the fourth bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_3" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the fourth bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="ellipse" c:identifier="cogl_path_ellipse">
        <doc xml:whitespace="preserve">Constructs an ellipse shape. If there is an existing path this will
start a new disjoint sub-path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="center_x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the ellipse center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="center_y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the ellipse center</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="radius_x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X radius of the ellipse</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="radius_y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y radius of the ellipse</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="fill" c:identifier="cogl_path_fill">
        <doc xml:whitespace="preserve">Fills the interior of the constructed shape using the current
drawing color. The current path is then cleared. To use the path
again, call cogl_path_fill_preserve() instead.

The interior of the shape is determined using the fill rule of the
path. See %CoglPathFillRule for details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="fill_preserve"
                c:identifier="cogl_path_fill_preserve"
                version="1.0">
        <doc xml:whitespace="preserve">Fills the interior of the constructed shape using the current
drawing color and preserves the path to be used again. See
cogl_path_fill() for a description what is considered the interior
of the shape.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="get_fill_rule"
                c:identifier="cogl_path_get_fill_rule"
                version="1.4">
        <doc xml:whitespace="preserve">Retrieves the fill rule set using cogl_path_set_fill_rule().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the fill rule that is used for the current path.</doc>
          <type name="PathFillRule" c:type="CoglPathFillRule"/>
        </return-value>
      </function>
      <function name="line" c:identifier="cogl_path_line">
        <doc xml:whitespace="preserve">Constructs a straight line shape starting and ending at the given
coordinates. If there is an existing path this will start a new
disjoint sub-path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the start line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the start line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the end line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the end line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="line_to" c:identifier="cogl_path_line_to">
        <doc xml:whitespace="preserve">Adds a straight line segment to the current path that ends at the
given coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the end line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the end line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="move_to" c:identifier="cogl_path_move_to">
        <doc xml:whitespace="preserve">Moves the pen to the given location. If there is an existing path
this will start a new disjoint subpath.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the pen location to move to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the pen location to move to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="cogl_path_new" version="1.0">
        <doc xml:whitespace="preserve">Clears the current path and starts a new one. Creating a new path
also resets the fill rule to the default which is
%COGL_PATH_FILL_RULE_EVEN_ODD.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="polygon" c:identifier="cogl_path_polygon">
        <doc xml:whitespace="preserve">Constructs a polygonal shape of the given number of vertices. If
there is an existing path this will start a new disjoint sub-path.

The coords array must contain 2 * num_points values. The first value
represents the X coordinate of the first vertex, the second value
represents the Y coordinate of the first vertex, continuing in the same
fashion for the rest of the vertices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="coords" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the first element of an array of fixed-point values that specify the vertex coordinates.</doc>
            <array zero-terminated="0" c:type="float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="num_points" transfer-ownership="none">
            <doc xml:whitespace="preserve">The total number of vertices.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="polyline" c:identifier="cogl_path_polyline">
        <doc xml:whitespace="preserve">Constructs a series of straight line segments, starting from the
first given vertex coordinate. If there is an existing path this
will start a new disjoint sub-path. Each subsequent segment starts
where the previous one ended and ends at the next given vertex
coordinate.

The coords array must contain 2 * num_points values. The first value
represents the X coordinate of the first vertex, the second value
represents the Y coordinate of the first vertex, continuing in the same
fashion for the rest of the vertices. (num_points - 1) segments will
be constructed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="coords" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the first element of an array of fixed-point values that specify the vertex coordinates.</doc>
            <array zero-terminated="0" c:type="float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="num_points" transfer-ownership="none">
            <doc xml:whitespace="preserve">The total number of vertices.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="rectangle" c:identifier="cogl_path_rectangle">
        <doc xml:whitespace="preserve">Constructs a rectangular shape at the given coordinates. If there
is an existing path this will start a new disjoint sub-path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the top-left corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the top-left corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the bottom-right corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the bottom-right corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="rel_curve_to" c:identifier="cogl_path_rel_curve_to">
        <doc xml:whitespace="preserve">Adds a cubic bezier curve segment to the current path with the given
second, third and fourth control points and using current pen location
as the first control point. The given coordinates are relative to the
current pen location.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the second bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the second bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the third bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the third bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_3" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the fourth bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_3" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the fourth bezier control point</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="rel_line_to" c:identifier="cogl_path_rel_line_to">
        <doc xml:whitespace="preserve">Adds a straight line segment to the current path that ends at the
given coordinates relative to the current pen location.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X offset from the current pen location of the end line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y offset from the current pen location of the end line vertex</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="rel_move_to" c:identifier="cogl_path_rel_move_to">
        <doc xml:whitespace="preserve">Moves the pen to the given offset relative to the current pen
location. If there is an existing path this will start a new
disjoint subpath.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X offset from the current pen location to move the pen to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y offset from the current pen location to move the pen to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="round_rectangle"
                c:identifier="cogl_path_round_rectangle">
        <doc xml:whitespace="preserve">Constructs a rectangular shape with rounded corners. If there is an
existing path this will start a new disjoint sub-path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the top-left corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the top-left corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the bottom-right corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the bottom-right corner.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:whitespace="preserve">Radius of the corner arcs.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="arc_step" transfer-ownership="none">
            <doc xml:whitespace="preserve">Angle increment resolution for subdivision of the corner arcs.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_fill_rule"
                c:identifier="cogl_path_set_fill_rule"
                version="1.4">
        <doc xml:whitespace="preserve">Sets the fill rule of the current path to @fill_rule. This will
affect how the path is filled when cogl_path_fill() is later
called. Note that the fill rule state is attached to the path so
calling cogl_get_path() will preserve the fill rule and calling
cogl_path_new() will reset the fill rule back to the default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fill_rule" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new fill rule.</doc>
            <type name="PathFillRule" c:type="CoglPathFillRule"/>
          </parameter>
        </parameters>
      </function>
      <function name="stroke" c:identifier="cogl_path_stroke">
        <doc xml:whitespace="preserve">Strokes the constructed shape using the current drawing color and a
width of 1 pixel (regardless of the current transformation
matrix). To current path is then cleared. To use the path again,
call cogl_path_stroke_preserve() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="stroke_preserve"
                c:identifier="cogl_path_stroke_preserve"
                version="1.0">
        <doc xml:whitespace="preserve">Strokes the constructed shape using the current drawing color and
preserves the path to be used again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <enumeration name="PathFillRule"
                 version="1.4"
                 glib:type-name="CoglPathFillRule"
                 glib:get-type="cogl_path_fill_rule_get_type"
                 c:type="CoglPathFillRule">
      <doc xml:whitespace="preserve">#CoglPathFillRule is used to determine how a path is filled. There
are two options - 'non-zero' and 'even-odd'. To work out whether any
point will be filled imagine drawing an infinetely long line in any
direction from that point. The number of times and the direction
that the edges of the path crosses this line determines whether the
line is filled as described below. Any open sub paths are treated
as if there was an extra line joining the first point and the last
point.

The default fill rule is %COGL_PATH_FILL_RULE_EVEN_ODD. The fill
rule is attached to the current path so preserving a path with
cogl_get_path() also preserves the fill rule. Calling
cogl_path_new() resets the current fill rule to the default.

&lt;figure id="fill-rule-non-zero"&gt;
&lt;title&gt;Example of filling various paths using the non-zero rule&lt;/title&gt;
&lt;graphic fileref="fill-rule-non-zero.png" format="PNG"/&gt;
&lt;/figure&gt;

&lt;figure id="fill-rule-even-odd"&gt;
&lt;title&gt;Example of filling various paths using the even-odd rule&lt;/title&gt;
&lt;graphic fileref="fill-rule-even-odd.png" format="PNG"/&gt;
&lt;/figure&gt;</doc>
      <member name="non_zero"
              value="0"
              c:identifier="COGL_PATH_FILL_RULE_NON_ZERO"
              glib:nick="non-zero"/>
      <member name="even_odd"
              value="1"
              c:identifier="COGL_PATH_FILL_RULE_EVEN_ODD"
              glib:nick="even-odd"/>
    </enumeration>
    <record name="PixelBuffer" c:type="CoglPixelBuffer" disguised="1">
      <function name="new_with_size_EXP"
                c:identifier="cogl_pixel_buffer_new_with_size_EXP"
                introspectable="0">
        <return-value>
          <type name="PixelBuffer" c:type="CoglPixelBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="stride" transfer-ownership="none">
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="PixelFormat"
                 version="0.8"
                 glib:type-name="CoglPixelFormat"
                 glib:get-type="cogl_pixel_format_get_type"
                 c:type="CoglPixelFormat">
      <doc xml:whitespace="preserve">Pixel formats used by COGL. For the formats with a byte per
component, the order of the components specify the order in
increasing memory addresses. So for example
%COGL_PIXEL_FORMAT_RGB_888 would have the red component in the
lowest address, green in the next address and blue after that
regardless of the endinanness of the system.

For the 16-bit formats the component order specifies the order
within a 16-bit number from most significant bit to least
significant. So for %COGL_PIXEL_FORMAT_RGB_565, the red component
would be in bits 11-15, the green component would be in 6-11 and
the blue component would be in 1-5. Therefore the order in memory
depends on the endianness of the system.

When uploading a texture %COGL_PIXEL_FORMAT_ANY can be used as the
internal format. Cogl will try to pick the best format to use
internally and convert the texture data if necessary.</doc>
      <member name="any"
              value="0"
              c:identifier="COGL_PIXEL_FORMAT_ANY"
              glib:nick="any"/>
      <member name="a_8"
              value="17"
              c:identifier="COGL_PIXEL_FORMAT_A_8"
              glib:nick="a-8"/>
      <member name="rgb_565"
              value="4"
              c:identifier="COGL_PIXEL_FORMAT_RGB_565"
              glib:nick="rgb-565"/>
      <member name="rgba_4444"
              value="21"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444"
              glib:nick="rgba-4444"/>
      <member name="rgba_5551"
              value="22"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551"
              glib:nick="rgba-5551"/>
      <member name="yuv"
              value="7"
              c:identifier="COGL_PIXEL_FORMAT_YUV"
              glib:nick="yuv"/>
      <member name="g_8"
              value="8"
              c:identifier="COGL_PIXEL_FORMAT_G_8"
              glib:nick="g-8"/>
      <member name="rgb_888"
              value="2"
              c:identifier="COGL_PIXEL_FORMAT_RGB_888"
              glib:nick="rgb-888"/>
      <member name="bgr_888"
              value="34"
              c:identifier="COGL_PIXEL_FORMAT_BGR_888"
              glib:nick="bgr-888"/>
      <member name="rgba_8888"
              value="19"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888"
              glib:nick="rgba-8888"/>
      <member name="bgra_8888"
              value="51"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888"
              glib:nick="bgra-8888"/>
      <member name="argb_8888"
              value="83"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888"
              glib:nick="argb-8888"/>
      <member name="abgr_8888"
              value="115"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888"
              glib:nick="abgr-8888"/>
      <member name="rgba_8888_pre"
              value="147"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888_PRE"
              glib:nick="rgba-8888-pre"/>
      <member name="bgra_8888_pre"
              value="179"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888_PRE"
              glib:nick="bgra-8888-pre"/>
      <member name="argb_8888_pre"
              value="211"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888_PRE"
              glib:nick="argb-8888-pre"/>
      <member name="abgr_8888_pre"
              value="243"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888_PRE"
              glib:nick="abgr-8888-pre"/>
      <member name="rgba_4444_pre"
              value="149"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444_PRE"
              glib:nick="rgba-4444-pre"/>
      <member name="rgba_5551_pre"
              value="150"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551_PRE"
              glib:nick="rgba-5551-pre"/>
    </enumeration>
    <record name="PollFD" c:type="CoglPollFD" version="1.10">
      <doc xml:whitespace="preserve">A struct for describing the state of a file descriptor that Cogl
needs to block on. The @events field contains a bitmask of
#CoglPollFDEvent&lt;!-- --&gt;s that should cause the application to wake
up. After the application is woken up from idle it should pass back
an array of #CoglPollFD&lt;!-- --&gt;s to Cogl and update the @revents
mask to the actual events that occurred on the file descriptor.

Note that CoglPollFD is deliberately exactly the same as struct
pollfd on Unix so that it can simply be cast when calling poll.</doc>
      <field name="fd" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="events" writable="1">
        <type name="gshort" c:type="short"/>
      </field>
      <field name="revents" writable="1">
        <type name="gshort" c:type="short"/>
      </field>
    </record>
    <enumeration name="PollFDEvent"
                 version="1.10"
                 glib:type-name="CoglPollFDEvent"
                 glib:get-type="cogl_poll_fd_event_get_type"
                 c:type="CoglPollFDEvent">
      <doc xml:whitespace="preserve">A bitmask of events that Cogl may need to wake on for a file
descriptor. Note that these all have the same values as the
corresponding defines for the poll function call on Unix so they
may be directly passed to poll.</doc>
      <member name="in"
              value="1"
              c:identifier="COGL_POLL_FD_EVENT_IN"
              glib:nick="in"/>
      <member name="pri"
              value="2"
              c:identifier="COGL_POLL_FD_EVENT_PRI"
              glib:nick="pri"/>
      <member name="out"
              value="4"
              c:identifier="COGL_POLL_FD_EVENT_OUT"
              glib:nick="out"/>
      <member name="err"
              value="8"
              c:identifier="COGL_POLL_FD_EVENT_ERR"
              glib:nick="err"/>
      <member name="hup"
              value="16"
              c:identifier="COGL_POLL_FD_EVENT_HUP"
              glib:nick="hup"/>
      <member name="nval"
              value="32"
              c:identifier="COGL_POLL_FD_EVENT_NVAL"
              glib:nick="nval"/>
    </enumeration>
    <record name="Primitive" c:type="CoglPrimitive" disguised="1">
      <method name="draw" c:identifier="cogl_primitive_draw" version="1.6">
        <doc xml:whitespace="preserve">Draw the given @primitive with the current source material.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_first_vertex"
              c:identifier="cogl_primitive_get_first_vertex">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_mode" c:identifier="cogl_primitive_get_mode">
        <return-value transfer-ownership="none">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </return-value>
      </method>
      <method name="get_n_vertices_EXP"
              c:identifier="cogl_primitive_get_n_vertices_EXP">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="set_attributes"
              c:identifier="cogl_primitive_set_attributes"
              version="1.6">
        <doc xml:whitespace="preserve">Replaces all the attributes of the given #CoglPrimitive object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">A %NULL terminated array of #CoglAttribute pointers</doc>
            <type name="Attribute" c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_first_vertex"
              c:identifier="cogl_primitive_set_first_vertex">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_vertex" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_indices_EXP"
              c:identifier="cogl_primitive_set_indices_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="indices" transfer-ownership="none">
            <type name="Indices" c:type="CoglIndices*"/>
          </parameter>
          <parameter name="n_indices" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mode" c:identifier="cogl_primitive_set_mode">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_n_vertices_EXP"
              c:identifier="cogl_primitive_set_n_vertices_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_vertices" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="cogl_primitive_new"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Combines a set of #CoglAttribute&lt;!-- --&gt;s with a specific draw @mode
and defines a vertex count so a #CoglPrimitive object can be retained and
drawn later with no addition information required.

The value passed as @n_vertices will simply update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive object</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to process when drawing</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </function>
      <function name="new_p2"
                c:identifier="cogl_primitive_new_p2"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
attribute with a #CoglAttribute and upload your data.

For example to draw a convex polygon you can do:
|[
CoglVertexP2 triangle[] =
{
{ 0,   300 },
{ 150, 0,  },
{ 300, 300 }
};
prim = cogl_primitive_new_p2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP2 vertices</doc>
            <type name="VertexP2" c:type="CoglVertexP2*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_p2c4"
                c:identifier="cogl_primitive_new_p2c4"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
and color attributes with #CoglAttribute&lt;!-- --&gt;s and upload
your data.

For example to draw a convex polygon with a linear gradient you
can do:
|[
CoglVertexP2C4 triangle[] =
{
{ 0,   300,  0xff, 0x00, 0x00, 0xff },
{ 150, 0,    0x00, 0xff, 0x00, 0xff },
{ 300, 300,  0xff, 0x00, 0x00, 0xff }
};
prim = cogl_primitive_new_p2c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP2C4 vertices</doc>
            <type name="VertexP2C4" c:type="CoglVertexP2C4*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_p2t2"
                c:identifier="cogl_primitive_new_p2t2"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position and
texture coordinate attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping you can
do:
|[
CoglVertexP2T2 triangle[] =
{
{ 0,   300,  0.0, 1.0},
{ 150, 0,    0.5, 0.0},
{ 300, 300,  1.0, 1.0}
};
prim = cogl_primitive_new_p2t2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP2T2 vertices</doc>
            <type name="VertexP2T2" c:type="CoglVertexP2T2*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_p2t2c4"
                c:identifier="cogl_primitive_new_p2t2c4"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position, texture
coordinate and color attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping and a
linear gradient you can do:
|[
CoglVertexP2T2C4 triangle[] =
{
{ 0,   300,  0.0, 1.0,  0xff, 0x00, 0x00, 0xff},
{ 150, 0,    0.5, 0.0,  0x00, 0xff, 0x00, 0xff},
{ 300, 300,  1.0, 1.0,  0xff, 0x00, 0x00, 0xff}
};
prim = cogl_primitive_new_p2t2c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP2T2C4 vertices</doc>
            <type name="VertexP2T2C4" c:type="CoglVertexP2T2C4*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_p3"
                c:identifier="cogl_primitive_new_p3"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
attribute with a #CoglAttribute and upload your data.

For example to draw a convex polygon you can do:
|[
CoglVertexP3 triangle[] =
{
{ 0,   300, 0 },
{ 150, 0,   0 },
{ 300, 300, 0 }
};
prim = cogl_primitive_new_p3 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP3 vertices</doc>
            <type name="VertexP3" c:type="CoglVertexP3*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_p3c4"
                c:identifier="cogl_primitive_new_p3c4"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
and color attributes with #CoglAttribute&lt;!-- --&gt;s and upload
your data.

For example to draw a convex polygon with a linear gradient you
can do:
|[
CoglVertexP3C4 triangle[] =
{
{ 0,   300, 0,  0xff, 0x00, 0x00, 0xff },
{ 150, 0,   0,  0x00, 0xff, 0x00, 0xff },
{ 300, 300, 0,  0xff, 0x00, 0x00, 0xff }
};
prim = cogl_primitive_new_p3c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP3C4 vertices</doc>
            <type name="VertexP3C4" c:type="CoglVertexP3C4*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_p3t2"
                c:identifier="cogl_primitive_new_p3t2"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position and
texture coordinate attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping you can
do:
|[
CoglVertexP3T2 triangle[] =
{
{ 0,   300, 0,  0.0, 1.0},
{ 150, 0,   0,  0.5, 0.0},
{ 300, 300, 0,  1.0, 1.0}
};
prim = cogl_primitive_new_p3t2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP3T2 vertices</doc>
            <type name="VertexP3T2" c:type="CoglVertexP3T2*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_p3t2c4"
                c:identifier="cogl_primitive_new_p3t2c4"
                version="1.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position, texture
coordinate and color attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping and a
linear gradient you can do:
|[
CoglVertexP3T2C4 triangle[] =
{
{ 0,   300, 0,  0.0, 1.0,  0xff, 0x00, 0x00, 0xff},
{ 150, 0,   0,  0.5, 0.0,  0x00, 0xff, 0x00, 0xff},
{ 300, 300, 0,  1.0, 1.0,  0xff, 0x00, 0x00, 0xff}
};
prim = cogl_primitive_new_p3t2c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive::n_vertices property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.
&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;

1. This can be freed using cogl_object_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglPrimitive with a reference of</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of vertices to read from @data and also the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #CoglVertexP3T2C4 vertices</doc>
            <type name="VertexP3T2C4" c:type="CoglVertexP3T2C4*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_attributes"
                c:identifier="cogl_primitive_new_with_attributes"
                introspectable="0">
        <return-value>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <type name="Attribute" c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Quaternion" c:type="CoglQuaternion">
      <doc xml:whitespace="preserve">A quaternion is comprised of a scalar component and a 3D vector
component. The scalar component is normally referred to as w and the
vector might either be referred to as v or a (for axis) or expanded
with the individual components: (x, y, z) A full quaternion would
then be written as &lt;pre&gt;[w (x, y, z)]&lt;/pre&gt;.

Quaternions can be considered to represent an axis and angle
pair although sadly these numbers are buried somewhat under some
maths...

For the curious you can see here that a given axis (a) and angle (𝜃)
pair are represented in a quaternion as follows:
|[
[w=cos(𝜃/2) ( x=sin(𝜃/2)*a.x, y=sin(𝜃/2)*a.y, z=sin(𝜃/2)*a.x )]
]|

Unit Quaternions:
When using Quaternions to represent spatial orientations for 3D
graphics it's always assumed you have a unit quaternion. The
magnitude of a quaternion is defined as:
|[
sqrt (w² + x² + y² + z²)
]|
and a unit quaternion satisfies this equation:
|[
w² + x² + y² + z² = 1
]|

Thankfully most of the time we don't actually have to worry about
the maths that goes on behind the scenes but if you are curious to
learn more here are some external references:

&lt;itemizedlist&gt;
&lt;listitem&gt;
&lt;ulink url="http://mathworld.wolfram.com/Quaternion.html"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.gamedev.net/reference/articles/article1095.asp"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.cprogramming.com/tutorial/3d/quaternions.html"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.isner.com/tutorials/quatSpells/quaternion_spells_12.htm"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
3D Maths Primer for Graphics and Game Development ISBN-10: 1556229119
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.cs.caltech.edu/courses/cs171/quatut.pdf"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q56"/&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;

rotation it is sin(𝜃/2)*axis.x
rotation it is sin(𝜃/2)*axis.y
rotation it is sin(𝜃/2)*axis.z</doc>
      <field name="w" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding0" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding1" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding2" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding3" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <method name="copy"
              c:identifier="cogl_quaternion_copy"
              version="2.0"
              introspectable="0">
        <doc xml:whitespace="preserve">Allocates a new #CoglQuaternion on the stack and initializes it with
the same values as @src.

using cogl_quaternion_free()</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglQuaternion which should be freed</doc>
          <type name="Quaternion" c:type="CoglQuaternion*"/>
        </return-value>
      </method>
      <method name="dot_product"
              c:identifier="cogl_quaternion_dot_product"
              version="2.0">
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_quaternion_free" version="2.0">
        <doc xml:whitespace="preserve">Frees a #CoglQuaternion that was previously allocated via
cogl_quaternion_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_rotation_angle"
              c:identifier="cogl_quaternion_get_rotation_angle"
              version="2.0">
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="get_rotation_axis"
              c:identifier="cogl_quaternion_get_rotation_axis"
              version="2.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="vector" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="cogl_quaternion_init" version="2.0">
        <doc xml:whitespace="preserve">Initializes a quaternion that rotates @angle degrees around the
axis vector (@x, @y, @z). The axis vector does not need to be
normalized.

rotated @angle degrees around the axis vector (@x, @y, @z)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A normalized, unit quaternion representing an orientation</doc>
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The angle you want to rotate around the given axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:whitespace="preserve">The x component of your axis vector about which you want to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:whitespace="preserve">The y component of your axis vector about which you want to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:whitespace="preserve">The z component of your axis vector about which you want to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_angle_vector"
              c:identifier="cogl_quaternion_init_from_angle_vector"
              version="2.0">
        <doc xml:whitespace="preserve">Initializes a quaternion that rotates @angle degrees around the
given @axis vector. The axis vector does not need to be
normalized.

rotated @angle degrees around the given @axis vector.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A normalized, unit quaternion representing an orientation</doc>
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="angle" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis" transfer-ownership="none">
            <doc xml:whitespace="preserve">your axis vector about which you want to rotate.</doc>
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_array"
              c:identifier="cogl_quaternion_init_from_array"
              version="2.0">
        <doc xml:whitespace="preserve">Initializes a [w (x, y,z)] quaternion directly from an array of 4
floats: [w,x,y,z].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of 4 floats (x,y,z),w</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_euler"
              c:identifier="cogl_quaternion_init_from_euler">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="euler" transfer-ownership="none">
            <type name="Euler" c:type="CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_x_rotation"
              c:identifier="cogl_quaternion_init_from_x_rotation"
              version="2.0">
        <doc xml:whitespace="preserve">XXX: check which direction this rotates</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The angle to rotate around the x axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_y_rotation"
              c:identifier="cogl_quaternion_init_from_y_rotation"
              version="2.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The angle to rotate around the y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_z_rotation"
              c:identifier="cogl_quaternion_init_from_z_rotation"
              version="2.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The angle to rotate around the y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity"
              c:identifier="cogl_quaternion_init_identity"
              version="2.0">
        <doc xml:whitespace="preserve">Initializes the quaternion with the canonical quaternion identity
[1 (0, 0, 0)] which represents no rotation. Multiplying a
quaternion with this identity leaves the quaternion unchanged.

You might also want to consider using
cogl_get_static_identity_quaternion().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="invert"
              c:identifier="cogl_quaternion_invert"
              version="2.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="multiply"
              c:identifier="cogl_quaternion_multiply"
              version="2.0">
        <doc xml:whitespace="preserve">This combines the rotations of two quaternions into @result. The
operation is not commutative so the order is important because AxB
!= BxA. Cogl follows the standard convention for quaternions here
so the rotations are applied @right to @left. This is similar to the
combining of matrices.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="left" transfer-ownership="none">
            <doc xml:whitespace="preserve">The second #CoglQuaternion rotation to apply</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The first #CoglQuaternion rotation to apply</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="nlerp" c:identifier="cogl_quaternion_nlerp">
        <doc xml:whitespace="preserve">Performs a normalized linear interpolation between two quaternions.
That is it does a linear interpolation of the quaternion components
and then normalizes the result. This will follow the shortest arc
between the two orientations (just like the slerp() function) but
will not progress at a constant speed. Unlike slerp() nlerp is
commutative which is useful if you are blending animations
together. (I.e. nlerp (tmp, a, b) followed by nlerp (result, tmp,
d) is the same as nlerp (tmp, a, d) followed by nlerp (result, tmp,
b)). Finally nlerp is cheaper than slerp so it can be a good choice
if you don't need the constant speed property of the slerp() function.

Notable properties:
&lt;itemizedlist&gt;
&lt;listitem&gt;
commutative: Yes
&lt;/listitem&gt;
&lt;listitem&gt;
constant velocity: No
&lt;/listitem&gt;
&lt;listitem&gt;
torque minimal (travels along the surface of the 4-sphere): Yes
&lt;/listitem&gt;
&lt;listitem&gt;
faster than cogl_quaternion_slerp()
&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="a" transfer-ownership="none">
            <doc xml:whitespace="preserve">The first #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">The second #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:whitespace="preserve">The factor in the range [0,1] used to interpolate between quaterion @a and @b.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize"
              c:identifier="cogl_quaternion_normalize"
              version="2.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="pow" c:identifier="cogl_quaternion_pow" version="2.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="exponent" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="slerp" c:identifier="cogl_quaternion_slerp">
        <doc xml:whitespace="preserve">Performs a spherical linear interpolation between two quaternions.

Noteable properties:
&lt;itemizedlist&gt;
&lt;listitem&gt;
commutative: No
&lt;/listitem&gt;
&lt;listitem&gt;
constant velocity: Yes
&lt;/listitem&gt;
&lt;listitem&gt;
torque minimal (travels along the surface of the 4-sphere): Yes
&lt;/listitem&gt;
&lt;listitem&gt;
more expensive than cogl_quaternion_nlerp()
&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="a" transfer-ownership="none">
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="squad" c:identifier="cogl_quaternion_squad" version="2.0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="prev" transfer-ownership="none">
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="next" transfer-ownership="none">
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal"
                c:identifier="cogl_quaternion_equal"
                version="2.0">
        <doc xml:whitespace="preserve">Compares that all the components of quaternions @a and @b are
equal.

An epsilon value is not used to compare the float components, but
the == operator is at least used so that 0 and -0 are considered
equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the quaternions are equal else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglQuaternion</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglQuaternion</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="RADIANS_TO_DEGREES"
              value="3754936"
              c:type="COGL_RADIANS_TO_DEGREES">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="ReadPixelsFlags"
              version="1.0"
              glib:type-name="CoglReadPixelsFlags"
              glib:get-type="cogl_read_pixels_flags_get_type"
              c:type="CoglReadPixelsFlags">
      <doc xml:whitespace="preserve">Flags for cogl_read_pixels()</doc>
      <member name="color_buffer"
              value="1"
              c:identifier="COGL_READ_PIXELS_COLOR_BUFFER"
              glib:nick="color-buffer"/>
    </bitfield>
    <enumeration name="RendererError"
                 glib:type-name="CoglRendererError"
                 glib:get-type="cogl_renderer_error_get_type"
                 c:type="CoglRendererError">
      <member name="not_found"
              value="0"
              c:identifier="COGL_RENDERER_ERROR_NOT_FOUND"
              glib:nick="not-found"/>
      <member name="xlib_display_open"
              value="1"
              c:identifier="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN"
              glib:nick="xlib-display-open"/>
    </enumeration>
    <constant name="SQRTI_ARG_10_PERCENT"
              value="5590"
              c:type="COGL_SQRTI_ARG_10_PERCENT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SQRTI_ARG_5_PERCENT"
              value="210"
              c:type="COGL_SQRTI_ARG_5_PERCENT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SQRTI_ARG_MAX" value="4194303" c:type="COGL_SQRTI_ARG_MAX">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="ShaderType"
                 version="1.0"
                 glib:type-name="CoglShaderType"
                 glib:get-type="cogl_shader_type_get_type"
                 c:type="CoglShaderType">
      <doc xml:whitespace="preserve">Types of shaders</doc>
      <member name="vertex"
              value="0"
              c:identifier="COGL_SHADER_TYPE_VERTEX"
              glib:nick="vertex"/>
      <member name="fragment"
              value="1"
              c:identifier="COGL_SHADER_TYPE_FRAGMENT"
              glib:nick="fragment"/>
    </enumeration>
    <record name="SubTexture" c:type="CoglSubTexture" disguised="1">
      <method name="get_parent"
              c:identifier="cogl_sub_texture_get_parent"
              version="1.10">
        <doc xml:whitespace="preserve">Retrieves the parent texture that @sub_texture derives its content
from.  This is the texture that was passed to
cogl_sub_texture_new() as the parent_texture argument.

derives its content from.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The parent texture that @sub_texture</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
      </method>
      <function name="new_EXP"
                c:identifier="cogl_sub_texture_new_EXP"
                introspectable="0">
        <return-value>
          <type name="SubTexture" c:type="CoglSubTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="parent_texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
          <parameter name="sub_x" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_y" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="SwapBuffersNotify" c:type="CoglSwapBuffersNotify">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="framebuffer" transfer-ownership="none">
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="TEXTURE_MAX_WASTE"
              value="127"
              c:type="COGL_TEXTURE_MAX_WASTE">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Texture" c:type="CoglTexture" disguised="1">
      <method name="get_data" c:identifier="cogl_texture_get_data">
        <doc xml:whitespace="preserve">Copies the pixel data from a cogl texture to system memory.

&lt;note&gt;Don't pass the value of cogl_texture_get_rowstride() as the
@rowstride argument, the rowstride should be the rowstride you
want for the destination @data buffer not the rowstride of the
source texture&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the texture data in bytes</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #CoglPixelFormat to store the texture as.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rowstride of @data in bytes or pass 0 to calculate from the bytes-per-pixel of @format multiplied by the @texture width.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">memory location to write the @texture's contents, or %NULL to only query the data size through the return value.</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="cogl_texture_get_format">
        <doc xml:whitespace="preserve">Queries the #CoglPixelFormat of a cogl texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #CoglPixelFormat of the GPU side texture</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </return-value>
      </method>
      <method name="get_gl_texture" c:identifier="cogl_texture_get_gl_texture">
        <doc xml:whitespace="preserve">Queries the GL handles for a GPU side texture through its #CoglTexture.

If the texture is spliced the data for the first sub texture will be
queried.

if the handle was invalid</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the handle was successfully retrieved, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="out_gl_handle"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer to return location for the textures GL handle, or %NULL.</doc>
            <type name="GL.uint" c:type="GLuint*"/>
          </parameter>
          <parameter name="out_gl_target"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer to return location for the GL target type, or %NULL.</doc>
            <type name="GL.enum" c:type="GLenum*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_texture_get_height">
        <doc xml:whitespace="preserve">Queries the height of a cogl texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the height of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
      </method>
      <method name="get_max_waste" c:identifier="cogl_texture_get_max_waste">
        <doc xml:whitespace="preserve">Queries the maximum wasted (unused) pixels in one dimension of a GPU side
texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the maximum waste</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="get_rowstride"
              c:identifier="cogl_texture_get_rowstride"
              deprecated="There&apos;s no replacement for the API but there&apos;s"
              deprecated-version="1.10">
        <doc xml:whitespace="preserve">Determines the bytes-per-pixel for the #CoglPixelFormat retrieved
from cogl_texture_get_format() and multiplies that by the texture's
width.

&lt;note&gt;It's very unlikely that anyone would need to use this API to
query the internal rowstride of a #CoglTexture which can just be
considered an implementation detail. Actually it's not even useful
internally since underlying drivers are free to use a different
format&lt;/note&gt;

&lt;/note&gt;This API is only here for backwards compatibility and
shouldn't be used in new code. In particular please don't be
mislead to pass the returned value to cogl_texture_get_data() for
the rowstride, since you should be passing the rowstride you desire
for your destination buffer not the rowstride of the source
texture.&lt;/note&gt;

multiplied by the texture's width

also no known need for API either. It was just
a mistake that it was ever published.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The bytes-per-pixel for the current format</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
      </method>
      <method name="get_width" c:identifier="cogl_texture_get_width">
        <doc xml:whitespace="preserve">Queries the width of a cogl texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the width of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
      </method>
      <method name="is_sliced" c:identifier="cogl_texture_is_sliced">
        <doc xml:whitespace="preserve">Queries if a texture is sliced (stored as multiple GPU side tecture
objects).

is stored as a single GPU texture</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the texture is sliced, %FALSE if the texture</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="new_from_sub_texture"
              c:identifier="cogl_texture_new_from_sub_texture"
              version="1.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a new texture which represents a subregion of another
texture. The GL resources will be shared so that no new texture
data is actually allocated.

Sub textures have undefined behaviour texture coordinates outside
of the range [0,1] are used. They also do not work with
CoglVertexBuffers.

The sub texture will keep a reference to the full texture so you do
not need to keep one separately if you only want to use the sub
texture.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly created #CoglTexture or %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="sub_x" transfer-ownership="none">
            <doc xml:whitespace="preserve">X coordinate of the top-left of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_y" transfer-ownership="none">
            <doc xml:whitespace="preserve">Y coordinate of the top-left of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">Width in pixels of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">Height in pixels of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region" c:identifier="cogl_texture_set_region">
        <doc xml:whitespace="preserve">Sets the pixels in a rectangular subregion of @texture from an in-memory
buffer containing pixel data.

&lt;note&gt;The region set can't be larger than the source @data&lt;/note&gt;

%FALSE otherwise</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the subregion upload was successful, and</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:whitespace="preserve">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:whitespace="preserve">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:whitespace="preserve">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:whitespace="preserve">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">width of destination region to write. (Must be less than or equal to @width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">height of destination region to write. (Must be less than or equal to @height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:whitespace="preserve">width of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:whitespace="preserve">height of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #CoglPixelFormat used in the source buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:whitespace="preserve">rowstride of source buffer (computed from width if none specified)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the actual pixel data.</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <function name="2d_new_from_data_EXP"
                c:identifier="cogl_texture_2d_new_from_data_EXP"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </function>
      <function name="2d_new_from_foreign_EXP"
                c:identifier="cogl_texture_2d_new_from_foreign_EXP"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="gl_handle" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="2d_new_with_size_EXP"
                c:identifier="cogl_texture_2d_new_with_size_EXP"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="2d_sliced_new_with_size"
                c:identifier="cogl_texture_2d_sliced_new_with_size"
                version="1.10"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Creates a #CoglTexture2DSliced that may internally be comprised of
1 or more #CoglTexture2D textures with power-of-two sizes.
@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller power-of-two sizes
until the wasted padding at the bottom and right of the
power-of-two textures is less than specified.

an error allocating any of the internal slices %NULL is
returned and @error is updated.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated #CoglTexture2DSliced or if there was</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:whitespace="preserve">The virtual width of your sliced texture.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:whitespace="preserve">The virtual height of your sliced texture.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:whitespace="preserve">The threshold of how wide a strip of wasted texels are allowed in the non-power-of-two textures before they must be sliced to reduce the amount of waste.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the texture</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="3d_new_from_data_EXP"
                c:identifier="cogl_texture_3d_new_from_data_EXP"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="image_stride" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </function>
      <function name="3d_new_with_size_EXP"
                c:identifier="cogl_texture_3d_new_with_size_EXP"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_bitmap"
                c:identifier="cogl_texture_new_from_bitmap"
                version="1.0"
                introspectable="0">
        <doc xml:whitespace="preserve">Creates a #CoglTexture from a #CoglBitmap.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly created #CoglTexture or %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #CoglBitmap pointer</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #CoglPixelFormat to use for the GPU storage of the texture</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_data"
                c:identifier="cogl_texture_new_from_data"
                version="0.8"
                introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #CoglTexture based on data residing in memory.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly created #CoglTexture or %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:whitespace="preserve">width of texture in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:whitespace="preserve">height of texture in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #CoglPixelFormat that will be used for storing the buffer on the GPU. If COGL_PIXEL_FORMAT_ANY is given then a premultiplied format similar to the format of the source data will be used. The default blending equations of Cogl expect premultiplied color data; the main use of passing a non-premultiplied format here is if you have non-premultiplied source data and are going to adjust the blend mode (see cogl_material_set_blend()) or use the data for something other than straight blending.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:whitespace="preserve">the memory offset in bytes between the starts of scanlines in @data</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_file"
                c:identifier="cogl_texture_new_from_file"
                version="0.8"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Creates a #CoglTexture from an image file.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly created #CoglTexture or %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the file to load</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #CoglPixelFormat to use for the GPU storage of the texture. If %COGL_PIXEL_FORMAT_ANY is given then a premultiplied format similar to the format of the source data will be used. The default blending equations of Cogl expect premultiplied color data; the main use of passing a non-premultiplied format here is if you have non-premultiplied source data and are going to adjust the blend mode (see cogl_material_set_blend()) or use the data for something other than straight blending.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_foreign"
                c:identifier="cogl_texture_new_from_foreign"
                version="0.8"
                introspectable="0">
        <doc xml:whitespace="preserve">Creates a #CoglTexture based on an existing OpenGL texture; the
width, height and format are passed along since it is not always
possible to query these from OpenGL.

The waste arguments allow you to create a Cogl texture that maps to
a region smaller than the real OpenGL texture. For instance if your
hardware only supports power-of-two textures you may load a
non-power-of-two image into a larger power-of-two texture and use
the waste arguments to tell Cogl which region should be mapped to
the texture coordinate range [0:1].</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly created #CoglTexture or %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="gl_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">opengl handle of foreign texture.</doc>
            <type name="GL.uint" c:type="GLuint"/>
          </parameter>
          <parameter name="gl_target" transfer-ownership="none">
            <doc xml:whitespace="preserve">opengl target type of foreign texture</doc>
            <type name="GL.enum" c:type="GLenum"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:whitespace="preserve">width of foreign texture</doc>
            <type name="GL.uint" c:type="GLuint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:whitespace="preserve">height of foreign texture.</doc>
            <type name="GL.uint" c:type="GLuint"/>
          </parameter>
          <parameter name="x_pot_waste" transfer-ownership="none">
            <doc xml:whitespace="preserve">horizontal waste on the right hand edge of the texture.</doc>
            <type name="GL.uint" c:type="GLuint"/>
          </parameter>
          <parameter name="y_pot_waste" transfer-ownership="none">
            <doc xml:whitespace="preserve">vertical waste on the bottom edge of the texture.</doc>
            <type name="GL.uint" c:type="GLuint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">format of the foreign texture.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_size"
                c:identifier="cogl_texture_new_with_size"
                version="0.8"
                introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #CoglTexture with the specified dimensions and pixel format.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly created #CoglTexture or %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:whitespace="preserve">width of texture in pixels.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:whitespace="preserve">height of texture in pixels.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #CoglPixelFormat to use for the GPU storage of the texture.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="ref"
                c:identifier="cogl_texture_ref"
                introspectable="0"
                deprecated="Use cogl_object_ref() instead"
                deprecated-version="1.2">
        <doc xml:whitespace="preserve">Increment the reference count for a cogl texture.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the @texture pointer.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglTexture.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_texture_unref"
                deprecated="Use cogl_object_unref() instead"
                deprecated-version="1.2">
        <doc xml:whitespace="preserve">Decrement the reference count for a cogl texture.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #CoglTexture.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Texture2D" c:type="CoglTexture2D" disguised="1">
    </record>
    <record name="Texture2DSliced" c:type="CoglTexture2DSliced" disguised="1">
    </record>
    <enumeration name="TextureError"
                 version="2.0"
                 glib:type-name="CoglTextureError"
                 glib:get-type="cogl_texture_error_get_type"
                 c:type="CoglTextureError"
                 glib:error-domain="cogl-texture-error-quark">
      <doc xml:whitespace="preserve">Error codes that can be thrown when allocating textures.</doc>
      <member name="size"
              value="0"
              c:identifier="COGL_TEXTURE_ERROR_SIZE"
              glib:nick="size"/>
      <member name="format"
              value="1"
              c:identifier="COGL_TEXTURE_ERROR_FORMAT"
              glib:nick="format"/>
      <member name="bad_parameter"
              value="2"
              c:identifier="COGL_TEXTURE_ERROR_BAD_PARAMETER"
              glib:nick="bad-parameter"/>
      <member name="type"
              value="3"
              c:identifier="COGL_TEXTURE_ERROR_TYPE"
              glib:nick="type"/>
      <function name="quark" c:identifier="cogl_texture_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="TextureFlags"
              version="1.0"
              glib:type-name="CoglTextureFlags"
              glib:get-type="cogl_texture_flags_get_type"
              c:type="CoglTextureFlags">
      <doc xml:whitespace="preserve">Flags to pass to the cogl_texture_new_* family of functions.</doc>
      <member name="none"
              value="0"
              c:identifier="COGL_TEXTURE_NONE"
              glib:nick="none"/>
      <member name="no_auto_mipmap"
              value="1"
              c:identifier="COGL_TEXTURE_NO_AUTO_MIPMAP"
              glib:nick="no-auto-mipmap"/>
      <member name="no_slicing"
              value="2"
              c:identifier="COGL_TEXTURE_NO_SLICING"
              glib:nick="no-slicing"/>
      <member name="no_atlas"
              value="4"
              c:identifier="COGL_TEXTURE_NO_ATLAS"
              glib:nick="no-atlas"/>
    </bitfield>
    <record name="TextureRectangle"
            c:type="CoglTextureRectangle"
            disguised="1">
      <function name="new_with_size_EXP"
                c:identifier="cogl_texture_rectangle_new_with_size_EXP"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="TextureRectangle" c:type="CoglTextureRectangle*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="TextureVertex" c:type="CoglTextureVertex">
      <doc xml:whitespace="preserve">Used to specify vertex information when calling cogl_polygon()</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="tx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ty" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <type name="Color" c:type="CoglColor"/>
      </field>
    </record>
    <constant name="UNORDERED_MASK" value="15" c:type="COGL_UNORDERED_MASK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="UNPREMULT_MASK" value="127" c:type="COGL_UNPREMULT_MASK">
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="UserDataDestroyCallback"
              c:type="CoglUserDataDestroyCallback"
              version="1.4">
      <doc xml:whitespace="preserve">When associating private data with a #CoglObject a callback can be
given which will be called either if the object is destroyed or if
cogl_object_set_user_data() is called with NULL user_data for the
same key.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" closure="0">
          <doc xml:whitespace="preserve">The data whos association with a #CoglObject has been destoyed.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="UserDataKey" c:type="CoglUserDataKey" version="1.4">
      <doc xml:whitespace="preserve">A #CoglUserDataKey is used to declare a key for attaching data to a
#CoglObject using cogl_object_set_user_data. The typedef only exists as a
formality to make code self documenting since only the unique address of a
#CoglUserDataKey is used.

Typically you would declare a static #CoglUserDataKey and set private data
on an object something like this:

|[
static CoglUserDataKey path_private_key;

static void
destroy_path_private_cb (void *data)
{
g_free (data);
}

static void
my_path_set_data (CoglPath *path, void *data)
{
cogl_object_set_user_data (COGL_OBJECT (path),
&amp;private_key,
data,
destroy_path_private_cb);
}
]|</doc>
      <field name="unused" writable="1">
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <record name="Vector3" c:type="CoglVector3">
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <method name="add_EXP" c:identifier="cogl_vector3_add_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="a" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_EXP"
              c:identifier="cogl_vector3_copy_EXP"
              introspectable="0">
        <return-value>
          <type name="Vector3" c:type="CoglVector3*"/>
        </return-value>
      </method>
      <method name="cross_product_EXP"
              c:identifier="cogl_vector3_cross_product_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="u" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
          <parameter name="v" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="distance_EXP" c:identifier="cogl_vector3_distance_EXP">
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="divide_scalar_EXP"
              c:identifier="cogl_vector3_divide_scalar_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="scalar" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="dot_product_EXP"
              c:identifier="cogl_vector3_dot_product_EXP">
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <parameter name="b" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_with_epsilon_EXP"
              c:identifier="cogl_vector3_equal_with_epsilon_EXP">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="vector1" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
          <parameter name="epsilon" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_EXP" c:identifier="cogl_vector3_free_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init_EXP" c:identifier="cogl_vector3_init_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_zero_EXP" c:identifier="cogl_vector3_init_zero_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="invert_EXP" c:identifier="cogl_vector3_invert_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="magnitude_EXP" c:identifier="cogl_vector3_magnitude_EXP">
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
      </method>
      <method name="multiply_scalar_EXP"
              c:identifier="cogl_vector3_multiply_scalar_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="scalar" transfer-ownership="none">
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize_EXP" c:identifier="cogl_vector3_normalize_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="subtract_EXP" c:identifier="cogl_vector3_subtract_EXP">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="a" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Vector3" c:type="CoglVector3*"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal_EXP" c:identifier="cogl_vector3_equal_EXP">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1" transfer-ownership="none">
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="v2" transfer-ownership="none">
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="VertexP2" c:type="CoglVertexP2" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v2_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP2C4" c:type="CoglVertexP2C4" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v2c4_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="g" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="b" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="a" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
    </record>
    <record name="VertexP2T2" c:type="CoglVertexP2T2" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v2t2_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP2T2C4" c:type="CoglVertexP2T2C4" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v3t2c4_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="g" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="b" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="a" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
    </record>
    <record name="VertexP3" c:type="CoglVertexP3" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v3_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP3C4" c:type="CoglVertexP3C4" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v3c4_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="g" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="b" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="a" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
    </record>
    <record name="VertexP3T2" c:type="CoglVertexP3T2" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v3t2_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP3T2C4" c:type="CoglVertexP3T2C4" version="1.6">
      <doc xml:whitespace="preserve">A convenience vertex definition that can be used with
cogl_primitive_new_with_v3t2c4_attributes().</doc>
      <field name="x" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="g" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="b" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="a" writable="1">
        <type name="guint8" c:type="guint8"/>
      </field>
    </record>
    <enumeration name="VerticesMode"
                 version="1.0"
                 glib:type-name="CoglVerticesMode"
                 glib:get-type="cogl_vertices_mode_get_type"
                 c:type="CoglVerticesMode">
      <doc xml:whitespace="preserve">Different ways of interpreting vertices when drawing.</doc>
      <member name="points"
              value="0"
              c:identifier="COGL_VERTICES_MODE_POINTS"
              glib:nick="points"/>
      <member name="lines"
              value="1"
              c:identifier="COGL_VERTICES_MODE_LINES"
              glib:nick="lines"/>
      <member name="line_loop"
              value="2"
              c:identifier="COGL_VERTICES_MODE_LINE_LOOP"
              glib:nick="line-loop"/>
      <member name="line_strip"
              value="3"
              c:identifier="COGL_VERTICES_MODE_LINE_STRIP"
              glib:nick="line-strip"/>
      <member name="triangles"
              value="4"
              c:identifier="COGL_VERTICES_MODE_TRIANGLES"
              glib:nick="triangles"/>
      <member name="triangle_strip"
              value="5"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_STRIP"
              glib:nick="triangle-strip"/>
      <member name="triangle_fan"
              value="6"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_FAN"
              glib:nick="triangle-fan"/>
    </enumeration>
    <enumeration name="Winding"
                 glib:type-name="CoglWinding"
                 glib:get-type="cogl_winding_get_type"
                 c:type="CoglWinding">
      <doc xml:whitespace="preserve">Enum used to represent the two directions of rotation. This can be
used to set the front face for culling by calling
cogl_pipeline_set_front_face_winding().</doc>
      <member name="clockwise"
              value="0"
              c:identifier="COGL_WINDING_CLOCKWISE"
              glib:nick="clockwise"/>
      <member name="counter_clockwise"
              value="1"
              c:identifier="COGL_WINDING_COUNTER_CLOCKWISE"
              glib:nick="counter-clockwise"/>
    </enumeration>
    <enumeration name="WinsysFeature"
                 glib:type-name="CoglWinsysFeature"
                 glib:get-type="cogl_winsys_feature_get_type"
                 c:type="CoglWinsysFeature">
      <member name="multiple_onscreen"
              value="0"
              c:identifier="COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN"
              glib:nick="multiple-onscreen"/>
      <member name="swap_throttle"
              value="1"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_THROTTLE"
              glib:nick="swap-throttle"/>
      <member name="vblank_counter"
              value="2"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_COUNTER"
              glib:nick="vblank-counter"/>
      <member name="vblank_wait"
              value="3"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_WAIT"
              glib:nick="vblank-wait"/>
      <member name="texture_from_pixmap"
              value="4"
              c:identifier="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP"
              glib:nick="texture-from-pixmap"/>
      <member name="swap_buffers_event"
              value="5"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT"
              glib:nick="swap-buffers-event"/>
      <member name="swap_region"
              value="6"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION"
              glib:nick="swap-region"/>
      <member name="swap_region_throttle"
              value="7"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE"
              glib:nick="swap-region-throttle"/>
      <member name="swap_region_synchronized"
              value="8"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED"
              glib:nick="swap-region-synchronized"/>
      <member name="n_features"
              value="9"
              c:identifier="COGL_WINSYS_FEATURE_N_FEATURES"
              glib:nick="n-features"/>
    </enumeration>
    <callback name="XlibFilterFunc"
              c:type="CoglXlibFilterFunc"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="event" transfer-ownership="none">
          <type c:type="XEvent*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="_ColorSizeCheck" c:type="_CoglColorSizeCheck">
      <field name="compile_time_assert_CoglColor_size" writable="1">
        <array zero-terminated="0" c:type="gchar" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_EulerSizeCheck" c:type="_CoglEulerSizeCheck">
      <field name="compile_time_assert_CoglEuler_size" writable="1">
        <array zero-terminated="0" c:type="gchar" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_MatrixSizeCheck" c:type="_CoglMatrixSizeCheck">
      <field name="compile_time_assert_CoglMatrix_size" writable="1">
        <array zero-terminated="0" c:type="gchar" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_QuaternionSizeCheck" c:type="_CoglQuaternionSizeCheck">
      <field name="compile_time_assert_CoglQuaternion_size" writable="1">
        <array zero-terminated="0" c:type="gchar" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_TextureVertexSizeCheck"
            c:type="_CoglTextureVertexSizeCheck">
      <field name="compile_time_assert_CoglTextureVertex_size" writable="1">
        <array zero-terminated="0" c:type="gchar" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <function name="angle_cos"
              c:identifier="cogl_angle_cos"
              version="1.0"
              introspectable="0">
      <doc xml:whitespace="preserve">Computes the cosine of @angle</doc>
      <return-value>
        <doc xml:whitespace="preserve">the cosine of the passed angle</doc>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:whitespace="preserve">an angle expressed using #CoglAngle</doc>
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="angle_sin"
              c:identifier="cogl_angle_sin"
              version="1.0"
              introspectable="0">
      <doc xml:whitespace="preserve">Computes the sine of @angle</doc>
      <return-value>
        <doc xml:whitespace="preserve">the sine of the passed angle</doc>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:whitespace="preserve">an angle expressed using #CoglAngle</doc>
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="angle_tan"
              c:identifier="cogl_angle_tan"
              version="1.0"
              introspectable="0">
      <doc xml:whitespace="preserve">Computes the tangent of @angle</doc>
      <return-value>
        <doc xml:whitespace="preserve">the tangent of the passed angle</doc>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:whitespace="preserve">an angle expressed using #CoglAngle</doc>
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="begin_gl" c:identifier="cogl_begin_gl" version="1.0">
      <doc xml:whitespace="preserve">We do not advise nor reliably support the interleaving of raw GL drawing and
Cogl drawing functions, but if you insist, cogl_begin_gl() and cogl_end_gl()
provide a simple mechanism that may at least give you a fighting chance of
succeeding.

Note: this doesn't help you modify the behaviour of Cogl drawing functions
through the modification of GL state; that will never be reliably supported,
but if you are trying to do something like:

|[
{
- setup some OpenGL state.
- draw using OpenGL (e.g. glDrawArrays() )
- reset modified OpenGL state.
- continue using Cogl to draw
}
]|

You should surround blocks of drawing using raw GL with cogl_begin_gl()
and cogl_end_gl():

|[
{
cogl_begin_gl ();
- setup some OpenGL state.
- draw using OpenGL (e.g. glDrawArrays() )
- reset modified OpenGL state.
cogl_end_gl ();
- continue using Cogl to draw
}
]|

Don't ever try and do:

|[
{
- setup some OpenGL state.
- use Cogl to draw
- reset modified OpenGL state.
}
]|

When the internals of Cogl evolves, this is very liable to break.

This function will flush all batched primitives, and subsequently flush
all internal Cogl state to OpenGL as if it were going to draw something
itself.

The result is that the OpenGL modelview matrix will be setup; the state
corresponding to the current source material will be set up and other world
state such as backface culling, depth and fogging enabledness will be sent
to OpenGL.

&lt;note&gt;No special material state is flushed, so if you want Cogl to setup a
simplified material state it is your responsibility to set a simple source
material before calling cogl_begin_gl(). E.g. by calling
cogl_set_source_color4ub().&lt;/note&gt;

&lt;note&gt;It is your responsibility to restore any OpenGL state that you modify
to how it was after calling cogl_begin_gl() if you don't do this then the
result of further Cogl calls is undefined.&lt;/note&gt;

&lt;note&gt;You can not nest begin/end blocks.&lt;/note&gt;

Again we would like to stress, we do not advise the use of this API and if
possible we would prefer to improve Cogl than have developers require raw
OpenGL.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="bitmap_error_quark"
              c:identifier="cogl_bitmap_error_quark"
              moved-to="BitmapError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="bitmap_get_size_from_file"
              c:identifier="cogl_bitmap_get_size_from_file"
              moved-to="Bitmap.get_size_from_file"
              version="1.0">
      <doc xml:whitespace="preserve">Parses an image file enough to extract the width and height
of the bitmap.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the image was successfully parsed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">the file to check</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="width"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">return location for the bitmap width, or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="height"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">return location for the bitmap height, or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="blend_string_error_quark"
              c:identifier="cogl_blend_string_error_quark"
              moved-to="BlendStringError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="check_extension"
              c:identifier="cogl_check_extension"
              deprecated="OpenGL is an implementation detail for Cogl and so it&apos;s"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Check whether @name occurs in list of extensions in @ext.


not appropriate to expose OpenGL extensions through the Cogl API. This
function can be replaced by the following equivalent code:
|[
gboolean retval = (strstr (ext, name) != NULL) ? TRUE : FALSE;
]|</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the extension occurs in the list, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">extension to check for</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <doc xml:whitespace="preserve">list of extensions</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear" c:identifier="cogl_clear">
      <doc xml:whitespace="preserve">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <doc xml:whitespace="preserve">Background color to clear to</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="buffers" transfer-ownership="none">
          <doc xml:whitespace="preserve">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary buffers to clear</doc>
          <type name="gulong" c:type="unsigned long"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_ensure"
              c:identifier="cogl_clip_ensure"
              version="1.0"
              deprecated="Calling this function has no effect"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Ensures that the current clipping region has been set in GL. This
will automatically be called before any Cogl primitives but it
maybe be neccessary to call if you are using raw GL calls with
clipping.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_pop" c:identifier="cogl_clip_pop">
      <doc xml:whitespace="preserve">Reverts the clipping region to the state before the last call to
cogl_clip_push().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_push"
              c:identifier="cogl_clip_push"
              deprecated="The x, y, width, height arguments are inconsistent"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().

with other API that specify rectangles in model space, and when used
with a coordinate space that puts the origin at the center and y+
extending up, it's awkward to use. Please use cogl_clip_push_rectangle()
instead</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">left edge of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">top edge of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">width of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">height of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_from_path"
              c:identifier="cogl_clip_push_from_path"
              version="1.0">
      <doc xml:whitespace="preserve">Sets a new clipping area using the current path. The current path
is then cleared. The clipping area is intersected with the previous
clipping area. To restore the previous clipping area, call
cogl_clip_pop().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_push_from_path_preserve"
              c:identifier="cogl_clip_push_from_path_preserve"
              version="1.0">
      <doc xml:whitespace="preserve">Sets a new clipping area using the current path. The current path
is then cleared. The clipping area is intersected with the previous
clipping area. To restore the previous clipping area, call
cogl_clip_pop().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_push_rectangle"
              c:identifier="cogl_clip_push_rectangle"
              version="1.2">
      <doc xml:whitespace="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x0" transfer-ownership="none">
          <doc xml:whitespace="preserve">x coordinate for top left corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y0" transfer-ownership="none">
          <doc xml:whitespace="preserve">y coordinate for top left corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:whitespace="preserve">x coordinate for bottom right corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:whitespace="preserve">y coordinate for bottom right corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_window_rect"
              c:identifier="cogl_clip_push_window_rect"
              deprecated="Use cogl_clip_push_window_rectangle() instead"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">left edge of the clip rectangle in window coordinates</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">top edge of the clip rectangle in window coordinates</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">width of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">height of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_window_rectangle"
              c:identifier="cogl_clip_push_window_rectangle"
              version="1.2">
      <doc xml:whitespace="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">left edge of the clip rectangle in window coordinates</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">top edge of the clip rectangle in window coordinates</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">width of the clip rectangle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">height of the clip rectangle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_stack_restore"
              c:identifier="cogl_clip_stack_restore"
              version="0.8.2"
              deprecated="This was originally added to allow us to restore"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Restore the state of the clipping stack that was previously saved
by cogl_clip_stack_save().

the clip stack when switching back from an offscreen framebuffer,
but it's not necessary anymore given that framebuffers now own
separate clip stacks which will be automatically switched between
when a new buffer is set. Calling this function has no effect</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_stack_save"
              c:identifier="cogl_clip_stack_save"
              version="0.8.2"
              deprecated="This was originally added to allow us to save the"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Save the entire state of the clipping stack and then clear all
clipping. The previous state can be returned to with
cogl_clip_stack_restore(). Each call to cogl_clip_push() after this
must be matched by a call to cogl_clip_pop() before calling
cogl_clip_stack_restore().

clip stack when switching to an offscreen framebuffer, but it's
not necessary anymore given that framebuffers now own separate
clip stacks which will be automatically switched between when a
new buffer is set. Calling this function has no effect</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clutter_check_extension_CLUTTER"
              c:identifier="cogl_clutter_check_extension_CLUTTER">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clutter_winsys_has_feature_CLUTTER"
              c:identifier="cogl_clutter_winsys_has_feature_CLUTTER">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <type name="WinsysFeature" c:type="CoglWinsysFeature"/>
        </parameter>
      </parameters>
    </function>
    <function name="clutter_winsys_xlib_get_visual_info_CLUTTER"
              c:identifier="cogl_clutter_winsys_xlib_get_visual_info_CLUTTER"
              introspectable="0">
      <return-value>
        <type c:type="XVisualInfo*"/>
      </return-value>
    </function>
    <function name="color_equal"
              c:identifier="cogl_color_equal"
              moved-to="Color.equal"
              version="1.0">
      <doc xml:whitespace="preserve">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the two colors are the same.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglColor</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglColor</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_program"
              c:identifier="cogl_create_program"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new cogl program object that can be used to replace parts of the GL
rendering pipeline with custom code.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new cogl program.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
    </function>
    <function name="create_shader"
              c:identifier="cogl_create_shader"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new shader handle, use cogl_shader_source() to set the
source code to be used on it.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new shader handle.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="shader_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">COGL_SHADER_TYPE_VERTEX or COGL_SHADER_TYPE_FRAGMENT.</doc>
          <type name="ShaderType" c:type="CoglShaderType"/>
        </parameter>
      </parameters>
    </function>
    <function name="disable_fog" c:identifier="cogl_disable_fog">
      <doc xml:whitespace="preserve">This function disables fogging, so primitives drawn afterwards will not be
blended with any previously set fog color.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="double_to_fixed"
              c:identifier="cogl_double_to_fixed"
              introspectable="0">
      <return-value>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_to_int" c:identifier="cogl_double_to_int">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_to_uint" c:identifier="cogl_double_to_uint">
      <return-value transfer-ownership="none">
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_attributes" c:identifier="cogl_draw_attributes">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first_vertex" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <type name="Attribute" c:type="CoglAttribute**"/>
        </parameter>
        <parameter name="n_attributes" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="draw_indexed_attributes"
              c:identifier="cogl_draw_indexed_attributes">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first_vertex" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="indices" transfer-ownership="none">
          <type name="Indices" c:type="CoglIndices*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <type name="Attribute" c:type="CoglAttribute**"/>
        </parameter>
        <parameter name="n_attributes" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="end_gl" c:identifier="cogl_end_gl" version="1.0">
      <doc xml:whitespace="preserve">This is the counterpart to cogl_begin_gl() used to delimit blocks of drawing
code using raw OpenGL. Please refer to cogl_begin_gl() for full details.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="euler_equal"
              c:identifier="cogl_euler_equal"
              moved-to="Euler.equal"
              version="2.0">
      <doc xml:whitespace="preserve">Compares the two given euler angles @v1 and @v1 and it they are
equal returns %TRUE else %FALSE.

&lt;note&gt;This function only checks that all three components rotations
are numerically equal, it does not consider that some rotations
can be represented with different component rotations&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @v1 and @v2 are equal else %FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:whitespace="preserve">The second euler angle to compare</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="features_available" c:identifier="cogl_features_available">
      <doc xml:whitespace="preserve">Checks whether the given COGL features are available. Multiple
features can be checked for by or-ing them together with the '|'
operator. %TRUE is only returned if all of the requested features
are available.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the features are available, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="features" transfer-ownership="none">
          <doc xml:whitespace="preserve">A bitmask of features to check for</doc>
          <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="flush" c:identifier="cogl_flush" version="1.0">
      <doc xml:whitespace="preserve">This function should only need to be called in exceptional circumstances.

As an optimization Cogl drawing functions may batch up primitives
internally, so if you are trying to use raw GL outside of Cogl you stand a
better chance of being successful if you ask Cogl to flush any batched
geometry before making your state changes.

It only ensure that the underlying driver is issued all the commands
necessary to draw the batched primitives. It provides no guarantees about
when the driver will complete the rendering.

This provides no guarantees about the GL state upon returning and to avoid
confusing Cogl you should aim to restore any changes you make before
resuming use of Cogl.

If you are making state changes with the intention of affecting Cogl drawing
primitives you are 100% on your own since you stand a good chance of
conflicting with Cogl internals. For example clutter-gst which currently
uses direct GL calls to bind ARBfp programs will very likely break when Cogl
starts to use ARBfb programs itself for the material API.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="framebuffer_error_quark_EXP"
              c:identifier="cogl_framebuffer_error_quark_EXP"
              moved-to="FramebufferError.quark_EXP">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="frustum" c:identifier="cogl_frustum" version="0.8.2">
      <doc xml:whitespace="preserve">Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">X position of the left clipping plane where it intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">X position of the right clipping plane where it intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y position of the bottom clipping plane where it intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y position of the top clipping plane where it intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:whitespace="preserve">The distance to the near clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:whitespace="preserve">The distance to the far clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_backface_culling_enabled"
              c:identifier="cogl_get_backface_culling_enabled">
      <doc xml:whitespace="preserve">Queries if backface culling has been enabled via
cogl_set_backface_culling_enabled()</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if backface culling is enabled, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="get_bitmasks" c:identifier="cogl_get_bitmasks">
      <doc xml:whitespace="preserve">Gets the number of bitplanes used for each of the color components
in the color buffer. Pass %NULL for any of the arguments if the
value is not required.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Return location for the number of red bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="green"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Return location for the number of green bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="blue"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Return location for the number of blue bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="alpha"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Return location for the number of alpha bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_depth_test_enabled"
              c:identifier="cogl_get_depth_test_enabled"
              deprecated="Use cogl_material_get_depth_test_enabled()"
              deprecated-version="1.4">
      <doc xml:whitespace="preserve">Queries if depth testing has been enabled via cogl_set_depth_test_enable()


instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if depth testing is enabled, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="get_features"
              c:identifier="cogl_get_features"
              version="0.8">
      <doc xml:whitespace="preserve">Returns all of the features supported by COGL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A logical OR of all the supported COGL features.</doc>
        <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
      </return-value>
    </function>
    <function name="get_modelview_matrix"
              c:identifier="cogl_get_modelview_matrix">
      <doc xml:whitespace="preserve">Stores the current model-view matrix in @matrix.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">return location for the model-view matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_option_group"
              c:identifier="cogl_get_option_group"
              version="1.0"
              introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the #GOptionGroup used by COGL to parse the command
line options. Clutter uses this to handle the COGL command line
options during its initialization process.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a #GOptionGroup</doc>
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="get_path"
              c:identifier="cogl_get_path"
              version="1.4"
              introspectable="0">
      <doc xml:whitespace="preserve">Gets a pointer to the current path. The path can later be used
again by calling cogl_path_set(). Note that the path isn't copied
so if you later call any functions to add to the path it will
affect the returned object too. No reference is taken on the path
so if you want to retain it you should take your own reference with
cogl_object_ref().</doc>
      <return-value>
        <doc xml:whitespace="preserve">a pointer to the current path.</doc>
        <type name="Path" c:type="CoglPath*"/>
      </return-value>
    </function>
    <function name="get_proc_address"
              c:identifier="cogl_get_proc_address"
              introspectable="0">
      <doc xml:whitespace="preserve">Gets a pointer to a given GL or GL ES extension function. This acts
as a wrapper around glXGetProcAddress() or whatever is the
appropriate function for the current backend.

function is not available.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a pointer to the requested function or %NULL if the</doc>
        <type name="FuncPtr" c:type="CoglFuncPtr"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the function.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_projection_matrix"
              c:identifier="cogl_get_projection_matrix">
      <doc xml:whitespace="preserve">Stores the current projection matrix in @matrix.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">return location for the projection matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_rectangle_indices"
              c:identifier="cogl_get_rectangle_indices"
              introspectable="0">
      <return-value>
        <type name="Indices" c:type="CoglIndices*"/>
      </return-value>
      <parameters>
        <parameter name="n_rectangles" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_source"
              c:identifier="cogl_get_source"
              version="1.6"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns the current source material as previously set using
cogl_set_source().

&lt;note&gt;You should typically consider the returned material immutable
and not try to change any of its properties unless you own a
reference to that material. At times you may be able to get a
reference to an internally managed materials and the result of
modifying such materials is undefined.&lt;/note&gt;</doc>
      <return-value>
        <doc xml:whitespace="preserve">The current source material.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
    </function>
    <function name="get_static_identity_quaternion"
              c:identifier="cogl_get_static_identity_quaternion"
              version="2.0">
      <doc xml:whitespace="preserve">Returns a pointer to a singleton quaternion constant describing the
canonical identity [1 (0, 0, 0)] which represents no rotation.

If you multiply a quaternion with the identity quaternion you will
get back the same value as the original quaternion.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A pointer to an identity quaternion</doc>
        <type name="Quaternion" c:type="CoglQuaternion*"/>
      </return-value>
    </function>
    <function name="get_static_zero_quaternion"
              c:identifier="cogl_get_static_zero_quaternion"
              version="2.0">
      <doc xml:whitespace="preserve">rotation of 180 degrees around a degenerate axis:
[0 (0, 0, 0)]</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a pointer to a singleton quaternion constant describing a</doc>
        <type name="Quaternion" c:type="CoglQuaternion*"/>
      </return-value>
    </function>
    <function name="get_viewport" c:identifier="cogl_get_viewport">
      <doc xml:whitespace="preserve">Stores the current viewport in @v. @v[0] and @v[1] get the x and y
position of the viewport and @v[2] and @v[3] get the width and
height.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="v"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a 4 element array of #float&lt;!-- --&gt;s to receive the viewport dimensions.</doc>
          <array zero-terminated="0" c:type="float" fixed-size="4">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="glib_source_new"
              c:identifier="cogl_glib_source_new"
              version="1.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a #GSource which handles Cogl's internal system event
processing. This can be used as a convenience instead of
cogl_poll_get_info() and cogl_poll_dispatch() in applications that
are already using the GLib main loop. After this is called the
#GSource should be attached to the main loop using
g_source_attach().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GSource</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglContext</doc>
          <type c:type="CoglContext*"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:whitespace="preserve">The priority of the #GSource</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_get_type" c:identifier="cogl_handle_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="handle_ref" c:identifier="cogl_handle_ref">
      <doc xml:whitespace="preserve">Increases the reference count of @handle by 1</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handle, with its reference count increased</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref" c:identifier="cogl_handle_unref">
      <doc xml:whitespace="preserve">Drecreases the reference count of @handle by 1; if the reference
count reaches 0, the resources allocated by @handle will be freed</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="indices_get_type" c:identifier="cogl_indices_get_type">
      <return-value transfer-ownership="none">
        <type name="IndicesType" c:type="CoglIndicesType"/>
      </return-value>
      <parameters>
        <parameter name="indices" transfer-ownership="none">
          <type name="Indices" c:type="CoglIndices*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_attribute" c:identifier="cogl_is_attribute">
      <doc xml:whitespace="preserve">Gets whether the given object references a #CoglAttribute.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a #CoglAttribute,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_attribute_buffer"
              c:identifier="cogl_is_attribute_buffer"
              version="1.4">
      <doc xml:whitespace="preserve">Gets whether the given object references a #CoglAttributeBuffer.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a #CoglAttributeBuffer,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_bitmap" c:identifier="cogl_is_bitmap" version="1.0">
      <doc xml:whitespace="preserve">Checks whether @handle is a #CoglHandle for a bitmap

and %FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the passed handle represents a bitmap,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for a bitmap</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_buffer" c:identifier="cogl_is_buffer" version="1.2">
      <doc xml:whitespace="preserve">Checks whether @buffer is a buffer object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is a CoglBuffer, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_index_buffer"
              c:identifier="cogl_is_index_buffer"
              version="1.4">
      <doc xml:whitespace="preserve">Gets whether the given object references a #CoglIndexBuffer.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a #CoglIndexBuffer,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_material" c:identifier="cogl_is_material">
      <doc xml:whitespace="preserve">Gets whether the given handle references an existing material object.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a #CoglMaterial,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_offscreen" c:identifier="cogl_is_offscreen">
      <doc xml:whitespace="preserve">Determines whether the given #CoglHandle references an offscreen buffer
object.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references an offscreen buffer,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle for an offscreen buffer</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_path" c:identifier="cogl_is_path">
      <doc xml:whitespace="preserve">Gets whether the given handle references an existing path object.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a #CoglPath,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_pixel_buffer_EXP"
              c:identifier="cogl_is_pixel_buffer_EXP">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_primitive"
              c:identifier="cogl_is_primitive"
              version="1.6">
      <doc xml:whitespace="preserve">Gets whether the given object references a #CoglPrimitive.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a #CoglPrimitive,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_program" c:identifier="cogl_is_program">
      <doc xml:whitespace="preserve">Gets whether the given handle references an existing program object.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a program,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_shader" c:identifier="cogl_is_shader">
      <doc xml:whitespace="preserve">Gets whether the given handle references an existing shader object.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a shader,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_sub_texture_EXP" c:identifier="cogl_is_sub_texture_EXP">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture" c:identifier="cogl_is_texture">
      <doc xml:whitespace="preserve">Gets whether the given object references a texture object.

%FALSE otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle references a texture, and</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_2d_EXP" c:identifier="cogl_is_texture_2d_EXP">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_3d_EXP" c:identifier="cogl_is_texture_3d_EXP">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_rectangle_EXP"
              c:identifier="cogl_is_texture_rectangle_EXP">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_vertex_buffer"
              c:identifier="cogl_is_vertex_buffer"
              version="1.0">
      <doc xml:whitespace="preserve">Checks whether @handle is a Vertex Buffer Object

otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is a VBO, and %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for a vertex buffer object</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_vertex_buffer_indices"
              c:identifier="cogl_is_vertex_buffer_indices"
              version="1.4">
      <doc xml:whitespace="preserve">Checks whether @handle is a handle to the indices for a vertex
buffer object

otherwise</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is indices, and %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_layer_get_type"
              c:identifier="cogl_material_layer_get_type">
      <doc xml:whitespace="preserve">Retrieves the type of the layer

Currently there is only one type of layer defined:
%COGL_MATERIAL_LAYER_TYPE_TEXTURE, but considering we may add purely GLSL
based layers in the future, you should write code that checks the type
first.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the type of the layer</doc>
        <type name="MaterialLayerType" c:type="CoglMaterialLayerType"/>
      </return-value>
      <parameters>
        <parameter name="layer" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglMaterialLayer object</doc>
          <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_unref"
              c:identifier="cogl_material_unref"
              moved-to="Material.unref"
              version="1.0"
              deprecated="Use cogl_object_unref() instead"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Decrement the reference count for a #CoglMaterial.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglMaterial object.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_equal"
              c:identifier="cogl_matrix_equal"
              moved-to="Matrix.equal"
              version="1.4">
      <doc xml:whitespace="preserve">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:whitespace="preserve">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:whitespace="preserve">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_ref"
              c:identifier="cogl_object_ref"
              moved-to="Object.ref"
              introspectable="0">
      <doc xml:whitespace="preserve">Increases the reference count of @handle by 1</doc>
      <return-value>
        <doc xml:whitespace="preserve">the @object, with its reference count increased</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_unref"
              c:identifier="cogl_object_unref"
              moved-to="Object.unref"
              introspectable="0">
      <doc xml:whitespace="preserve">Drecreases the reference count of @object by 1; if the reference
count reaches 0, the resources allocated by @object will be freed</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="offscreen_new_to_texture"
              c:identifier="cogl_offscreen_new_to_texture">
      <doc xml:whitespace="preserve">This creates an offscreen buffer object using the given @texture as the
primary color buffer. It doesn't just initialize the contents of the
offscreen buffer with the @texture; they are tightly bound so that
drawing to the offscreen buffer effectivly updates the contents of the
given texture. You don't need to destroy the offscreen buffer before
you can use the @texture again.

Note: This does not work with sliced Cogl textures.

buffer or %COGL_INVALID_HANDLE if it wasn't possible to create the
buffer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a #CoglHandle for the new offscreen</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglTexture pointer</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
      </parameters>
    </function>
    <function name="offscreen_ref"
              c:identifier="cogl_offscreen_ref"
              deprecated="cogl_handle_ref() should be used in new code."
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Increments the reference count on the offscreen buffer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">For convenience it returns the given CoglHandle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle for an offscreen buffer</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="offscreen_unref"
              c:identifier="cogl_offscreen_unref"
              deprecated="cogl_handle_unref() should be used in new code."
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Decreases the reference count for the offscreen buffer and frees it when
the count reaches 0.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle for an offscreen buffer</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="onscreen_clutter_backend_set_size_CLUTTER"
              c:identifier="cogl_onscreen_clutter_backend_set_size_CLUTTER"
              moved-to="Onscreen.clutter_backend_set_size_CLUTTER">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="ortho" c:identifier="cogl_ortho" version="1.0">
      <doc xml:whitespace="preserve">Replaces the current projection matrix with an orthographic projection
matrix. See &lt;xref linkend="cogl-ortho-matrix"/&gt; to see how the matrix is
calculated.

&lt;figure id="cogl-ortho-matrix"&gt;
&lt;title&gt;&lt;/title&gt;
&lt;graphic fileref="cogl_ortho.png" format="PNG"/&gt;
&lt;/figure&gt;

&lt;note&gt;This function copies the arguments from OpenGL's glOrtho() even
though they are unnecessarily confusing due to the z near and z far
arguments actually being a "distance" from the origin, where
negative values are behind the viewer, instead of coordinates for
the z clipping planes which would have been consistent with the
left, right bottom and top arguments.&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:whitespace="preserve">The coordinate for the left clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:whitespace="preserve">The coordinate for the right clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:whitespace="preserve">The coordinate for the bottom clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:whitespace="preserve">The coordinate for the top clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="near" transfer-ownership="none">
          <doc xml:whitespace="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping plane (negative if the plane is behind the viewer)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="far" transfer-ownership="none">
          <doc xml:whitespace="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; for the far clipping plane (negative if the plane is behind the viewer)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_arc" c:identifier="cogl_path_arc" moved-to="Path.arc">
      <doc xml:whitespace="preserve">Adds an elliptical arc segment to the current path. A straight line
segment will link the current pen location with the first vertex
of the arc. If you perform a move_to to the arcs start just before
drawing it you create a free standing arc.

The angles are measured in degrees where 0° is in the direction of
the positive X axis and 90° is in the direction of the positive Y
axis. The angle of the arc begins at @angle_1 and heads towards
@angle_2 (so if @angle_2 is less than @angle_1 it will decrease,
otherwise it will increase).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="center_x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the elliptical arc center</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="center_y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the elliptical arc center</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="radius_x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X radius of the elliptical arc</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="radius_y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y radius of the elliptical arc</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="angle_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">Angle in degrees at which the arc begin</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="angle_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Angle in degrees at which the arc ends</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_close"
              c:identifier="cogl_path_close"
              moved-to="Path.close">
      <doc xml:whitespace="preserve">Closes the path being constructed by adding a straight line segment
to it that ends at the first vertex of the path.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_curve_to"
              c:identifier="cogl_path_curve_to"
              moved-to="Path.curve_to">
      <doc xml:whitespace="preserve">Adds a cubic bezier curve segment to the current path with the given
second, third and fourth control points and using current pen location
as the first control point.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the second bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the second bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the third bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the third bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_3" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the fourth bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_3" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the fourth bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_ellipse"
              c:identifier="cogl_path_ellipse"
              moved-to="Path.ellipse">
      <doc xml:whitespace="preserve">Constructs an ellipse shape. If there is an existing path this will
start a new disjoint sub-path.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="center_x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the ellipse center</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="center_y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the ellipse center</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="radius_x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X radius of the ellipse</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="radius_y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y radius of the ellipse</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_fill"
              c:identifier="cogl_path_fill"
              moved-to="Path.fill">
      <doc xml:whitespace="preserve">Fills the interior of the constructed shape using the current
drawing color. The current path is then cleared. To use the path
again, call cogl_path_fill_preserve() instead.

The interior of the shape is determined using the fill rule of the
path. See %CoglPathFillRule for details.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_fill_preserve"
              c:identifier="cogl_path_fill_preserve"
              moved-to="Path.fill_preserve"
              version="1.0">
      <doc xml:whitespace="preserve">Fills the interior of the constructed shape using the current
drawing color and preserves the path to be used again. See
cogl_path_fill() for a description what is considered the interior
of the shape.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_get_fill_rule"
              c:identifier="cogl_path_get_fill_rule"
              moved-to="Path.get_fill_rule"
              version="1.4">
      <doc xml:whitespace="preserve">Retrieves the fill rule set using cogl_path_set_fill_rule().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the fill rule that is used for the current path.</doc>
        <type name="PathFillRule" c:type="CoglPathFillRule"/>
      </return-value>
    </function>
    <function name="path_line"
              c:identifier="cogl_path_line"
              moved-to="Path.line">
      <doc xml:whitespace="preserve">Constructs a straight line shape starting and ending at the given
coordinates. If there is an existing path this will start a new
disjoint sub-path.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the start line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the start line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the end line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the end line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_line_to"
              c:identifier="cogl_path_line_to"
              moved-to="Path.line_to">
      <doc xml:whitespace="preserve">Adds a straight line segment to the current path that ends at the
given coordinates.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the end line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the end line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_move_to"
              c:identifier="cogl_path_move_to"
              moved-to="Path.move_to">
      <doc xml:whitespace="preserve">Moves the pen to the given location. If there is an existing path
this will start a new disjoint subpath.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the pen location to move to.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the pen location to move to.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_new"
              c:identifier="cogl_path_new"
              moved-to="Path.new"
              version="1.0">
      <doc xml:whitespace="preserve">Clears the current path and starts a new one. Creating a new path
also resets the fill rule to the default which is
%COGL_PATH_FILL_RULE_EVEN_ODD.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_polygon"
              c:identifier="cogl_path_polygon"
              moved-to="Path.polygon">
      <doc xml:whitespace="preserve">Constructs a polygonal shape of the given number of vertices. If
there is an existing path this will start a new disjoint sub-path.

The coords array must contain 2 * num_points values. The first value
represents the X coordinate of the first vertex, the second value
represents the Y coordinate of the first vertex, continuing in the same
fashion for the rest of the vertices.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="coords" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the first element of an array of fixed-point values that specify the vertex coordinates.</doc>
          <array zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="num_points" transfer-ownership="none">
          <doc xml:whitespace="preserve">The total number of vertices.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_polyline"
              c:identifier="cogl_path_polyline"
              moved-to="Path.polyline">
      <doc xml:whitespace="preserve">Constructs a series of straight line segments, starting from the
first given vertex coordinate. If there is an existing path this
will start a new disjoint sub-path. Each subsequent segment starts
where the previous one ended and ends at the next given vertex
coordinate.

The coords array must contain 2 * num_points values. The first value
represents the X coordinate of the first vertex, the second value
represents the Y coordinate of the first vertex, continuing in the same
fashion for the rest of the vertices. (num_points - 1) segments will
be constructed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="coords" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the first element of an array of fixed-point values that specify the vertex coordinates.</doc>
          <array zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="num_points" transfer-ownership="none">
          <doc xml:whitespace="preserve">The total number of vertices.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rectangle"
              c:identifier="cogl_path_rectangle"
              moved-to="Path.rectangle">
      <doc xml:whitespace="preserve">Constructs a rectangular shape at the given coordinates. If there
is an existing path this will start a new disjoint sub-path.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the top-left corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the top-left corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the bottom-right corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the bottom-right corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rel_curve_to"
              c:identifier="cogl_path_rel_curve_to"
              moved-to="Path.rel_curve_to">
      <doc xml:whitespace="preserve">Adds a cubic bezier curve segment to the current path with the given
second, third and fourth control points and using current pen location
as the first control point. The given coordinates are relative to the
current pen location.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the second bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the second bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the third bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the third bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_3" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the fourth bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_3" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the fourth bezier control point</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rel_line_to"
              c:identifier="cogl_path_rel_line_to"
              moved-to="Path.rel_line_to">
      <doc xml:whitespace="preserve">Adds a straight line segment to the current path that ends at the
given coordinates relative to the current pen location.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X offset from the current pen location of the end line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y offset from the current pen location of the end line vertex</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_rel_move_to"
              c:identifier="cogl_path_rel_move_to"
              moved-to="Path.rel_move_to">
      <doc xml:whitespace="preserve">Moves the pen to the given offset relative to the current pen
location. If there is an existing path this will start a new
disjoint subpath.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X offset from the current pen location to move the pen to.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y offset from the current pen location to move the pen to.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_round_rectangle"
              c:identifier="cogl_path_round_rectangle"
              moved-to="Path.round_rectangle">
      <doc xml:whitespace="preserve">Constructs a rectangular shape with rounded corners. If there is an
existing path this will start a new disjoint sub-path.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the top-left corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the top-left corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the bottom-right corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the bottom-right corner.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <doc xml:whitespace="preserve">Radius of the corner arcs.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="arc_step" transfer-ownership="none">
          <doc xml:whitespace="preserve">Angle increment resolution for subdivision of the corner arcs.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_set_fill_rule"
              c:identifier="cogl_path_set_fill_rule"
              moved-to="Path.set_fill_rule"
              version="1.4">
      <doc xml:whitespace="preserve">Sets the fill rule of the current path to @fill_rule. This will
affect how the path is filled when cogl_path_fill() is later
called. Note that the fill rule state is attached to the path so
calling cogl_get_path() will preserve the fill rule and calling
cogl_path_new() will reset the fill rule back to the default.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fill_rule" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new fill rule.</doc>
          <type name="PathFillRule" c:type="CoglPathFillRule"/>
        </parameter>
      </parameters>
    </function>
    <function name="path_stroke"
              c:identifier="cogl_path_stroke"
              moved-to="Path.stroke">
      <doc xml:whitespace="preserve">Strokes the constructed shape using the current drawing color and a
width of 1 pixel (regardless of the current transformation
matrix). To current path is then cleared. To use the path again,
call cogl_path_stroke_preserve() instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="path_stroke_preserve"
              c:identifier="cogl_path_stroke_preserve"
              moved-to="Path.stroke_preserve"
              version="1.0">
      <doc xml:whitespace="preserve">Strokes the constructed shape using the current drawing color and
preserves the path to be used again.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="perspective" c:identifier="cogl_perspective">
      <doc xml:whitespace="preserve">Replaces the current projection matrix with a perspective matrix
based on the provided values.

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fovy" transfer-ownership="none">
          <doc xml:whitespace="preserve">Vertical field of view angle in degrees.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="aspect" transfer-ownership="none">
          <doc xml:whitespace="preserve">The (width over height) aspect ratio for display</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:whitespace="preserve">The distance to the near clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:whitespace="preserve">The distance to the far clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_dispatch"
              c:identifier="cogl_poll_dispatch"
              version="1.10"
              introspectable="0">
      <doc xml:whitespace="preserve">This should be called whenever an application is woken up from
going idle in its main loop. The @poll_fds array should contain a
list of file descriptors matched with the events that occurred in
revents. The events field is ignored. It is safe to pass in extra
file descriptors that Cogl didn't request from
cogl_context_begin_idle() or a shorter array missing some file
descriptors that Cogl requested.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglContext</doc>
          <type c:type="CoglContext*"/>
        </parameter>
        <parameter name="poll_fds" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #CoglPollFD&lt;!-- --&gt;s describing the events that have occurred since the application went idle.</doc>
          <type name="PollFD" c:type="CoglPollFD*"/>
        </parameter>
        <parameter name="n_poll_fds" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length of the @poll_fds array.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_get_info"
              c:identifier="cogl_poll_get_info"
              version="1.10"
              introspectable="0">
      <doc xml:whitespace="preserve">This should be called whenever an application is about to go idle
so that Cogl has a chance to describe what state it needs to be
woken up on. The assumption is that the application is using a main
loop with something like the poll function call on Unix or the GLib
main loop.

After the function is called *@poll_fds will contain a pointer to
an array of #CoglPollFD structs describing the file descriptors
that Cogl expects. The fd and events members will be updated
accordingly. After the application has completed its idle it is
expected to either update the revents members directly in this
array or to create a copy of the array and update them
there. Either way it should pass a pointer to either array back to
Cogl when calling cogl_poll_dispatch().

When using the %COGL_WINSYS_ID_WGL winsys (where file descriptors
don't make any sense) or %COGL_WINSYS_ID_SDL (where the event
handling functions of SDL don't allow blocking on a file
descriptor) *n_poll_fds is guaranteed to be zero.

@timeout will contain a maximum amount of time to wait in
microseconds before the application should wake up or -1 if the
application should wait indefinitely. This can also be 0 zero if
Cogl needs to be woken up immediately.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglContext</doc>
          <type c:type="CoglContext*"/>
        </parameter>
        <parameter name="poll_fds" transfer-ownership="none">
          <doc xml:whitespace="preserve">A return location for a pointer to an array of #CoglPollFD&lt;!-- --&gt;s</doc>
          <type name="PollFD" c:type="CoglPollFD**"/>
        </parameter>
        <parameter name="n_poll_fds" transfer-ownership="none">
          <doc xml:whitespace="preserve">A return location for the number of entries in *@poll_fds</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="timeout" transfer-ownership="none">
          <doc xml:whitespace="preserve">A return location for the maximum length of time to wait in microseconds, or -1 to wait indefinitely.</doc>
          <type name="gint64" c:type="gint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="polygon" c:identifier="cogl_polygon" version="1.0">
      <doc xml:whitespace="preserve">Draws a convex polygon using the current source material to fill / texture
with according to the texture coordinates passed.

If @use_color is %TRUE then the color will be changed for each vertex using
the value specified in the color member of #CoglTextureVertex. This can be
used for example to make the texture fade out by setting the alpha value of
the color.

All of the texture coordinates must be in the range [0,1] and repeating the
texture is not supported.

Because of the way this function is implemented it will currently
only work if either the texture is not sliced or the backend is not
OpenGL ES and the minifying and magnifying functions are both set
to COGL_MATERIAL_FILTER_NEAREST.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vertices" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #CoglTextureVertex structs</doc>
          <type name="TextureVertex" c:type="CoglTextureVertex*"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length of the vertices array</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="use_color" transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the color member of #CoglTextureVertex should be used</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="pop_draw_buffer"
              c:identifier="cogl_pop_draw_buffer"
              deprecated="The draw buffer API was replaced with a framebuffer API"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Restore cogl_set_draw_buffer() state.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_framebuffer"
              c:identifier="cogl_pop_framebuffer"
              version="1.2">
      <doc xml:whitespace="preserve">Restores the framebuffer that was previously at the top of the stack.
All subsequent drawing will be redirected to this framebuffer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_matrix" c:identifier="cogl_pop_matrix">
      <doc xml:whitespace="preserve">Restores the current model-view matrix from the matrix stack.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_source" c:identifier="cogl_pop_source" version="1.6">
      <doc xml:whitespace="preserve">Removes the material at the top of the source stack. The material
at the top of this stack defines the GPU state used to process
later primitives as defined by cogl_set_source().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="program_attach_shader"
              c:identifier="cogl_program_attach_shader">
      <doc xml:whitespace="preserve">Attaches a shader to a program object. A program can have multiple
vertex or fragment shaders but only one of them may provide a
main() function. It is allowed to use a program with only a vertex
shader or only a fragment shader.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for a shdaer program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="shader_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for a vertex of fragment shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_get_uniform_location"
              c:identifier="cogl_program_get_uniform_location">
      <doc xml:whitespace="preserve">Retrieve the location (offset) of a uniform variable in a shader program,
a uniform is a variable that is constant for all vertices/fragments for a
shader object and is possible to modify as an external parameter.

This uniform can be set using cogl_program_uniform_1f() when the
program is in use.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the offset of a uniform in a specified program.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of a uniform.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_link" c:identifier="cogl_program_link">
      <doc xml:whitespace="preserve">Links a program making it ready for use. Note that calling this
function is optional. If it is not called the program will
automatically be linked the first time it is used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_ref"
              c:identifier="cogl_program_ref"
              introspectable="0"
              deprecated="Please use cogl_handle_ref() instead."
              deprecated-version="1.0">
      <doc xml:whitespace="preserve">Add an extra reference to a program.</doc>
      <return-value>
        <doc xml:whitespace="preserve">@handle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle to a program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1f"
              c:identifier="cogl_program_set_uniform_1f"
              version="1.4">
      <doc xml:whitespace="preserve">Changes the value of a floating point uniform for the given linked
@program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform location retrieved from cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1i"
              c:identifier="cogl_program_set_uniform_1i"
              version="1.4">
      <doc xml:whitespace="preserve">Changes the value of an integer uniform for the given linked
@program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform location retrieved from cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_float"
              c:identifier="cogl_program_set_uniform_float"
              version="1.4">
      <doc xml:whitespace="preserve">Changes the value of a float vector uniform, or uniform array for
the given linked @program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform location retrieved from cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of components for the uniform. For example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">For uniform arrays this is the array length otherwise just pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_int"
              c:identifier="cogl_program_set_uniform_int"
              version="1.4">
      <doc xml:whitespace="preserve">Changes the value of a int vector uniform, or uniform array for
the given linked @program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform location retrieved from cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of components for the uniform. For example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">For uniform arrays this is the array length otherwise just pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_matrix"
              c:identifier="cogl_program_set_uniform_matrix"
              version="1.4">
      <doc xml:whitespace="preserve">Changes the value of a matrix uniform, or uniform array in the
given linked @program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform location retrieved from cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dimensions" transfer-ownership="none">
          <doc xml:whitespace="preserve">The dimensions of the matrix. So for for example pass 2 for a 2x2 matrix or 3 for 3x3.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">For uniform arrays this is the array length otherwise just pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to transpose the matrix when setting the uniform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <array length="3" zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1f"
              c:identifier="cogl_program_uniform_1f"
              deprecated="Use cogl_program_set_uniform_1f() instead."
              deprecated-version="1.4">
      <doc xml:whitespace="preserve">Changes the value of a floating point uniform in the currently
used (see cogl_program_use()) shader program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1i"
              c:identifier="cogl_program_uniform_1i"
              deprecated="Use cogl_program_set_uniform_1i() instead."
              deprecated-version="1.4">
      <doc xml:whitespace="preserve">Changes the value of an integer uniform in the currently
used (see cogl_program_use()) shader program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_float"
              c:identifier="cogl_program_uniform_float"
              deprecated="Use cogl_program_set_uniform_float() instead."
              deprecated-version="1.4">
      <doc xml:whitespace="preserve">Changes the value of a float vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of float vector.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_int"
              c:identifier="cogl_program_uniform_int">
      <doc xml:whitespace="preserve">Changes the value of a int vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of int vector.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_matrix"
              c:identifier="cogl_program_uniform_matrix">
      <doc xml:whitespace="preserve">Changes the value of a matrix uniform, or uniform array in the
currently used (see cogl_program_use()) shader program. The @size
parameter is used to determine the square size of the matrix.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:whitespace="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of matrix.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to transpose the matrix when setting the uniform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_unref"
              c:identifier="cogl_program_unref"
              deprecated="Please use cogl_handle_unref() instead."
              deprecated-version="1.0">
      <doc xml:whitespace="preserve">Removes a reference to a program. If it was the last reference the
program object will be destroyed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle to a program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_use" c:identifier="cogl_program_use">
      <doc xml:whitespace="preserve">Activate a specific shader program replacing that part of the GL
rendering pipeline, if passed in %COGL_INVALID_HANDLE the default
behavior of GL is reinstated.

This function affects the global state of the current Cogl
context. It is much more efficient to attach the shader to a
specific material used for rendering instead by calling
cogl_material_set_user_program().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglHandle for a shader program or %COGL_INVALID_HANDLE.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_draw_buffer"
              c:identifier="cogl_push_draw_buffer"
              deprecated="The draw buffer API was replaced with a framebuffer API"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Save cogl_set_draw_buffer() state.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="push_framebuffer"
              c:identifier="cogl_push_framebuffer"
              version="1.2">
      <doc xml:whitespace="preserve">Redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
or in the future it may be an onscreen framebuffer too.

You should understand that a framebuffer owns the following state:
&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;simpara&gt;The projection matrix&lt;/simpara&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;simpara&gt;The modelview matrix stack&lt;/simpara&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;simpara&gt;The viewport&lt;/simpara&gt;&lt;/listitem&gt;
&lt;listitem&gt;&lt;simpara&gt;The clip stack&lt;/simpara&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
So these items will automatically be saved and restored when you
push and pop between different framebuffers.

Also remember a newly allocated framebuffer will have an identity matrix for
the projection and modelview matrices which gives you a coordinate space
like OpenGL with (-1, -1) corresponding to the top left of the viewport,
(1, 1) corresponding to the bottom right and +z coming out towards the
viewer.

If you want to set up a coordinate space like Clutter does with (0, 0)
corresponding to the top left and (framebuffer_width, framebuffer_height)
corresponding to the bottom right you can do so like this:

|[
static void
setup_viewport (unsigned int width,
unsigned int height,
float fovy,
float aspect,
float z_near,
float z_far)
{
float z_camera;
CoglMatrix projection_matrix;
CoglMatrix mv_matrix;

cogl_set_viewport (0, 0, width, height);
cogl_perspective (fovy, aspect, z_near, z_far);

cogl_get_projection_matrix (&amp;amp;projection_matrix);
z_camera = 0.5 * projection_matrix.xx;

cogl_matrix_init_identity (&amp;amp;mv_matrix);
cogl_matrix_translate (&amp;amp;mv_matrix, -0.5f, -0.5f, -z_camera);
cogl_matrix_scale (&amp;amp;mv_matrix, 1.0f / width, -1.0f / height, 1.0f / width);
cogl_matrix_translate (&amp;amp;mv_matrix, 0.0f, -1.0 * height, 0.0f);
cogl_set_modelview_matrix (&amp;amp;mv_matrix);
}

static void
my_init_framebuffer (ClutterStage *stage,
CoglFramebuffer *framebuffer,
unsigned int framebuffer_width,
unsigned int framebuffer_height)
{
ClutterPerspective perspective;

clutter_stage_get_perspective (stage, &amp;perspective);

cogl_push_framebuffer (framebuffer);
setup_viewport (framebuffer_width,
framebuffer_height,
perspective.fovy,
perspective.aspect,
perspective.z_near,
perspective.z_far);
}
]|

The previous framebuffer can be restored by calling cogl_pop_framebuffer()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglFramebuffer object, either onscreen or offscreen.</doc>
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_matrix" c:identifier="cogl_push_matrix">
      <doc xml:whitespace="preserve">Stores the current model-view matrix on the matrix stack. The matrix
can later be restored with cogl_pop_matrix().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="push_source" c:identifier="cogl_push_source" version="1.6">
      <doc xml:whitespace="preserve">Pushes the given @material to the top of the source stack. The
material at the top of this stack defines the GPU state used to
process later primitives as defined by cogl_set_source().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglMaterial</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="quaternion_equal"
              c:identifier="cogl_quaternion_equal"
              moved-to="Quaternion.equal"
              version="2.0">
      <doc xml:whitespace="preserve">Compares that all the components of quaternions @a and @b are
equal.

An epsilon value is not used to compare the float components, but
the == operator is at least used so that 0 and -0 are considered
equal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the quaternions are equal else %FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglQuaternion</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglQuaternion</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="read_pixels" c:identifier="cogl_read_pixels">
      <doc xml:whitespace="preserve">This reads a rectangle of pixels from the current framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and the data is returned with a rowstride of (width * 4).

Currently Cogl assumes that the framebuffer is in a premultiplied
format so if @format is non-premultiplied it will convert it. To
read the pixel values without any conversion you should either
specify a format that doesn't use an alpha channel or use one of
the formats ending in PRE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">The window x position to start reading from</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">The window y position to start reading from</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">The width of the rectangle you want to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">The height of the rectangle you want to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:whitespace="preserve">Identifies which auxillary buffer you want to read (only COGL_READ_PIXELS_COLOR_BUFFER supported currently)</doc>
          <type name="ReadPixelsFlags" c:type="CoglReadPixelsFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">The pixel format you want the result in (only COGL_PIXEL_FORMAT_RGBA_8888 supported currently)</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="pixels" transfer-ownership="none">
          <doc xml:whitespace="preserve">The location to write the pixel data.</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle" c:identifier="cogl_rectangle">
      <doc xml:whitespace="preserve">Fills a rectangle at the given coordinates with the current source material</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the top-left corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the top-left corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">X coordinate of the bottom-right corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y coordinate of the bottom-right corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_multitexture_coords"
              c:identifier="cogl_rectangle_with_multitexture_coords"
              version="1.0">
      <doc xml:whitespace="preserve">This function draws a rectangle using the current source material to
texture or fill with. As a material may contain multiple texture layers
this interface lets you supply texture coordinates for each layer of the
material.

The first pair of coordinates are for the first layer (with the smallest
layer index) and if you supply less texture coordinates than there are
layers in the current source material then default texture coordinates
(0.0, 0.0, 1.0, 1.0) are generated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:whitespace="preserve">x coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:whitespace="preserve">y coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:whitespace="preserve">x coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:whitespace="preserve">y coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tex_coords" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array containing groups of 4 float values: [tx1, ty1, tx2, ty2] that are interpreted as two texture coordinates; one for the upper left texel, and one for the lower right texel. Each value should be between 0.0 and 1.0, where the coordinate (0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the bottom right.</doc>
          <array zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="tex_coords_len" transfer-ownership="none">
          <doc xml:whitespace="preserve">The length of the tex_coords array. (e.g. for one layer and one group of texture coordinates, this would be 4)</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_texture_coords"
              c:identifier="cogl_rectangle_with_texture_coords"
              version="1.0">
      <doc xml:whitespace="preserve">Draw a rectangle using the current material and supply texture coordinates
to be used for the first texture layer of the material. To draw the entire
texture pass in @tx1=0.0 @ty1=0.0 @tx2=1.0 @ty2=1.0.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:whitespace="preserve">x coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:whitespace="preserve">y coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:whitespace="preserve">x coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:whitespace="preserve">y coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tx1" transfer-ownership="none">
          <doc xml:whitespace="preserve">x part of texture coordinate to use for upper left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty1" transfer-ownership="none">
          <doc xml:whitespace="preserve">y part of texture coordinate to use for upper left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tx2" transfer-ownership="none">
          <doc xml:whitespace="preserve">x part of texture coordinate to use for lower right pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty2" transfer-ownership="none">
          <doc xml:whitespace="preserve">y part of texture coordinate to use for left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles" c:identifier="cogl_rectangles" version="1.0">
      <doc xml:whitespace="preserve">Draws a series of rectangles in the same way that
cogl_rectangle() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle() separately for each rectangle.

@verts should point to an array of #float&lt;!-- --&gt;s with
@n_rects * 4 elements. Each group of 4 values corresponds to the
parameters x1, y1, x2, and y2, and have the same
meaning as in cogl_rectangle().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of vertices</doc>
          <array zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of rectangles to draw</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles_with_texture_coords"
              c:identifier="cogl_rectangles_with_texture_coords"
              version="0.8.6">
      <doc xml:whitespace="preserve">Draws a series of rectangles in the same way that
cogl_rectangle_with_texture_coords() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle_with_texture_coords() separately for each rectangle.

@verts should point to an array of #float&lt;!-- --&gt;s with
@n_rects * 8 elements. Each group of 8 values corresponds to the
parameters x1, y1, x2, y2, tx1, ty1, tx2 and ty2 and have the same
meaning as in cogl_rectangle_with_texture_coords().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of vertices</doc>
          <array zero-terminated="0" c:type="float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of rectangles to draw</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rotate" c:identifier="cogl_rotate">
      <doc xml:whitespace="preserve">Multiplies the current model-view matrix by one that rotates the
model around the vertex specified by @x, @y and @z. The rotation
follows the right-hand thumb rule so for example rotating by 10
degrees about the vertex (0, 0, 1) causes a small counter-clockwise
rotation.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:whitespace="preserve">Angle in degrees to rotate.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:whitespace="preserve">Z-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="scale" c:identifier="cogl_scale">
      <doc xml:whitespace="preserve">Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">Amount to scale along the x-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Amount to scale along the y-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:whitespace="preserve">Amount to scale along the z-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_backface_culling_enabled"
              c:identifier="cogl_set_backface_culling_enabled">
      <doc xml:whitespace="preserve">Sets whether textures positioned so that their backface is showing
should be hidden. This can be used to efficiently draw two-sided
textures or fully closed cubes without enabling depth testing. This
only affects calls to the cogl_rectangle* family of functions and
cogl_vertex_buffer_draw*. Backface culling is disabled by default.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to enable backface culling or %FALSE to disable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_depth_test_enabled"
              c:identifier="cogl_set_depth_test_enabled"
              deprecated="Use cogl_material_set_depth_test_enabled()"
              deprecated-version="1.4">
      <doc xml:whitespace="preserve">Sets whether depth testing is enabled. If it is disabled then the
order that actors are layered on the screen depends solely on the
order specified using clutter_actor_raise() and
clutter_actor_lower(), otherwise it will also take into account the
actor's depth. Depth testing is disabled by default.

instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE to enable depth testing or %FALSE to disable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_draw_buffer"
              c:identifier="cogl_set_draw_buffer"
              deprecated="The target argument was redundant since we could look at"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Redirects all subsequent drawing to the specified framebuffer. This
can either be an offscreen buffer created with
cogl_offscreen_new_to_texture () or you can revert to your original
on screen window buffer.

the type of CoglHandle given instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglBufferTarget that specifies what kind of framebuffer you are setting as the render target.</doc>
          <type name="BufferTarget" c:type="CoglBufferTarget"/>
        </parameter>
        <parameter name="offscreen" transfer-ownership="none">
          <doc xml:whitespace="preserve">If you are setting a framebuffer of type COGL_OFFSCREEN_BUFFER then this is a CoglHandle for the offscreen buffer.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_fog" c:identifier="cogl_set_fog">
      <doc xml:whitespace="preserve">Enables fogging. Fogging causes vertices that are further away from the eye
to be rendered with a different color. The color is determined according to
the chosen fog mode; at it's simplest the color is linearly interpolated so
that vertices at @z_near are drawn fully with their original color and
vertices at @z_far are drawn fully with @fog_color. Fogging will remain
enabled until you call cogl_disable_fog().

&lt;note&gt;The fogging functions only work correctly when primitives use
unmultiplied alpha colors. By default Cogl will premultiply textures
and cogl_set_source_color() will premultiply colors, so unless you
explicitly load your textures requesting an unmultiplied internal format
and use cogl_material_set_color() you can only use fogging with fully
opaque primitives. This might improve in the future when we can depend
on fragment shaders.&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fog_color" transfer-ownership="none">
          <doc xml:whitespace="preserve">The color of the fog</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglFogMode that determines the equation used to calculate the fogging blend factor.</doc>
          <type name="FogMode" c:type="CoglFogMode"/>
        </parameter>
        <parameter name="density" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used by %COGL_FOG_MODE_EXPONENTIAL and by %COGL_FOG_MODE_EXPONENTIAL_SQUARED equations.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:whitespace="preserve">Position along Z axis where no fogging should be applied</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:whitespace="preserve">Position along Z axis where full fogging should be applied</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_framebuffer"
              c:identifier="cogl_set_framebuffer"
              version="1.2">
      <doc xml:whitespace="preserve">This redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
or in the future it may be an onscreen framebuffers too.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglFramebuffer object, either onscreen or offscreen.</doc>
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_modelview_matrix"
              c:identifier="cogl_set_modelview_matrix">
      <doc xml:whitespace="preserve">Loads @matrix as the new model-view matrix.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new model-view matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_path"
              c:identifier="cogl_set_path"
              version="1.4"
              introspectable="0">
      <doc xml:whitespace="preserve">Replaces the current path with @path. A reference is taken on the
object so if you no longer need the path you should unref with
cogl_object_unref().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglPath object</doc>
          <type name="Path" c:type="CoglPath*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_projection_matrix"
              c:identifier="cogl_set_projection_matrix">
      <doc xml:whitespace="preserve">Loads matrix as the new projection matrix.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:whitespace="preserve">the new projection matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source" c:identifier="cogl_set_source" version="1.0">
      <doc xml:whitespace="preserve">This function changes the material at the top of the source stack.
The material at the top of this stack defines the GPU state used to
process subsequent primitives, such as rectangles drawn with
cogl_rectangle() or vertices drawn using cogl_vertex_buffer_draw().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglMaterial</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color"
              c:identifier="cogl_set_source_color"
              version="1.0">
      <doc xml:whitespace="preserve">This is a convenience function for creating a solid fill source material
from the given color. This color will be used for any subsequent drawing
operation.

The color will be premultiplied by Cogl, so the color should be
non-premultiplied. For example: use (1.0, 0.0, 0.0, 0.5) for
semi-transparent red.

See also cogl_set_source_color4ub() and cogl_set_source_color4f()
if you already have the color components.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglColor</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4f"
              c:identifier="cogl_set_source_color4f"
              version="1.0">
      <doc xml:whitespace="preserve">This is a convenience function for creating a solid fill source material
from the given color using normalized values for each component. This color
will be used for any subsequent drawing operation.

The value for each component is a fixed point number in the range
between 0 and %1.0. If the values passed in are outside that
range, they will be clamped.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the red channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the green channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the blue channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the alpha channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4ub"
              c:identifier="cogl_set_source_color4ub"
              version="1.0">
      <doc xml:whitespace="preserve">This is a convenience function for creating a solid fill source material
from the given color using unsigned bytes for each component. This
color will be used for any subsequent drawing operation.

The value for each component is an unsigned byte in the range
between 0 and 255.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the red channel, between 0 and 255</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the green channel, between 0 and 255</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the blue channel, between 0 and 255</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:whitespace="preserve">value of the alpha channel, between 0 and 255</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_texture"
              c:identifier="cogl_set_source_texture"
              version="1.0">
      <doc xml:whitespace="preserve">This is a convenience function for creating a material with the first
layer set to @texture and setting that material as the source with
cogl_set_source.

Note: There is no interaction between calls to cogl_set_source_color
and cogl_set_source_texture. If you need to blend a texture with a color then
you can create a simple material like this:
&lt;programlisting&gt;
material = cogl_material_new ();
cogl_material_set_color4ub (material, 0xff, 0x00, 0x00, 0x80);
cogl_material_set_layer (material, 0, tex_handle);
cogl_set_source (material);
&lt;/programlisting&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #CoglTexture you want as your source</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_viewport"
              c:identifier="cogl_set_viewport"
              version="1.2">
      <doc xml:whitespace="preserve">Replaces the current viewport with the given values.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">X offset of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Y offset of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">Width of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">Height of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_compile" c:identifier="cogl_shader_compile">
      <doc xml:whitespace="preserve">Compiles the shader, no return value, but the shader is now ready
for linking into a program. Note that calling this function is
optional. If it is not called then the shader will be automatically
compiled when it is linked.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_info_log"
              c:identifier="cogl_shader_get_info_log">
      <doc xml:whitespace="preserve">Retrieves the information log for a coglobject, can be used in conjunction
with cogl_shader_get_parameteriv() to retrieve the compiler warnings/error
messages that caused a shader to not compile correctly, mainly useful for
debugging purposes.

g_free() to free it</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated string containing the info log. Use</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_type" c:identifier="cogl_shader_get_type">
      <doc xml:whitespace="preserve">Retrieves the type of a shader #CoglHandle

or %COGL_SHADER_TYPE_FRAGMENT if the shader is a frament processor</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%COGL_SHADER_TYPE_VERTEX if the shader is a vertex processor</doc>
        <type name="ShaderType" c:type="CoglShaderType"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_is_compiled" c:identifier="cogl_shader_is_compiled">
      <doc xml:whitespace="preserve">Retrieves whether a shader #CoglHandle has been compiled</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the shader object has sucessfully be compiled</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_ref"
              c:identifier="cogl_shader_ref"
              introspectable="0"
              deprecated="Please use cogl_handle_ref() instead."
              deprecated-version="1.0">
      <doc xml:whitespace="preserve">Add an extra reference to a shader.</doc>
      <return-value>
        <doc xml:whitespace="preserve">@handle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle to a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_source" c:identifier="cogl_shader_source">
      <doc xml:whitespace="preserve">Replaces the current source associated with a shader with a new
one.

Please see &lt;link
linkend="cogl-Shaders-and-Programmable-Pipeline.description"&gt;above&lt;/link&gt;
for a description of the recommended format for the shader code.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="shader" transfer-ownership="none">
          <doc xml:whitespace="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:whitespace="preserve">Shader source.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_unref"
              c:identifier="cogl_shader_unref"
              deprecated="Please use cogl_handle_unref() instead."
              deprecated-version="1.0">
      <doc xml:whitespace="preserve">Removes a reference to a shader. If it was the last reference the
shader object will be destroyed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglHandle to a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="sqrti" c:identifier="cogl_sqrti" version="1.0">
      <doc xml:whitespace="preserve">Very fast fixed point implementation of square root for integers.

This function is at least 6x faster than clib sqrt() on x86, and (this is
not a typo!) about 500x faster on ARM without FPU. It's error is less than
5% for arguments smaller than %COGL_SQRTI_ARG_5_PERCENT and less than 10%
for narguments smaller than %COGL_SQRTI_ARG_10_PERCENT. The maximum
argument that can be passed to this function is %COGL_SQRTI_ARG_MAX.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">integer square root.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">integer value</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_error_quark"
              c:identifier="cogl_texture_error_quark"
              moved-to="TextureError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="texture_unref"
              c:identifier="cogl_texture_unref"
              moved-to="Texture.unref"
              deprecated="Use cogl_object_unref() instead"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Decrement the reference count for a cogl texture.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglTexture.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform" c:identifier="cogl_transform" version="1.4">
      <doc xml:whitespace="preserve">Multiplies the current model-view matrix by the given matrix.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:whitespace="preserve">the matrix to multiply with the current model-view</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="translate" c:identifier="cogl_translate">
      <doc xml:whitespace="preserve">Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:whitespace="preserve">Distance to translate along the x-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:whitespace="preserve">Distance to translate along the y-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:whitespace="preserve">Distance to translate along the z-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vdraw_attributes"
              c:identifier="cogl_vdraw_attributes"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first_vertex" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="vdraw_indexed_attributes"
              c:identifier="cogl_vdraw_indexed_attributes"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first_vertex" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="indices" transfer-ownership="none">
          <type name="Indices" c:type="CoglIndices*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_equal_EXP"
              c:identifier="cogl_vector3_equal_EXP"
              moved-to="Vector3.equal_EXP">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1" transfer-ownership="none">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="v2" transfer-ownership="none">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_add" c:identifier="cogl_vertex_buffer_add">
      <doc xml:whitespace="preserve">Adds an attribute to a buffer, or replaces a previously added
attribute with the same name.

You either can use one of the built-in names such as "gl_Vertex", or
"gl_MultiTexCoord0" to add standard attributes, like positions, colors
and normals, or you can add custom attributes for use in shaders.

The number of vertices declared when calling cogl_vertex_buffer_new()
determines how many attribute values will be read from the supplied
@pointer.

The data for your attribute isn't copied anywhere until you call
cogl_vertex_buffer_submit(), or issue a draw call which automatically
submits pending attribute changes. so the supplied pointer must remain
valid until then. If you are updating an existing attribute (done by
re-adding it) then you still need to re-call cogl_vertex_buffer_submit()
to commit the changes to the GPU. Be carefull to minimize the number
of calls to cogl_vertex_buffer_submit(), though.

&lt;note&gt;If you are interleving attributes it is assumed that each interleaved
attribute starts no farther than +- stride bytes from the other attributes
it is interleved with. I.e. this is ok:
&lt;programlisting&gt;
|-0-0-0-0-0-0-0-0-0-0|
&lt;/programlisting&gt;
This is not ok:
&lt;programlisting&gt;
|- - - - -0-0-0-0-0-0 0 0 0 0|
&lt;/programlisting&gt;
(Though you can have multiple groups of interleved attributes)&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of your attribute. It should be a valid GLSL variable name and standard attribute types must use one of following built-in names: (Note: they correspond to the built-in names of GLSL) &lt;itemizedlist&gt; &lt;listitem&gt;"gl_Color"&lt;/listitem&gt; &lt;listitem&gt;"gl_Normal"&lt;/listitem&gt; &lt;listitem&gt;"gl_MultiTexCoord0, gl_MultiTexCoord1, ..."&lt;/listitem&gt; &lt;listitem&gt;"gl_Vertex"&lt;/listitem&gt; &lt;/itemizedlist&gt; To support adding multiple variations of the same attribute the name can have a detail component, E.g. "gl_Color::active" or "gl_Color::inactive"</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of components per attribute and must be 1, 2, 3 or 4</doc>
          <type name="guint8" c:type="guint8"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglAttributeType specifying the data type of each component.</doc>
          <type name="AttributeType" c:type="CoglAttributeType"/>
        </parameter>
        <parameter name="normalized" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE, this specifies that values stored in an integer format should be mapped into the range [-1.0, 1.0] or [0.0, 1.0] for unsigned values. If %FALSE they are converted to floats directly.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="stride" transfer-ownership="none">
          <doc xml:whitespace="preserve">This specifies the number of bytes from the start of one attribute value to the start of the next value (for the same attribute). So, for example, with a position interleved with color like this: XYRGBAXYRGBAXYRGBA, then if each letter represents a byte, the stride for both attributes is 6. The special value 0 means the values are stored sequentially in memory.</doc>
          <type name="guint16" c:type="guint16"/>
        </parameter>
        <parameter name="pointer" transfer-ownership="none">
          <doc xml:whitespace="preserve">This addresses the first attribute in the vertex array. This must remain valid until you either call cogl_vertex_buffer_submit() or issue a draw call.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_delete"
              c:identifier="cogl_vertex_buffer_delete">
      <doc xml:whitespace="preserve">Deletes an attribute from a buffer. You will need to call
cogl_vertex_buffer_submit() or issue a draw call to commit this
change to the GPU.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of a previously added attribute</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_disable"
              c:identifier="cogl_vertex_buffer_disable">
      <doc xml:whitespace="preserve">Disables a previosuly added attribute.

Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.

You don't need to call cogl_vertex_buffer_submit() after using this
function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the attribute you want to disable</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw" c:identifier="cogl_vertex_buffer_draw">
      <doc xml:whitespace="preserve">Allows you to draw geometry using all or a subset of the
vertices in a vertex buffer.

Any un-submitted attribute changes are automatically submitted before
drawing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglVerticesMode specifying how the vertices should be interpreted.</doc>
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first" transfer-ownership="none">
          <doc xml:whitespace="preserve">Specifies the index of the first vertex you want to draw with</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">Specifies the number of vertices you want to draw.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw_elements"
              c:identifier="cogl_vertex_buffer_draw_elements">
      <doc xml:whitespace="preserve">This function lets you use an array of indices to specify the vertices
within your vertex buffer that you want to draw. The indices themselves
are created by calling cogl_vertex_buffer_indices_new ()

Any un-submitted attribute changes are automatically submitted before
drawing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglVerticesMode specifying how the vertices should be interpreted.</doc>
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="indices" transfer-ownership="none">
          <doc xml:whitespace="preserve">A CoglHandle for a set of indices allocated via cogl_vertex_buffer_indices_new ()</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="min_index" transfer-ownership="none">
          <doc xml:whitespace="preserve">Specifies the minimum vertex index contained in indices</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="max_index" transfer-ownership="none">
          <doc xml:whitespace="preserve">Specifies the maximum vertex index contained in indices</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="indices_offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">An offset into named indices. The offset marks the first index to use for drawing.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:whitespace="preserve">Specifies the number of vertices you want to draw.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_enable"
              c:identifier="cogl_vertex_buffer_enable">
      <doc xml:whitespace="preserve">Enables a previosuly disabled attribute.

Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.

You don't need to call cogl_vertex_buffer_submit() after using this function</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the attribute you want to enable</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_get_n_vertices"
              c:identifier="cogl_vertex_buffer_get_n_vertices">
      <doc xml:whitespace="preserve">Retrieves the number of vertices that @handle represents</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the number of vertices</doc>
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_for_quads"
              c:identifier="cogl_vertex_buffer_indices_get_for_quads"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a vertex buffer containing the indices needed to draw pairs
of triangles from a list of vertices grouped as quads. There will
be at least @n_indices entries in the buffer (but there may be
more).

The indices will follow this pattern:

0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7 ... etc

For example, if you submit vertices for a quad like like that shown
in &lt;xref linkend="quad-indices-order"/&gt; then you can request 6
indices to render two triangles like those shown in &lt;xref
linkend="quad-indices-triangles"/&gt;.

&lt;figure id="quad-indices-order"&gt;
&lt;title&gt;Example of vertices submitted to form a quad&lt;/title&gt;
&lt;graphic fileref="quad-indices-order.png" format="PNG"/&gt;
&lt;/figure&gt;

&lt;figure id="quad-indices-triangles"&gt;
&lt;title&gt;Illustration of the triangle indices that will be generated&lt;/title&gt;
&lt;graphic fileref="quad-indices-triangles.png" format="PNG"/&gt;
&lt;/figure&gt;

owned by Cogl and should not be modified or unref'd.</doc>
      <return-value>
        <doc xml:whitespace="preserve">A %CoglHandle containing the indices. The handled is</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_indices" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of indices in the vertex buffer.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_type"
              c:identifier="cogl_vertex_buffer_indices_get_type">
      <doc xml:whitespace="preserve">Queries back the data type used for the given indices</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The CoglIndicesType used</doc>
        <type name="IndicesType" c:type="CoglIndicesType"/>
      </return-value>
      <parameters>
        <parameter name="indices" transfer-ownership="none">
          <doc xml:whitespace="preserve">An indices handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_new"
              c:identifier="cogl_vertex_buffer_indices_new"
              introspectable="0">
      <doc xml:whitespace="preserve">Depending on how much geometry you are submitting it can be worthwhile
optimizing the number of redundant vertices you submit. Using an index
array allows you to reference vertices multiple times, for example
during triangle strips.

cogl_vertex_buffer_draw_elements().</doc>
      <return-value>
        <doc xml:whitespace="preserve">A CoglHandle for the indices which you can pass to</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="indices_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #CoglIndicesType specifying the data type used for the indices.</doc>
          <type name="IndicesType" c:type="CoglIndicesType"/>
        </parameter>
        <parameter name="indices_array" transfer-ownership="none">
          <doc xml:whitespace="preserve">Specifies the address of your array of indices</doc>
          <array length="2" zero-terminated="0" c:type="void*">
            <type name="gpointer" c:type="void"/>
          </array>
        </parameter>
        <parameter name="indices_len" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of indices in indices_array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_new"
              c:identifier="cogl_vertex_buffer_new"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new vertex buffer that you can use to add attributes.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new #CoglHandle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_vertices" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of vertices that your attributes will correspond to.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_ref"
              c:identifier="cogl_vertex_buffer_ref"
              introspectable="0"
              deprecated="Use cogl_handle_ref() instead"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Increment the reference count for a vertex buffer</doc>
      <return-value>
        <doc xml:whitespace="preserve">the @handle.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a @CoglHandle.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_submit"
              c:identifier="cogl_vertex_buffer_submit">
      <doc xml:whitespace="preserve">Submits all the user added attributes to the GPU; once submitted, the
attributes can be used for drawing.

You should aim to minimize calls to this function since it implies
validating your data; it potentially incurs a transport cost (especially if
you are using GLX indirect rendering) and potentially a format conversion
cost if the GPU doesn't natively support any of the given attribute formats.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_unref"
              c:identifier="cogl_vertex_buffer_unref"
              deprecated="Use cogl_handle_unref() instead"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Decrement the reference count for a vertex buffer</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">a @CoglHandle.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="viewport"
              c:identifier="cogl_viewport"
              version="0.8.2"
              deprecated="Use cogl_set_viewport() instead"
              deprecated-version="1.2">
      <doc xml:whitespace="preserve">Replace the current viewport with the given values.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <doc xml:whitespace="preserve">Width of the viewport</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:whitespace="preserve">Height of the viewport</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_get_visual_xid_EXP"
              c:identifier="cogl_x11_onscreen_get_visual_xid_EXP">
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_get_window_xid_EXP"
              c:identifier="cogl_x11_onscreen_get_window_xid_EXP">
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_set_foreign_window_xid_EXP"
              c:identifier="cogl_x11_onscreen_set_foreign_window_xid_EXP"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="xid" transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="update" transfer-ownership="none" closure="3">
          <type name="OnscreenX11MaskCallback"
                c:type="CoglOnscreenX11MaskCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_add_filter_EXP"
              c:identifier="cogl_xlib_renderer_add_filter_EXP"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_display_EXP"
              c:identifier="cogl_xlib_renderer_get_display_EXP"
              introspectable="0">
      <return-value>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_foreign_display_EXP"
              c:identifier="cogl_xlib_renderer_get_foreign_display_EXP"
              introspectable="0">
      <return-value>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_handle_event_EXP"
              c:identifier="cogl_xlib_renderer_handle_event_EXP"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <type c:type="XEvent*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_remove_filter_EXP"
              c:identifier="cogl_xlib_renderer_remove_filter_EXP"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_event_retrieval_enabled"
              c:identifier="cogl_xlib_renderer_set_event_retrieval_enabled"
              version="1.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Sets whether Cogl should automatically retrieve events from the X
display. This defaults to %TRUE unless
cogl_xlib_renderer_set_foreign_display() is called. It can be set
to %FALSE if the application wants to handle its own event
retrieval. Note that Cogl still needs to see all of the X events to
function properly so the application should call
cogl_xlib_renderer_handle_event() for each event if it disables
automatic event retrieval.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="enable" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_foreign_display_EXP"
              c:identifier="cogl_xlib_renderer_set_foreign_display_EXP"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none">
          <type c:type="Display*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
